(require 'cl-lib)
(require 'dash)

(define-minor-mode pretty-math-mode
  "Minor mode for math"
  :init-value nil
  (font-lock-fontify-buffer)
  (if pretty-math-mode
      (font-lock-add-keywords nil gm/pretty-math-keywords)
    (font-lock-remove-keywords nil gm/pretty-math-keywords)))

(defvar gm/math-greek-upper
  '(("Gamma" . "Γ")
    ("Delta" . "Δ")
    ("Epsilon" . "Ε")
    ("Theta" . "Θ")
    ("Lambda" . "Λ")
    ("Xi" . "Ξ")
    ("Pi" . "Π")
    ("Sigma" . "Σ")
    ("Upsilon" . "Υ")
    ("Phi" . "Φ")
    ("Psi" . "Ψ")
    ("Omega" . "Ω")))

(defvar gm/math-greek-lower
  '(("alpha" . "α")
    ("beta" . "β")
    ("gamma" . "γ")
    ("delta" . "δ")
    ("epsilon" . "ε")
    ("zeta" . "ζ")
    ("eta" . "η")
    ("theta" . "θ")
    ("iota" . "ι")
    ("kappa" . "κ")
    ("lambda" . "λ")
    ("mu" . "μ")
    ("nu" . "ν")
    ("xi" . "ξ")
    ("omicron" . "ο")
    ("pi" . "π")
    ("rho" . "ρ")
    ("sigma" . "σ")
    ("tau" . "τ")
    ("upsilon" . "υ")
    ("phi" . "ϕ")
    ("chi" . "χ")
    ("psi" . "ψ")
    ("omega" . "ω")
    ("varphi" . "φ")
    ("vartheta" . "ϑ")
    ("varpi" . "ϖ")
    ("varrho" . "ϱ")
    ("varsigma" . "ς")))

(defvar gm/math-vectors
  (append
   (cl-loop for i from 65 to 90
            collect (list (concat "vec " (char-to-string i))
                          (char-to-string (+ i 120211))))
   (cl-loop for i from 97 to 122
            collect (list (concat "vec " (char-to-string i))
                          (char-to-string (+ i 120205))))))

(defvar gm/math-letters
  (append
   gm/math-greek-lower
   gm/math-greek-upper
   gm/math-vectors
   '(("aleph" . "ℵ")
     ("hbar" . "ħ")
     ("ell" . "ℓ")
     ("wp" . "℘")
     ("partial" . "∂")
     ("N" . "𝗡")
     ("Z" . "𝗭")
     ("Q" . "𝗤")
     ("R" . "𝗥")
     ("C" . "𝗖")
     ("F" . "𝗙"))))

(defvar gm/math-arrows
  '(("rightarrow" . "→")        ; Directions
    ("leftarrow" . "←")
    ("leftrightarrow" . "↔")
    ("Rightarrow" . "⇒")
    ("Leftarrow" . "⇐")
    ("Leftrightarrow" . "⇔")
    ("uparrow" . "↑")
    ("downarrow" . "↓")
    ("updownarrow" . "↕")
    ("Uparrow" . "⇑")
    ("Downarrow" . "⇓")
    ("Updownarrow" . "⇕")
    ("nearrow" . "↗")
    ("searrow" . "↘")
    ("nwarrow" . "↖")
    ("swarrow" . "↙")
    ("Longrightarrow" . "⟹")  ; Long arrows
    ("implies" . "⟹")  ; Long arrows
    ("longrightarrow" . "⟶")
    ("longleftarrow" . "⟵")
    ("Longleftarrow" . "⟸")
    ("impliedby" . "⟸")
    ("longmapsto" . "⟼")
    ("longleftrightarrow" . "⟷")
    ("Longleftrightarrow" . "⟺")
    ("iff" . "⟺")
    ("leftharpoonup" . "↼")     ; Special Arrows
    ("leftharpoondown" . "↽")
    ("rightharpoonup" . "⇀")
    ("rightharpoondown" . "⇁")
    ("rightleftharpoons" . "⇌")
    ("hookrightarrow" . "↪")
    ("hookleftarrow" . "↩")))

(defvar gm/math-operators
  '(("bigvee" . "⋁")
    ("bigwedge" . "⋀")
    ("biguplus" . "⨄")
    ("bigcap" . "⋂")
    ("bigcup" . "⋃")
    ("nabla" . "∇")
    ("prod" . "∏")
    ("coprod" . "∐")
    ("int" . "∫")
    ("iint" . "∬")
    ("iiint" . "∭")
    ("oint" . "∮")
    ("oiint" . "∯")
    ("oiiint" . "∰")
    ("sum" . "∑")
    ("bigotimes" . "⨂")
    ("bigoplus" . "⨁")
    ("bigodot" . "⨀")
    ("bigsqcup" . "⨆")
    ("bigcirc" . "◯")))

(defvar gm/math-spaced
  (append
   gm/math-arrows
  '(("geq" . "≥")
    ("ge" . "≥")
    ("leq" . "≤")
    ("le" . "≤")
    ("neq" . "≠")
    ("land" . "∧")
    ("lor" . "∨")
    ("neg" . "¬")
    ("forall" . "∀")
    ("exists" . "∃")
    ("Diamond" . "⋄")
    ("Box" . "□")
    ("models" . "⊧")
    ("bot" . "⊥")
    ("top" . "⊤")
    ("mid" . "|")
    ("cup" . "∪")
    ("cap" . "∩")
    ("setminus" . "∖")
    ("minus" . "∖")
    ("subseteq" . "⊆")
    ("subset" . "⊂")
    ("in" . "∊")
    ("ni" . "∋")
    ("notin" . "∉")
    ("mapsto" . "↦")
    ("to" . "→")
    ("times" . "×")
    ("equiv" . "≡")
    ("sqcap" . "⊓")
    ("sqcup" . "⊔")
    ("uplus" . "⊎")
    ("amalg" . "⨿")
    ("odot" . "⊙")
    ("oslash" . "⊘")
    ("otimes" . "⊗")
    ("ominus" . "⊖")
    ("oplus" . "⊕")
    ("mp" . "∓")
    ("pm" . "±")
    ("cdot" . "⋅")
    ("ast" . "∗")
    ("propto" . "∝")
    ("sqsubseteq" . "⊑")
    ("sqsupseteq" . "⊒")
    ("parallel" . "∥")
    ("dashv" . "⊣")
    ("vdash" . "⊢")
    ("succ" . "≻")
    ("prec" . "≺")
    ("approx" . "≈")
    ("succeq" . "≽")
    ("preceq" . "≼")
    ("supset" . "⊃")
    ("supseteq" . "⊇")
    ("gg" . "≫")
    ("ll" . "≪")
    ("sim" . "∼")
    ("simeq" . "≃")
    ("asymp" . "≍")
    ("smile" . "⌣")
    ("frown" . "⌢")
    ("bowtie" . "⋈")
    ("models" . "⊧")
    ("Vert" . "∥")
    ("cong" . "≅")
    ("doteq" . "≐")
    ("triangleleft" . "◁")
    ("triangleright" . "▷")
    ("bigtriangleup" . "△")
    ("bigtriangledown" . "▽")
    ("circ" . "∘")
    ("wedge" . "∧")
    ("vee" . "∨")
    ("intprod" . "｣"))))

(defvar gm/math-unspaced
  (append
   gm/math-operators
   gm/math-letters
   '(("infty" . "∞")
     ("emptyset" . "∅")
     ("dots" . "…")
     ("cdots" . "⋯")
     ("vdots" . "⋮")
     ("ddots" . "⋱")
     ("langle" . "⟨")
     ("rangle" . "⟩")
     ("rceil" . "⌉")
     ("lceil" . "⌈")
     ("rfloor" . "⌋")
     ("lfloor" . "⌊")
     ("dagger" . "†" )
     ("dag" . "†")
     ("ddag" . "‡")
     ("S" . "§")
     ("star" . "★")
     ("vDash" . "⊨")
     ("surd" . "√")
     ("angle" . "∠")
     ("triangle" . "△")
     ("flat" . "♭")
     ("natural" . "♮")
     ("sharp" . "♯")
     ("clubsuit" . "♣")
     ("diamondsuit" . "♢")
     ("heartsuit" . "♡")
     ("spadesuit" . "♠")
     ("D" . "D")
     ("left(" . "(")
     ("right)" . ")")
     ("left[" . "[")
     ("right]" . "]"))))

(defvar gm/spaced-after
  '(("Div" . [?\s (Br . Bl) ?\s (Bc . Br) ?∇ (Br . Bc) ?\s (Br . Bc) ?\s (Bc . Bl) ?·])
    ("Lapl" . [?\s (Bc . Bc) ?\s (Bc . Br) ?∆])
    ("Grad" . [?\s (Bc . Bc) ?\s (Bc . Br) ?∇])
    ("Curl" . [?\s (Br . Bl) ?\s (Bc . Br) ?∇ (Br . Bc) ?\s (Br . Bc) ?\s (Bc . Bl) ?×])
    ("int" . [?\s (Bc . Bc) ?\s (Bc . Br) ?∫])))

(defvar gm/math-commands
  '(("dd" [?\s (Br . Bc) ?𝖽] "")
    ("pd" ?∂ "")))

(defun gm/math-regexp-unspaced (name symbol)
  (list (cons (format "\\(\\\\%s{}\\)" name) symbol)
        (cons (format "\\(\\\\%s\\)[^[:alnum:]{]" name) symbol)))

(defun gm/math-regexp-spaced (name symbol)
  (setq symbol `[?\s (Br . Bl) ?\s (Bc . Bc) ,(string-to-char symbol)])
  (list (cons (format "\\(\\\\%s\\( \\|{}\\)\\)" name) symbol)
        (cons (format "\\([ ]?\\\\%s\\)[^[:alnum:]{ ]" name) symbol)))

(defun gm/math-regexp-spaced-after (name symbol)
  (cons (format "\\(\\\\%s \\)" name) symbol))

(defun gm/math-regexp-commands (command open-delim close-delim)
  (list (cons (format "\\([ ]?\\(\\\\!\\)?\\\\%s{\\)" command) open-delim)
        (cons (format "\\\\%s{[^}]*\\(}\\)" command) close-delim)))

(defvar gm/math-replacements
  (append
   (--map (gm/math-regexp-spaced-after (car it) (cdr it)) gm/spaced-after)
   (-flatten-n 1 (--map (gm/math-regexp-spaced (car it) (cdr it)) gm/math-spaced))
   (-flatten-n 1 (--map (gm/math-regexp-unspaced (car it) (cdr it)) gm/math-unspaced))
   (-flatten-n 1 (--map (gm/math-regexp-commands (car it) (nth 1 it) (nth 2 it)) gm/math-commands))))

(defvar gm/pretty-math-keywords
  (-flatten-n 1 (cl-loop for pattern in gm/math-replacements
                         collect `((,(car pattern)
                                    (0 (progn
                                         (compose-region (match-beginning 1) (match-end 1)
                                                         ,(cdr pattern)
                                                         'decompose-region)
                                         nil)))))))

(provide 'gm-pretty-math)

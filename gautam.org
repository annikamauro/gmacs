#+TITLE: Emacs Configuration
* Starting Up
** Time Startup
On start-up, display how quickly emacs started up.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Add Package Sources
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives
	     '("melpa" . "https://melpa.org/packages/"))
#+END_SRC
Use ~use-package~.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
	(package-refresh-contents)
	(package-install 'use-package))
#+END_SRC
Always.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC
Use ~M-x package-refresh-contents~ to reload the list of packages after adding the package sources for the first time.
** Add Elisp Directory and Other Files
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/home/gautam/.emacs.d/elisp/")
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(require 'use-package)
#+END_SRC
If I ever need to load files outside of my package system, I know where to find
them. I also set up ~use-package~ here.
** Common Lisp
#+BEGIN_SRC emacs-lisp
(require 'cl)
#+END_SRC
* General Configuration
** Graphics
*** Decluttering
**** Splash Screen
Get rid of that ugly splash screen.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
**** Fullscreen
Start emacs in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "")
#+END_SRC
**** Bars
Menus are not required; neither is the scroll bar.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
It is no longer the 90s. Toolbars and their little icons are not cool.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC
**** Cursor Blinking
The cursor should not blink.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor 1)
#+END_SRC
**** Notifications
**** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
**** Auto-revert
Turn off reverting buffer messages.
#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
#+END_SRC
**** Autosave
Turn off autosave messages. To do this, we define our own auto-save function and
replace the built-in one with ours.
#+BEGIN_SRC emacs-lisp
(setq auto-save-timeout 99999)
(defvar bjm/auto-save-timer nil
  "Timer to run `bjm/auto-save-silent'")
(defvar bjm/auto-save-interval 5
  "How often in seconds of idle time to auto-save with `bjm/auto-save-silent'")
(defun bjm/auto-save-silent ()
  "Auto-save all buffers silently"
  (interactive)
  (do-auto-save t))
(setq bjm/auto-save-timer
      (run-with-idle-timer 0 bjm/auto-save-interval 'bjm/auto-save-silent))
#+END_SRC
**** Modeline
Keep a simpler modeline...
#+BEGIN_SRC emacs-lisp
(use-package diminish
    :defer 1)
#+END_SRC
and a smarter one.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
    :defer 2
    :config
    (sml/setup))
#+END_SRC
*** Modeline
**** Time
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
**** Column
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Ban Whitespace
#+BEGIN_SRC emacs-lisp
 (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Indentation
**** Keep Things Indented
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :disabled
    :diminish aggressive-indent-mode
    :hook
    (prog-mode . aggressive-indent-mode)
    (python-mode . (lambda () (aggressive-indent-mode -1))))
#+END_SRC
**** Wrap Indented Lines Sensibly
This way, indented lines that are wrapped with ~visual-line-mode~ do not begin at character 0, but from where they are indented.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap)
  (when (fboundp 'adaptive-wrap-prefix-mode)
  (defun my-activate-adaptive-wrap-prefix-mode ()
    "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
  (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))
#+END_SRC
*** Mouse Scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
#+END_SRC
*** Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq indent-line-function 'insert-tab)
#+END_SRC
** Ease of Use
*** Dialogs
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Ido Mode
"
#+BEGIN_SRC emacs-lisp
(use-package ido)
(use-package ido-grid-mode)
(require 'flx-ido)
(require 'ido-completing-read+)
(require 'smex)
(smex-initialize)
(ido-mode 1)
(ido-grid-mode 1)
(flx-ido-mode 1)
(ido-ubiquitous-mode 1)
(ido-everywhere 1)
(setq ido-grid-bind-keys t)
(setq ido-enable-flex-matching t)
(setq ido-use-filename-at-point 'guess)
(setq ido-create-new-buffer 'always)
(setq ido-use-faces nil)
(setq ido-file-extensions-order '(".org" ".tex" ".py"))
#+END_SRC
*** Delete The Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
*** Autocomplete
**** ignore case
#+BEGIN_SRC emacs-lisp
(setq completion-ignore-case t)
#+END_SRC
**** Company
#+BEGIN_SRC emacs-lisp
(use-package company
    :diminish company-mode
    :hook
    (after-init . global-company-mode))
#+END_SRC
*** Spellchek
#+BEGIN_SRC emacs-lisp
(use-package flyspell
    :defer 1
    :hook (text-mode . flyspell-mode)
    :diminish
    :bind (:map flyspell-mouse-map
                ([down-mouse-3] . #'flyspell-correct-word)
                ([mouse-3]      . #'undefined)))
#+END_SRC
*** Kill Current Buffer
Kill the current buffer.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'bjm/kill-this-buffer)
#+END_SRC
*** Split Vertically by Default
Gotta maximize that vertical screen space.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves so much clutter
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
Also, I have lots of disk space, and not so much patience when I lose an important file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
**** History
It's nice to have a history of commands so that when you open a new emacs instance, you can get right to work.
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
***** Desktop
On a similar note, save the desktop.
#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
(setq desktop-restore-eager 250)
#+END_SRC
Make two buffers with the same file name distinguishable.
#+BEGIN_SRC emacs-lisp
(use-package uniquify
    :defer 1
    :ensure nil
    :custom
    (uniquify-after-kill-buffer-p t)
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t))
#+END_SRC
***** Save Place
Opens a file to the same place in which it was last closed.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
*** Dictionary
#+BEGIN_SRC emacs-lisp
(require 'sdcv-mode)
#+END_SRC
*** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Better Searching (Ivy and Swiper)
Enable ivy-mode.
#+BEGIN_SRC emacs-lisp
(use-package ivy)
(use-package swiper
  :ensure t
  :config
  (ivy-mode 1)
  (diminish 'ivy-mode)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-display-style 'fancy)
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "C-c C-r") 'ivy-resume))
#+END_SRC
#+END_SRC
Get swiper to recentre the display when it exits.
#+BEGIN_SRC emacs-lisp
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter)
  )
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_SRC
*** Abbreviations
Load them.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/abbrevs.el")
#+END_SRC
Always use this wonderful tool.
#+BEGIN_SRC emacs-lispn
(set-default 'abbrev-mode t)
#+END_SRC
Because it's always on, we don't need to know about it.
#+BEGIN_SRC emacs-lisp
(diminish 'abbrev-mode)
#+END_SRC
Save them in the ~.emacs.d~ dir.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/abbrevs.el")
#+END_SRC
Save abbreviations upon saving a file.
#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silent)
#+END_SRC
*** Thing at Point
#+BEGIN_SRC emacs-lisp
(require 'thingatpt)
#+END_SRC
*** Electric Pairs
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '(
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
*** Easily Navigate to Word (Avy Mode)
#+BEGIN_SRC emacs-lisp
(use-package avy :ensure t
  :commands (avy-goto-char)
  :config
  (setq avy-background t)
  :custom-face
  (avy-lead-face ((t(:weight bold))))
  (avy-lead-face-0 ((t(:weight bold))))
  )
(global-set-key (kbd "M-i") 'avy-goto-char-2)
#+END_SRC
*** Autocorrect
**** Double Caps
#+BEGIN_SRC emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

(add-hook 'text-mode-hook #'dubcaps-mode)
#+END_SRC
**** Abbrevs
#+BEGIN_SRC emacs-lisp
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+END_SRC
*** Remember File Variables
#+BEGIN_SRC emacs-lisp
(defun risky-local-variable-p (sym &optional _ignored) nil)
#+END_SRC
*** Reload Files On Update
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
*** Complete Reload
Completely reload emacs, by reloading the init file.
#+BEGIN_SRC emacs-lisp
(defun gm/reload ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(require 'magit)
(global-set-key (kbd "C-x g") 'magit-status)
(setq magit-completing-read-function 'magit-ido-completing-read)
#+END_SRC
** Dired
*** Revert Buffer
Have the most up-to-date version of the buffer when using dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
*** Declutter
#+BEGIN_SRC emacs-lisp
(defun xah-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'xah-dired-mode-setup)
#+END_SRC
*** Copy and Delete
Allow dired to recursively copy and delete directories. ~always~ ensures that no
confirmation dialog comes up, and ~top~ does it only once.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies (quote always))
(setq dired-recursive-deletes (quote top))
#+END_SRC
*** Speed Sorting
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :ensure t
  :config
  (dired-quick-sort-setup))
#+END_SRC
** God Mode
Enable god-mode.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
  :ensure t)
#+END_SRC
*** Indicate Mode with Modeline
#+BEGIN_SRC emacs-lisp
(defun me//god-mode-indicator ()
  (cond (god-local-mode
         (progn
           (set-cursor-color "#dc322f")))
        (t
         (progn
           (set-cursor-color "#657b83")))))

(add-hook 'god-mode-enabled-hook #'me//god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'me//god-mode-indicator)
#+END_SRC
** PDF Tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
  :pin manual
  :config
  (pdf-tools-install)
  (add-hook 'pdf-view-mode-hook (lambda () (pdf-view-midnight-minor-mode)))
  (setq pdf-view-midnight-colours '("#657b83" . "#fdf6e3"))
  (setq-default pdf-view-display-size 'fit-page) ;
  (setq pdf-annot-activate-created-annotations t)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (setq pdf-view-resize-factor 1.1)
  (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
  (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete))
#+END_SRC
* Global Keybindings
** Bind Key
#+BEGIN_SRC emacs-lisp
(require 'bind-key)
(use-package which-key
  :defer nil
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** The Actual Keybindings
*** Easy Meta
Alt is hard to type easily.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-SPC") 'smex)
(global-set-key (kbd "C-M-SPC") 'smex-major-mode-commands)
(global-set-key (kbd "C-c C-SPC") 'execute-extended-command)
#+END_SRC
*** Set Mark
Need to have a replacement because we rebound ~C-SPC~.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-t") 'set-mark-command)
#+END_SRC
*** Shell Backwards Kill
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-w" 'backward-kill-word)
#+END_SRC
*** Easy Kill
Add extra keybinding to account for missing.
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-k" 'kill-region)
(global-set-key "\C-c\C-k" 'kill-region)
#+END_SRC
*** Shell Backspace
Use shell like ~C-h~ instead of Backspace.
#+BEGIN_SRC emacs-lisp
(define-key key-translation-map [?\C-h] [?\C-?])
(global-set-key (kbd "<f1>") 'help-command)
#+END_SRC
*** Better Buffers
Switch better.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'ido-switch-buffer)
#+END_SRC
Use ibuffer.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC
**** Ibuffer Hydra
Courtesy of [[https://github.com/abo-abo/hydra/wiki/Ibuffer][hydra wiki]].
#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" quit-window "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC
Use with period.
#+BEGIN_SRC emacs-lisp
(define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)
#+END_SRC
*** Word Count
Count org-wc.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-f9>") 'org-wc-display)
#+END_SRC
*** Window Management
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-1") 'delete-other-windows)
(global-set-key (kbd "C-x C-2") 'split-window-below)
(global-set-key (kbd "C-x C-3") 'split-window-right)
(global-set-key (kbd "C-x C-0") 'delete-window)
#+END_SRC
*** Transpose Sentences and Paragraphs
Add an alias to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
#+END_SRC
*** Normal Undo
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z"))
(global-set-key  (kbd "C-z") 'undo)
(global-set-key (kbd "C-x C-u") 'undo)
#+END_SRC
*** Org LaTeX Export
#+BEGIN_SRC emacs-lisp
(global-set-key  (kbd "C-c b") 'gm/org-latex-export)
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC
*** Org Preview Latex
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "df" 'my/org-toggle-latex-fragment)
#+END_SRC
*** God Mode
Easily enter god mode.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "jk" 'god-local-mode)
#+END_SRC
* Theme
** Font Face
Normally use Hack.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Hack")
(set-frame-font "Hack" nil t)
#+END_SRC
** Solarized Light
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme)
(load-theme 'solarized-light t)
#+END_SRC
** Centered Buffer
#+BEGIN_SRC emacs-lisp
(use-package centered-window
  :ensure t
  :diminish centered-window-mode)
(centered-window-mode 1)
#+END_SRC
** Autofill
Use visual line mode everywhere.
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(eval-after-load "diminish" '(diminish 'auto-fill-mode-mode))
#+END_SRC
Quickly autofill the entire buffer by paragraph.
#+BEGIN_SRC emacs-lisp
(defun fill-buffer ()
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (fill-region (point-min) (point-max)))))
#+END_SRC
*** 80 Columns
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
        (lambda() (set-fill-column 80)))
#+END_SRC
** Highlighting
*** Syntax
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
*** Rainbow Mode
#+BEGIN_SRC emacs-lisp
(rainbow-mode 1)
(diminish 'rainbow-mode)
#+END_SRC
*** Source Code Blocks
Native syntax highlighting for source blocks in org mode.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC
*** Sentences
Highlight sentences. Credit to [[https://github.com/milkypostman/hl-sentence][Donald Curtis]].
#+BEGIN_SRC emacs-lisp
(require 'hl-sentence)
(add-hook 'org-mode-hook 'hl-sentence-mode)
#+END_SRC
Use Solarized Light cyan to highlight.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'hl-sentence nil
                     :background "#fdf6e3"
                     :foreground "#2aa198")
#+END_SRC
*** Parentheses
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'expression)
#+END_SRC
*** Transient Mark
#+BEGIN_SRC emacs-lisp
(setq transient-mark-mode t)
#+END_SRC
* Org
** Setup
We have to use ~require~ to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'ox-latex)
(use-package org
  :bind
  ("C-c l" . org-store-link)
  ("C-c a" . org-agenda)
  ("M-h" . org-mark-element)
  ("C-c c" . org-capture)
  :diminish
  (org-indent-mode)
  :custom
  (org-startup-indented t))
#+END_SRC
** Ox-hugo
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
    :ensure t
    :after ox)
(require 'ox-hugo-auto-export)
#+END_SRC
** Prettifying
*** Hide Emphasis
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Hide Macro Marks
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Org Bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets)
(add-hook 'org-mode-hook
  (defun org-bullets-mode-enable ()
    (org-bullets-mode 1)))
#+END_SRC
*** Bullet List
Have lists begun by, for example, ~-~ look like a bullet-pointed list.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

#+END_SRC
*** Visual Lines
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'visual-line-mode)
#+END_SRC
*** Typography
**** Quotation Marks
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map "\"" #'endless/round-quotes)
(defun endless/round-quotes (italicize)
  "Insert “” and leave point in the middle.
With prefix argument ITALICIZE, insert /“”/ instead
\(meant for org-mode).
Inside a code-block, just call `self-insert-command'."
  (interactive "P")
  (if (and (derived-mode-p 'org-mode)
           (org-in-block-p '("src" "latex" "html")))
      (call-interactively #'self-insert-command)
    (if (looking-at "”[/=_\\*]?")
        (goto-char (match-end 0))
      (when italicize
        (if (derived-mode-p 'markdown-mode)
            (insert "__")
          (insert "//"))
        (forward-char -1))
      (insert "“”")
      (forward-char -1))))
#+END_SRC
**** Apostrophes
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map "'" #'endless/apostrophe)
;; (eval-after-load 'markdown-mode
;;   '(define-key markdown-mode-map "'"
;;      #'endless/apostrophe))

(defun endless/apostrophe (opening)
  "Insert ’ in prose or `self-insert-command' in code.
With prefix argument OPENING, insert ‘’ instead and
leave point in the middle.
Inside a code-block, just call `self-insert-command'."
  (interactive "P")
  (if (and (derived-mode-p 'org-mode)
           (org-in-block-p '("src" "latex" "html")))
      (call-interactively #'self-insert-command)
    (if (looking-at "['’][=_/\\*]?")
        (goto-char (match-end 0))
      (if (null opening)
          (insert "’")
        (insert "‘’")
        (forward-char -1)))))
#+END_SRC
**** Ispell
#+BEGIN_SRC emacs-lisp
(require 'ispell)

;;; Tell ispell.el that ’ can be part of a word.
(setq ispell-local-dictionary-alist
      `((nil "[[:alpha:]]" "[^[:alpha:]]"
             "['\x2019]" nil ("-B") nil utf-8)))

;;; Don't send ’ to the subprocess.
(defun endless/replace-apostrophe (args)
  (cons (replace-regexp-in-string
         "’" "'" (car args))
        (cdr args)))
(advice-add #'ispell-send-string :filter-args
            #'endless/replace-apostrophe)

;;; Convert ' back to ’ from the subprocess.
(defun endless/replace-quote (args)
  (if (not (derived-mode-p 'org-mode))
      args
    (cons (replace-regexp-in-string
           "'" "’" (car args))
          (cdr args))))
(advice-add #'ispell-parse-output :filter-args
            #'endless/replace-quote)
#+END_SRC
** LaTeX
*** Use Cleverref
#+BEGIN_SRC emacs-lisp
(defun org-latex-ref-to-cref (text backend info)
  "Use \\cref instead of \\ref in latex export."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string "\\\\ref{" "\\\\cref{" text)))

(add-to-list 'org-export-filter-final-output-functions
             'org-latex-ref-to-cref)
#+END_SRC
*** Export Command
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-f4>") 'org-latex-export-to-pdf)
#+END_SRC
*** Autocomplete ~$~
#+BEGIN_SRC emacs-lisp
(defvar org-electric-pairs '((?$ . ?$) )) "Electric pairs for org-mode."
(defun dollar-add-electric-pairs ()
  (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))
  (setq-local electric-pair-text-pairs electric-pair-pairs))
(add-hook 'org-mode-hook 'dollar-add-electric-pairs)
(add-hook 'LaTeX-mode-hook 'dollar-add-electric-pairs)
#+END_SRC
*** Highlighting
Inline LaTeX such as $y = mx + b$ will appear in a different colour.
#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex))
#+END_SRC
*** Scaling Preview
By default, it's really small on my HiDPI screen.
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-options (plist-put org-format-latex-options :scale 1.0))
#+END_SRC
*** Export LaTeX Quotes
#+BEGIN_SRC emacs-lisp
(setq org-export-with-smart-quotes t)
#+END_SRC
*** Use XeTeX
#+BEGIN_SRC emacs-lisp
(setq org-latex-to-pdf-process
  '("xelatex -interaction nonstopmode %f"
     "xelatex -interaction nonstopmode %f")) ;; for multiple passes
#+END_SRC
*** Don't Break Paragraph on Comments
Remove comments from org document when exporting to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                    'comment 'identity))
    do
    (setf (buffer-substring (org-element-property :begin comment)
                (org-element-property :end comment))
          "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Equation Preview
Use overlay library.
Obtained from [[https://gist.github.com/cvcore/760008a4dfb2eadf42afdc9cf01ef979][Charles Wang]].
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar cw/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on. Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)"
  )

(setq cw/org-valid-fragment-type
      '(latex-fragment
        latex-environment
        link))

(defun cw/org-curr-fragment ()
  "Returns the type and position of the current fragment available for preview inside org-mode. Returns nil at non-displayable fragments"
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type cw/org-valid-fragment-type)
      (list fr-type
            (org-element-property :begin fr))))
  )

(defun cw/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type)
               (eq 'latex-environment fr-type))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov))))
          ((eq 'link fr-type)
           nil;; delete image overlay here?
           ))
    ))

(defun cw/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type) ;; latex stuffs
               (eq 'latex-environment fr-type))
           (when (cw/org-curr-fragment) (org-preview-latex-fragment))) ;; only toggle preview when we're in a valid region (for inserting in the front of a fragment)


          ((eq 'link fr-type) ;; for images
           (let ((fr-end (org-element-property :end (org-element-context))))
             (org-display-inline-images nil t fr-begin fr-end))))
    ))


(defun cw/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment"
  (and (eq 'org-mode major-mode)
       (let ((curr (cw/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            cw/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr cw/org-last-fragment)))

           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment)
             ;; now remove current image
             (cw/org-remove-fragment-overlay curr)
             ;; and save new fragment
             )
           (setq cw/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            cw/org-last-fragment)
           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment))

           ;; unset last fragment
           (setq cw/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not cw/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (cw/org-remove-fragment-overlay curr)
             )
           (setq cw/org-last-fragment curr))
          ))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display nil t)))
#+END_SRC
*** CDLaTeX
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC
*** Export Classes
**** Tufte-LaTeX
#+BEGIN_SRC emacs-lisp
(require 'ox-tufte-latex)
(require 'ox-extra)
#+END_SRC
***** Command Links
****** No Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
"latex" nil
(lambda (path desc format)
  (when(eq format 'latex)
    (format "\\%s{%s}" path desc))))
#+END_SRC
****** One Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "latex-opt" nil
 (lambda (path desc format)
   (when (eq format 'latex)
     (let* ((desc-list (split-string desc ";"))
            (opt (nth 1 desc-list))
            (arg (nth 0 desc-list)))
       (format "\\%s%s{%s}" path
               (if (equal "" opt) opt (format "[%s]" opt))
               arg)))))
#+END_SRC
***** Classes
****** Handout
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
'("tufte-handout"
"\\documentclass[symmetric,nobib]{gm-tufte-handout}
   [NO-DEFAULT-PACKAGES]"
("\\section{%s}" . "\\section*{%s}")
("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
****** Book
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
'("tufte-book"
"\\documentclass[twoside,nobib]{tufte-book}
  [NO-DEFAULT-PACKAGES]"
("\\part{%s}" . "\\part*{%s}")
("\\chapter{%s}" . "\\chapter*{%s}")
("\\section{%s}" . "\\section*{%s}")
("\\subsection{%s}" . "\\subsection*{%s}")
("\\paragraph{%s}" . "\\paragraph*{%s}")))
#+END_SRC
***** Biber
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
        "biber %b"
        "pdflatex -interaction nonstopmode -output-directory %o %f"
        "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
***** Keyword Search
#+BEGIN_SRC emacs-lisp
(defun jk-org-kwds ()
  "parse the buffer and return a cons list of (property . value)
from lines like:
#+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
                   (lambda (keyword) (cons (org-element-property :key keyword)
                                           (org-element-property :value keyword)))))

(defun jk-org-kwd (KEYWORD)
  "get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (jk-org-kwds))))
#+END_SRC
**** Assignment
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("lecture"
                 "\\documentclass[11pt]{lecture}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
*** Mass Export
#+BEGIN_SRC emacs-lisp
(defun org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-latex-export-to-latex nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))

(defun gm/org-latex-export ()
  (interactive)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (org-narrow-to-subtree)
    (org-export-headlines-to-pdf)
    (widen)))
#+END_SRC
* TeX
** AUCTeX
#+BEGIN_SRC emacs-lisp
(use-package auctex
  :defer t
  :ensure t)
(require 'tex-site)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-PDF-mode t)
(setq preview-auto-cache-preamble t)
(setq TeX-source-correlate-method 'synctex)
(add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'TeX-fold-mode)
(defun turn-on-outline-minor-mode ()
  (outline-minor-mode 1))
(add-hook 'LaTeX-mode-hook 'turn-on-outline-minor-mode)
(add-hook 'latex-mode-hook 'turn-on-outline-minor-mode)
(setq outline-minor-mode-prefix "\C-c \C-o") ; Or something else
(setq LaTeX-eqnarray-label "eq"
      LaTeX-equation-label "eq"
      LaTeX-figure-label "fig"
      LaTeX-table-label "tab"
      LaTeX-myChapter-label "chap"
      TeX-auto-save t
      TeX-newline-function 'reindent-then-newline-and-indent
      TeX-parse-self t
      LaTeX-section-hook
      '(LaTeX-section-heading
        LaTeX-section-title
        LaTeX-section-toc
        LaTeX-section-section
        LaTeX-section-label))
#+END_SRC
*** Auto Preview
#+BEGIN_SRC emacs-lisp
(defvar my/was-inside-math nil)

(defun my/preview-when-leaving-math ()
  (let ((in-math (texmathp)))
    (cond (in-math
           (setq my/was-inside-math t))
          ((and (not in-math)
                my/was-inside-math)
           (progn
             (condition-case ex
                 (unless (get-process "Preview-Ghostscript")
                   (preview-at-point))
               ('error
                (message (format "Could not invoke Preview: %s" ex)))))))))

;; (add-hook 'LaTeX-mode-hook
;;           (lambda ()
;;             (add-hook 'post-command-hook 'my/preview-when-leaving-math nil t)))
#+END_SRC
*** Diffing
#+BEGIN_SRC
(use-package latexdiff)
#+END_SRC
*** Prettifying
Don't make super and subscripts smaller.
#+BEGIN_SRC emacs-lisp
(setq font-latex-fontify-script nil)
#+END_SRC
Make preview size bigger.
#+BEGIN_SRC emacs-lisp
(set-default 'preview-scale-function 2.0)
#+END_SRC
*** SyncTeX
Obtained from [[https://tex.stackexchange.com/questions/29813/setup-synctex-with-emacs][from here]].
#+BEGIN_SRC emacs-lisp
; SyncTeX basics

; un-urlify and urlify-escape-only should be improved to handle all special characters, not only spaces.
; The fix for spaces is based on the first comment on http://emacswiki.org/emacs/AUCTeX#toc20

(defun un-urlify (fname-or-url)
  "Transform file:///absolute/path from Gnome into /absolute/path with very limited support for special characters"
  (if (string= (substring fname-or-url 0 8) "file:///")
      (url-unhex-string (substring fname-or-url 7))
    fname-or-url))

(defun urlify-escape-only (path)
  "Handle special characters for urlify"
  (replace-regexp-in-string " " "%20" path))

(defun urlify (absolute-path)
  "Transform /absolute/path to file:///absolute/path for Gnome with very limited support for special characters"
  (if (string= (substring absolute-path 0 1) "/")
      (concat "file://" (urlify-escape-only absolute-path))
      absolute-path))


; SyncTeX backward search - based on http://emacswiki.org/emacs/AUCTeX#toc20, reproduced on https://tex.stackexchange.com/a/49840/21017

(defun th-evince-sync (file linecol &rest ignored)
  (let* ((fname (un-urlify file))
         (buf (find-file fname))
         (line (car linecol))
         (col (cadr linecol)))
    (if (null buf)
        (message "[Synctex]: Could not open %s" fname)
      (switch-to-buffer buf)
      (goto-line (car linecol))
      (unless (= col -1)
        (move-to-column col)))))

(defvar *dbus-evince-signal* nil)

(defun enable-evince-sync ()
  (require 'dbus)
  ; cl is required for setf, taken from: http://lists.gnu.org/archive/html/emacs-orgmode/2009-11/msg01049.html
  (require 'cl)
  (when (and
         (eq window-system 'x)
         (fboundp 'dbus-register-signal))
    (unless *dbus-evince-signal*
      (setf *dbus-evince-signal*
            (dbus-register-signal
             :session nil "/org/gnome/evince/Window/0"
             "org.gnome.evince.Window" "SyncSource"
             'th-evince-sync)))))

(add-hook 'LaTeX-mode-hook 'enable-evince-sync)


; SyncTeX forward search - based on https://tex.stackexchange.com/a/46157

;; universal time, need by evince
(defun utime ()
  (let ((high (nth 0 (current-time)))
        (low (nth 1 (current-time))))
   (+ (* high (lsh 1 16) ) low)))

;; Forward search.
;; Adapted from http://dud.inf.tu-dresden.de/~ben/evince_synctex.tar.gz
(defun auctex-evince-forward-sync (pdffile texfile line)
  (let ((dbus-name
     (dbus-call-method :session
               "org.gnome.evince.Daemon"  ; service
               "/org/gnome/evince/Daemon" ; path
               "org.gnome.evince.Daemon"  ; interface
               "FindDocument"
               (urlify pdffile)
               t     ; Open a new window if the file is not opened.
               )))
    (dbus-call-method :session
          dbus-name
          "/org/gnome/evince/Window/0"
          "org.gnome.evince.Window"
          "SyncView"
          (urlify-escape-only texfile)
          (list :struct :int32 line :int32 1)
  (utime))))

(defun auctex-evince-view ()
  (let ((pdf (file-truename (concat default-directory
                    (TeX-master-file (TeX-output-extension)))))
    (tex (buffer-file-name))
    (line (line-number-at-pos)))
    (auctex-evince-forward-sync pdf tex line)))

;; New view entry: Evince via D-bus.
(setq TeX-view-program-list '())
(add-to-list 'TeX-view-program-list
         '("Evince" auctex-evince-view))

;; Prepend Evince via D-bus to program selection list
;; overriding other settings for PDF viewing.
(setq TeX-view-program-selection '())
(add-to-list 'TeX-view-program-selection
         '(output-pdf "Evince"))
#+END_SRC
** Electric Dollars and Parens
Insert dollar signs electrically.
#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook
	  (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			  (cons "$" "$"))))
(add-hook 'LaTeX-mode-hook
	  (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			  (cons "$" "$"))))
(add-hook 'text-mode-hook
	  (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			  (cons "(" ")"))))
#+END_SRC
** CDLaTeX
I use this package to easily insert math characters.
#+BEGIN_SRC emacs-lisp
(use-package cdlatex)
#+END_SRC
Automatically turn on when using LaTeX.
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
#+END_SRC
Insert math with semicolon.
#+BEGIN_SRC emacs-lisp
(setq cdlatex-math-symbol-prefix ?;)
#+END_SRC
* Snippets
** Load Snippets
#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(use-package yasnippet)
(eval-after-load "diminish"
  '(progn
     (eval-after-load "yasnippet"
       '(diminish 'yas-minor-mode))))
(yas-global-mode 1)
#+END_SRC
** SPC Expansion
Use SPC instead of TAB to expand snippets.
#+BEGIN_SRC emacs-lisp
(define-key yas-minor-mode-map (kbd "<tab>") nil)
(define-key yas-minor-mode-map (kbd "TAB") nil)
(define-key yas-minor-mode-map (kbd "SPC")
  (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
#+END_SRC
** Vim-like Ultisnips
Use texmathp to tell if you are in math mode.
#+BEGIN_SRC emacs-lisp
(require 'texmathp)
#+END_SRC
Using a hydra, I setup automatic expansion of yasnippets; when a leader key is
pressed, that key is inserted, but if the next key of a defined sequence is
pressed, the leader key is erased and the snippet is expanded.
#+BEGIN_SRC emacs-lisp
(require 'hydra)
#+END_SRC
For the fraction command, we use general.el.
#+BEGIN_SRC emacs-lisp
(require 'general)
#+END_SRC
*** Helper Functions
**** Delete n Characters
Delete n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/delete-chars (n)
  (dotimes (i n) (delete-char -1)))
#+END_SRC
**** Last n Characters
Return the last n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n)
  (buffer-substring-no-properties (- (point) n) (point)))
#+END_SRC
**** Expand Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/expand-snippet (name)
  (yas-expand-snippet (yas-lookup-snippet name)))
#+END_SRC
**** Check Correct Prefix
Most of my snippets for math mode are longer than two characters. In this case,
I need to check that the correct characters precede the typed ones before
executing a snippet. For example, I should only execute the "sin" snippet after
typing "in" if the character "s" precedes "in." This function returns true if
the given string, not including the last character, precedes the point.
#+BEGIN_SRC emacs-lisp
(defun gm/prefix-before-point (key)
  (let ((len (length key)))
    (equal (substring key 0 (1- len))
           (gm/last-n-chars (1- len)))
    ))
#+END_SRC
**** Math Mode Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/snippet (key snippet)
  (let ((len (length key)))
    (if (and (texmathp) (gm/prefix-before-point key))
        (progn
          (gm/delete-chars (- len 1))
          (gm/expand-snippet snippet))
      (insert (substring key (- len 1) len))
    )
    ))
#+END_SRC
*** Squared, Square Root
#+BEGIN_SRC emacs-lisp
(defhydra hydra-s (:color blue
                          :body-pre (insert "s")
                          :idle 1.0)
  ("q" (if (gm/prefix-before-point "sq")
           (cond ((gm/prefix-before-point "nsq") (gm/snippet "nsq" "nsqrt"))
                 (t (gm/snippet "sq" "sqrt")))
         (insert "n")) "(a)tan")
  ("r" (gm/snippet "sr" "squared") "squared")
  ("t" (gm/snippet "list" "list") "list")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "s") 'hydra-s/body)
#+END_SRC
*** Cubed, Subset
#+BEGIN_SRC emacs-lisp
(defhydra hydra-c (:color blue
                          :body-pre (insert "c")
                          :idle 1.0)
  ("b" (gm/snippet "cb" "cubed") "cubed")
  ("c" (gm/snippet "cc" "subset") "subset")
  ("-" (insert "-") "dash"))

 (global-set-key (kbd "c") 'hydra-c/body)
#+END_SRC
*** Derivative
#+BEGIN_SRC emacs-lisp
(defhydra hydra-d (:color blue
                          :body-pre (insert "d")
                          :idle 1.0)
  ("d" (cond ((gm/prefix-before-point "dd")
              (cond ((gm/prefix-before-point "pdd") (gm/snippet "pdd" "partial"))
                    (t (gm/snippet "dd" "derivative-one-term"))))
             (t (insert "d"))) "(p)differential")
  ("v" (cond ((gm/prefix-before-point "dv")
              (cond ((gm/prefix-before-point "pdv") (gm/snippet "pdv" "partial-derivative"))
                    (t (gm/snippet "dv" "derivative"))))
             (t (insert "v"))) "(p)derivative")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "d") 'hydra-d/body)
#+END_SRC
*** Partial Derivative, Norm, Brackets
#+BEGIN_SRC emacs-lisp
(defhydra hydra-r (:color blue
                          :body-pre (insert "r")
                          :idle 1.0)
  ("t" (gm/snippet "part" "partial-derivative") "partial")
  ("m" (gm/snippet "norm" "norm") "norm")
  ("9" (gm/snippet "lr9" "parentheses") "parentheses")
  ("[" (gm/snippet "lr[" "brackets") "brackets")
  ("{" (gm/snippet "lr{" "set") "set")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "r") 'hydra-r/body)
#+END_SRC
*** Inverse, Integral, In
#+BEGIN_SRC emacs-lisp
(defhydra hydra-n (:color blue
                          :body-pre (insert "n")
                          :idle 1.0)
  ("t" (if (gm/prefix-before-point "int")
           (cond ((gm/prefix-before-point "iint") (gm/snippet "iint" "iintegral"))
                 ((gm/prefix-before-point "oint") (gm/snippet "oint" "ointegral"))
                 ((gm/prefix-before-point "dint") (gm/snippet "dint" "dintegral"))
                 (t (gm/snippet "int" "integral")))
         (insert "t")) "integral")
  ("v" (gm/snippet "inv" "inverse") "inverse")
  ("n" (gm/snippet "inn" "in") "in")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "n") 'hydra-n/body)
#+END_SRC
*** Maps To
#+BEGIN_SRC emacs-lisp
(defhydra hydra-exc (:color blue
                         :body-pre (insert "!")
                         :idle 1.0)
(">" (gm/snippet "!>" "maps-to") "maps-to")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "!") 'hydra-exc/body)
#+END_SRC
*** Implies
#+BEGIN_SRC emacs-lisp
(defhydra hydra-eq (:color blue
                         :body-pre (insert "=")
                         :idle 1.0)
(">" (gm/snippet "=>" "implies") "implies")
("=" (gm/snippet "==" "split-equals") "&=")
("-" (insert "-") "dash"))

(global-set-key (kbd "=") 'hydra-eq/body)
#+END_SRC
*** Limit, Sin
#+BEGIN_SRC emacs-lisp
(defhydra hydra-i (:color blue
                          :body-pre (insert "i")
                          :idle 1.0)
  ("m" (gm/snippet "lim" "limit") "limit")
  ("l" (gm/snippet "ceil" "ceiling") "ceiling")
  ("m" (if (gm/prefix-before-point "im")
           (cond ((gm/prefix-before-point "dim") (gm/snippet "dim" "dim"))
                 ((gm/prefix-before-point "lim") (gm/snippet "lim" "limit"))
                 (t (gm/snippet "im" "image")))
         (hydra-m/body)) "dimension/image")
  ("n" (if (gm/prefix-before-point "sin")
           (cond ((gm/prefix-before-point "asin") (gm/snippet "asin" "asin"))
                 (t (gm/snippet "sin" "sin")))
         (hydra-n/body)) "(a)sin")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "i") 'hydra-i/body)
#+END_SRC
*** Sum
#+BEGIN_SRC emacs-lisp
(defhydra hydra-u (:color blue
                          :body-pre (insert "u")
                          :idle 1.0)
  ("m" (if (gm/prefix-before-point "sum")
           (cond ((gm/prefix-before-point "pairsum") (gm/snippet "pairsum" "pairsum"))
                 (t (gm/snippet "sum" "sum")))
         (insert "m")) "sum")
  ("n" (gm/snippet "fun" "function") "function")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "u") 'hydra-u/body)
#+END_SRC
*** Less Than
#+BEGIN_SRC emacs-lisp
(defhydra hydra-l (:color blue
                          :body-pre (insert "l")
                          :idle 1.0)
  ("e"
   (if (and (and (texmathp) (gm/prefix-before-point "le")) (not (gm/prefix-before-point "\\le")))
       (gm/snippet "le" "less-than")
     (insert "e")) "less-than")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "l") 'hydra-l/body)
#+END_SRC
*** Greater Than
#+BEGIN_SRC emacs-lisp
(defhydra hydra-g (:color blue
                          :body-pre (insert "g")
                          :idle 1.0)
  ("e" (gm/snippet "ge" "greater-than") "greater than")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "g") 'hydra-g/body)
#+END_SRC
*** Pairsum
#+BEGIN_SRC emacs-lisp
(defhydra hydra-p (:color blue
                          :body-pre (insert "p")
                          :idle 1.0)
  ("s" (gm/snippet "ps" "pairsum") "pairsum")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "p") 'hydra-p/body)
#+END_SRC
*** Set, Sec
#+BEGIN_SRC emacs-lisp
(defhydra hydra-e (:color blue
                          :body-pre (insert "e")
                          :idle 1.0)
  ("t" (gm/snippet "set" "set") "set")
  ("c" (gm/snippet "sec" "sec") "sec")
  ("r" (gm/snippet "ker" "kernel") "kernel")
  ("q" (if (gm/prefix-before-point "neq")
           (if (texmathp)
               (gm/snippet "neq" "neq")
             (gm/snippet "neq" "unnumbered-equation"))
         (insert "q")) "neq")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "e") 'hydra-e/body)
#+END_SRC
*** Times
#+BEGIN_SRC emacs-lisp
(defhydra hydra-x (:color blue
                          :body-pre (insert "x")
                          :idle 1.0)
("x" (gm/snippet "xx" "times") "times")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "x") 'hydra-x/body)
#+END_SRC
*** Infinity, Log, Interval, (Arc)cos, (Arc)cot
#+BEGIN_SRC emacs-lisp
(defhydra hydra-o (:color blue
                          :body-pre (insert "o")
                          :idle 1.0)
  ("g" (gm/snippet "log" "log") "log")
  ("l" (gm/snippet "bol" "bol") "centered interval")
  ("o" (gm/snippet "oo" "infinity") "infinity")
  ("s" (if (gm/prefix-before-point "cos")
           (cond ((gm/prefix-before-point "acos") (gm/snippet "acos" "acos"))
                 (t (gm/snippet "cos" "cos")))
         (insert "s")) "(a)cos")
  ("t" (cond ((gm/prefix-before-point "cot")
              (cond ((gm/prefix-before-point "acot") (gm/snippet "acot" "acot"))
                    (t (gm/snippet "cot" "cot"))))
             ((gm/prefix-before-point "not") (gm/snippet "not" "not"))
             (t (insert "t"))) "(a)cot")
  ("+" (gm/snippet "o+" "oplus") "oplus")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "o") 'hydra-o/body)
#+END_SRC
*** Tan, Arctan
#+BEGIN_SRC emacs-lisp
(defhydra hydra-a (:color blue
                          :body-pre (insert "a")
                          :idle 1.0)
  ("n" (cond ((gm/prefix-before-point "tan")
              (cond ((gm/prefix-before-point "atan") (gm/snippet "atan" "atan"))
                    (t (gm/snippet "tan" "tan"))))
             ((gm/prefix-before-point "span") (gm/snippet "span" "span"))
             (t (insert "n"))) "(a)tan")
  ("r" (gm/snippet "star" "star") "star")
  ("t" (gm/snippet "mat" "matrix") "matrix")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "a") 'hydra-a/body)
#+END_SRC
*** Fraction, Floor
#+BEGIN_SRC emacs-lisp
(defhydra hydra-f (:color blue
                         :body-pre (insert "f")
                         :idle 1.0)
  ("l" (gm/snippet "fl" "floor") "floor")
  ("r" (gm/snippet "fr" "frac") "frac")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "f") 'hydra-f/body)
#+END_SRC
*** Absolute Value, Nabla
#+BEGIN_SRC emacs-lisp
(defhydra hydra-b (:color blue
                          :body-pre (insert "b")
                          :idle 1.0)
  ("s" (if (gm/prefix-before-point "abs")
           (gm/snippet "abs" "abs")
         (hydra-s/body) "abs"))
  ("l" (gm/snippet "nabl" "nabla") "nabla")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "b") 'hydra-b/body)
#+END_SRC
*** Number Systems
**** Real
#+BEGIN_SRC emacs-lisp
(defhydra hydra-R (:color blue
                          :body-pre (insert "R")
                          :idle 1.0)
  ("R" (gm/snippet "RR" "real") "real")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "R") 'hydra-R/body)
#+END_SRC
**** Rational
#+BEGIN_SRC emacs-lisp
(defhydra hydra-Q (:color blue
                          :body-pre (insert "Q")
                          :idle 1.0)
  ("Q" (gm/snippet "QQ" "rational") "rational")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "Q") 'hydra-Q/body)
#+END_SRC
**** Complex
#+BEGIN_SRC emacs-lisp
(defhydra hydra-C (:color blue
                          :body-pre (insert "C")
                          :idle 1.0)
  ("C" (gm/snippet "CC" "complex") "complex")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "C") 'hydra-C/body)
#+END_SRC
**** Integer
#+BEGIN_SRC emacs-lisp
(defhydra hydra-Z (:color blue
                          :body-pre (insert "Z")
                          :idle 1.0)
  ("Z" (gm/snippet "ZZ" "integers") "integers")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "Z") 'hydra-Z/body)
#+END_SRC
**** Natural
#+BEGIN_SRC emacs-lisp
(defhydra hydra-N (:color blue
                          :body-pre (insert "N")
                          :idle 1.0)
  ("N" (gm/snippet "NN" "natural") "natural")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "N") 'hydra-N/body)
#+END_SRC
**** Cal L
#+BEGIN_SRC emacs-lisp
(defhydra hydra-L (:color blue
                          :body-pre (insert "L")
                          :idle 1.0)
  ("L" (gm/snippet "LL" "cal-L") "cal-L")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "L") 'hydra-L/body)
#+END_SRC
**** Cal M
#+BEGIN_SRC emacs-lisp
(defhydra hydra-M (:color blue
                          :body-pre (insert "M")
                          :idle 1.0)
  ("M" (gm/snippet "MM" "cal-M") "cal-M")
  ("-" (insert "-") "dash"))

(global-set-key (kbd "M") 'hydra-M/body)
#+END_SRC
*** Math Symbols
#+BEGIN_SRC emacs-lisp
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta") "β")
  ("C" (insert "\\mathbb{C}") "ℂ")
  ("d" (insert "\\delta") "δ")
  ("D" (insert "\\Delta") "Δ")
  ("e" (insert "\\epsilon") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi") "φ")
  ("F" (insert "\\Phi") "Φ")
  ("g" (insert "\\gamma") "γ")
  ("G" (insert "\\Gamma") "Γ")
  ("h" (insert "\\eta") "η")
  ("k" (insert "\\kappa") "κ")
  ("l" (insert "\\lambda") "λ")
  ("L" (insert "\\Lambda") "Λ")
  ("m" (insert "\\mu") "µ")
  ("n" (insert "\\nu") "ν")
  ("N" (insert "\\nabla ") "∇")
  ("o" (insert "\\omega") "ω")
  ("O" (insert "\\Omega") "Ω")
  ("p" (insert "\\pi") "π")
  ("P" (insert "\\Pi") "Π")
  ("q" (insert "\\theta") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma") "σ")
  ("t" (insert "\\tau") "τ")
  ("u" (insert "\\upsilon") "υ")
  ("U" (insert " \\cup ") "∪")
  ("w" (insert "\\xi") "ξ")
  ("W" (insert "\\Xi") "Ξ")
  ("x" (insert "\\chi") "χ")
  ("y" (insert "\\psi") "ψ")
  ("Y" (insert "\\Psi") "Ψ")
  ("z" (insert "\\zeta") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("e" (insert "\\varepsilon") "ε")
  ("f" (insert "\\phi") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell") "ℓ")
  ("q" (insert "\\Theta") "Θ")
  ("r" (insert "\\varrho") "ρ")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert " \\cdots ") "···")
  ("-" (gm/snippet "" "conjugate") "-"))

(defun gm/semicolon ()
  (interactive)
  (if (texmathp)
      (hydra-semicolon-a/body)
    (insert ";")))

(global-set-key (kbd ";") 'gm/semicolon)
#+END_SRC
* End
Finally, close the ~let~ block we opened way back when and set a higher garbage-collection.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 20000000)
#+END_Sr

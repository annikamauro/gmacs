#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results silent
* Starting Up
** Lexical Scoping
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC
** Start Server
Always load up a server when you open Emacs. If a server is already running,
make sure not to start another one.
#+BEGIN_SRC emacs-lisp
(defun --running-as-server ()
    "Returns true if `server-start' has been called."
  (condition-case nil
      (and (boundp 'server-process)
           (memq (process-status server-process)
                 '(connect listen open run)))
    (error)))

(unless (--running-as-server) (server-start))
#+END_SRC
** Time Startup
On start-up, display how quickly Emacs started up.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Add Package Sources
#+BEGIN_SRC emacs-lisp
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t))
#+END_SRC
Use ~use-package~.
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC
Always.
#+BEGIN_SRC emacs-lisp
(require 'use-package)
(setq use-package-verbose t)
(setq use-package-always-ensure t)
#+END_SRC
Use ~M-x package-refresh-contents~ to reload the list of packages after adding the package sources for the first time.
** Add Elisp Directory and Custom Directory
If I ever need to load files outside of my package system, I know where to find
them. I also set up ~use-package~ here.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/elisp/")
#+END_SRC
I put custom variables outside of my =init.el= file.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC
I put my personal information in =private.el=.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/private.el")
#+END_SRC
** Common Lisp
#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
#+END_SRC
* General Configuration
** Graphics
*** Decluttering
**** Splash Screen
Get rid of that ugly splash screen.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
#+END_SRC
**** Fullscreen
Start emacs in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "")
#+END_SRC
**** Bars
Menus are not required; neither is the scroll bar.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
It is no longer the 90s. Toolbars and their little icons are not cool.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC
**** Cursor Blinking
I find cursor blinking distracting.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor 1)
#+END_SRC
**** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
**** Auto-revert
Turn off reverting buffer messages.
#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
#+END_SRC
**** Autosave
Turn off autosave messages. To do this, we define our own auto-save function and
replace the built-in one with ours.
#+BEGIN_SRC emacs-lisp
(setq auto-save-timeout 99999)
(defvar bjm/auto-save-timer nil
  "Timer to run `bjm/auto-save-silent'")
(defvar bjm/auto-save-interval 15
  "How often in seconds of idle time to auto-save with `bjm/auto-save-silent'")
(defun bjm/auto-save-silent ()
  "Auto-save all buffers silently"
  (interactive)
  (do-auto-save t))
(setq bjm/auto-save-timer
      (run-with-idle-timer 0 bjm/auto-save-interval #'bjm/auto-save-silent))
#+END_SRC
**** Modeline
Keep a simpler modeline...
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :defer 1)
#+END_SRC
and a smarter one.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 2
  :config
  (sml/setup))
#+END_SRC
*** Modeline
**** Time
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
**** Column
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
*** Indentation
**** Keep Things Indented
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :disabled
  :diminish aggressive-indent-mode
  :hook
  (prog-mode . aggressive-indent-mode)
  (python-mode . (lambda () (aggressive-indent-mode -1))))
#+END_SRC
**** Wrap Indented Lines Sensibly
This way, indented lines that are wrapped with ~visual-line-mode~ do not begin at character 0, but from where they are indented.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap)
(when (fboundp 'adaptive-wrap-prefix-mode)
  (defun my-activate-adaptive-wrap-prefix-mode ()
    "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
  (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))
#+END_SRC
*** Mouse Scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq indent-line-function #'insert-tab)
#+END_SRC
** Ease of Use
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Delete The Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)
#+END_SRC
**** Kill Current Buffer
Kill the current buffer.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
**** Remember File Variables
#+BEGIN_SRC emacs-lisp
(defun risky-local-variable-p (sym &optional _ignored) nil)
#+END_SRC
**** Reload Files On Update
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
**** Complete Reload
Completely reload emacs, by reloading the init file.
#+BEGIN_SRC emacs-lisp
(defun gm/reload ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC
**** Dictionary
#+BEGIN_SRC emacs-lisp
(require 'sdcv-mode)
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves so much clutter
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
Also, I have lots of disk space, and not so much patience when I lose an important file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
**** History
It's nice to have a history of commands so that when you open a new emacs instance, you can get right to work.
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
***** Desktop
On a similar note, save the desktop.
#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
(setq desktop-restore-eager 250)
#+END_SRC
Make two buffers with the same file name distinguishable.
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :defer 1
  :ensure nil
  :custom
  (uniquify-after-kill-buffer-p t)
  (uniquify-buffer-name-style 'post-forward)
  (uniquify-strip-common-suffix t))
#+END_SRC
***** Save Place
Opens a file to the same place in which it was last closed.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
*** Abbreviations
Load them.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/abbrevs.el")
#+END_SRC
Always use this wonderful tool.
#+BEGIN_SRC emacs-lispn
(abbrev-mode 1)
#+END_SRC
Because it's always on, we don't need to know about it.
#+BEGIN_SRC emacs-lisp
(diminish 'abbrev-mode)
#+END_SRC
Save them in the ~.emacs.d~ dir.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/abbrevs.el")
#+END_SRC
Save abbreviations upon saving a file.
#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silent)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq)
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
#+END_SRC
*** Searching
Use =ack= instead of =grep=.
#+BEGIN_SRC emacs-lisp
(defvar ack-history nil
  "History for the `ack' command.")

(defun ack (command-args)
  (interactive
   (let ((ack-command "ack --nofilter --nogroup --with-filename "))
     (list (read-shell-command "Run ack (like this): "
                               ack-command
                               'ack-history))))
  (let ((compilation-disable-input t))
    (compilation-start (concat command-args " < " null-device)
                       'grep-mode)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish
  :config
  (ivy-mode 1)
  (diminish 'ivy-mode)
  :custom
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)
     (t      . ivy--regex-fuzzy)))
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil))
(use-package flx)
(use-package swiper)
(use-package counsel)
(use-package smex)
#+END_SRC
*** Proselinting
#+BEGIN_SRC emacs-lisp
(use-package flycheck)
(global-flycheck-mode)
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
	    (id (one-or-more (not (any " "))))
	    (message) line-end))
  :modes (text-mode org-mode markdown-mode gfm-mode))

(add-to-list 'flycheck-checkers 'proselint)
#+END_SRC
*** Programming
Check syntax.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'flycheck-mode)
(add-hook 'prog-mode-hook #'linum-relative-mode)
(add-hook 'web-mode-hook #'linum-relative-mode)
#+END_SRC
Relative line numbers, useful for vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :defer t)
#+END_SRC
**** Python
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook #'linum-relative-mode)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(elpy-enable)
(setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
(use-package py-autopep8)
(add-hook 'python-mode-hook #'elpy-mode)
(add-hook 'elpy-mode-hook #'py-autopep8-enable-on-save)
(add-hook 'elpy-mode-hook #'flycheck-mode)
#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp
(use-package company)
#+END_SRC
*** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :defer t)
(bind-key "C-=" 'er/expand-region)
#+END_SRC
*** Highlighting/Comments
#+BEGIN_SRC emacs-lisp
(require 'ov-highlight)
(bind-key "C-c h" 'ov-highlight/body)
(bind-key "C-c C-h" 'ov-highlight/body)
#+END_SRC
** Packages
*** Async
Run Emacs processes asynchronously.
#+BEGIN_SRC emacs-lisp
(require 'async)
#+END_SRC
Authorize actions.
#+BEGIN_SRC emacs-lisp
(require 'auth-source-pass)
(auth-source-pass-enable)
(setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
*** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t)
#+END_SRC
But no more juggling window configurations after committing.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'magit
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))
#+END_SRC
*** Dired
**** Async
#+BEGIN_SRC emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC
**** Revert Buffer
Have the most up-to-date version of the buffer when using dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
**** Declutter
#+BEGIN_SRC emacs-lisp
(defun xah-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook #'xah-dired-mode-setup)
#+END_SRC
**** Copy and Delete
Allow dired to recursively copy and delete directories. ~always~ ensures that no
confirmation dialog comes up, and ~top~ does it only once.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies (quote always))
(setq dired-recursive-deletes (quote top))
#+END_SRC
**** Speed Sorting
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :config
  (dired-quick-sort-setup))
#+END_SRC
**** Sudo
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :defer t)
(bind-key "C-c C-x r" 'sudo-edit)
#+END_SRC
*** God Mode
Enable god-mode.
#+BEGIN_SRC emacs-lisp
(use-package god-mode)
#+END_SRC
Indicate mode with modeline.
#+BEGIN_SRC emacs-lisp
(defun gm/god-mode-indicator ()
  (cond (god-local-mode
         (progn (set-cursor-color "#dc322f")))
        (t (progn (set-cursor-color "#657b83")))))

(add-hook 'god-mode-enabled-hook #'gm/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'gm/god-mode-indicator)
#+END_SRC
*** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :pin manual
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page) ;
  (setq pdf-annot-activate-created-annotations t)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (setq pdf-view-resize-factor 1.1)
  (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
  (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete)
  :hook (pdf-view-mode pdf-view-midnight-minor-mode))
#+END_SRC
*** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :init (add-to-list 'auto-mode-alist '("\\.scss\\'" . web-mode))
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Screencast
**** Show Keypresses
#+BEGIN_SRC emacs-lisp
(require 'keycast)
#+END_SRC
**** GIF Screencast
#+BEGIN_SRC emacs-lisp
(require 'gif-screencast)
(with-eval-after-load 'gif-screencast
  (define-key gif-screencast-mode-map (kbd "<f8>") 'gif-screencast-toggle-pause)
  (define-key gif-screencast-mode-map (kbd "<f9>") 'gif-screencast-stop))
#+END_SRC
** Theme
*** Solarized
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :config (load-theme 'solarized-dark t))
#+END_SRC
*** Font Face
Normally use Hack.
#+BEGIN_SRC emacs-lisp
(set-face-font 'default "Hack")
(set-frame-font "Hack" nil t)
(custom-set-faces
 '(variable-pitch ((t (:family "Palatino Linotype")))))
#+END_SRC
*** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(eval-after-load "diminish" '(diminish 'auto-fill-mode-mode))
#+END_SRC
**** 80 Columns
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
          (lambda() (set-fill-column 80)))
#+END_SRC
*** Highlighting
**** Syntax
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
**** Rainbow Mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
(rainbow-mode 1)
(diminish 'rainbow-mode)
#+END_SRC
**** Source Code Blocks
Native syntax highlighting for source blocks in org mode.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC
**** Parentheses
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'expression)
#+END_SRC
* Keybindings
** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Define context-aware keys in Emacs · Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def
                                                 &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
** Better Defaults
These are what I think are better bindings for or better versions of the default
 commands.
*** Easy M-x
Alt is hard to type easily.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" 'counsel-M-x)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" 'set-mark-command)
#+END_SRC
*** Shell Kill Word
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" 'backward-kill-word)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring)
(browse-kill-ring-default-keybindings)
#+END_SRC
*** Cut/Paste
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
*** Fill/Unfill
From [[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun xah-fill-or-unfill ()
  "Reformat current paragraph or region to `fill-column', like `fill-paragraph' or “unfill”.
When there is a text selection, act on the selection, else, act on a text block separated by blank lines.
URL `http://ergoemacs.org/emacs/modernization_fill-paragraph.html'
Version 2017-01-08"
  (interactive)
  ;; This command symbol has a property “'compact-p”, the possible values are t and nil. This property is used to easily determine whether to compact or uncompact, when this command is called again
  (let ( (compact-p
          (if (eq last-command this-command)
              (get this-command 'compact-p)
            (> (- (line-end-position) (line-beginning-position)) fill-column)))
         (deactivate-mark nil)
         (blanks-regex "\n[ \t]*\n")
         p1 p2
         )
    (if (use-region-p)
        (progn (setq p1 (region-beginning))
               (setq p2 (region-end)))
      (save-excursion
        (if (re-search-backward blanks-regex nil "NOERROR")
            (progn (re-search-forward blanks-regex)
                   (setq p1 (point)))
          (setq p1 (point)))
        (if (re-search-forward blanks-regex nil "NOERROR")
            (progn (re-search-backward blanks-regex)
                   (setq p2 (point)))
          (setq p2 (point)))))
    (if compact-p
        (fill-region p1 p2)
      (let ((fill-column most-positive-fixnum ))
        (fill-region p1 p2)))
    (put this-command 'compact-p (not compact-p))))

(global-set-key [remap fill-paragraph]
                #'endless/fill-or-unfill)
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(bind-key "M-j"
            (lambda ()
                  (interactive)
                  (join-line -1)))
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" 'delete-current-buffer-file)
#+END_SRC
Rename better.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" 'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x b" 'ivy-switch-buffer)
#+END_SRC
Use ibuffer.
#+BEGIN_SRC emacs-lisp
(require 'ibuffer)
(bind-key "C-x C-b" 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC
*** Window Management
#+BEGIN_SRC emacs-lisp
(use-package ace-window)
(bind-key "C-x o" 'ace-window)
(bind-key "M-o" 'ace-window)
(bind-key "C-x 1" 'delete-other-windows)
(bind-key "C-x 2" 'split-window-below)
(bind-key "C-x 3" 'split-window-right)
(bind-key "C-x 0" 'delete-window)
#+END_SRC
*** Transpose
***** Sentences and Paragraphs
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
#+END_SRC
***** Characters
#+BEGIN_SRC emacs-lisp
(bind-key "C-r" 'transpose-chars)
#+END_SRC
*** Search
#+BEGIN_SRC emacs-lisp
(bind-key "C-s" 'swiper)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
*** Unbind Return
I sometimes activate this when exiting God Mode.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-j")
#+END_SRC
** Word Count
Count org-wc.
#+BEGIN_SRC emacs-lisp
(use-package org-wc
  :defer t)
(defun gm/wc-display-current-subtree (arg)
  (interactive "P")
  (if arg
      (org-wc-display nil)
    (save-restriction
      (org-narrow-to-subtree)
      (org-wc-display nil))))
(bind-key "C-c w" 'gm/wc-display-current-subtree org-mode-map)
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(bind-key "C-x g" 'magit-status)
#+END_SRC
** Org LaTeX Export
#+BEGIN_SRC emacs-lisp
(bind-key "C-c b" 'gm/org-latex-export org-mode-map)
#+END_SRC
** Dictionary
#+BEGIN_SRC emacs-lisp
(bind-key "C-c d" 'sdcv-search)
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (lambda () (interactive) (find-file "~/org/inbox.org")))
#+END_SRC
** Complete Reload
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'gm/reload)
#+END_SRC
** Org Cliplink
Paste URL with extracted title as the description.
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :defer t)
(bind-key "C-c y" 'org-cliplink org-mode-map)
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC
The dollar sign ($) is especially useful for LaTeX.
*** God Mode
Easily enter god mode.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "jk" 'god-mode-all)
#+END_SRC
* Org Mode
** Setup
We have to use ~require~ to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (require 'org)
  (require 'ox-latex)
  (use-package ox-hugo
    :after ox)
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("M-h" . org-mark-element))
  :custom
  (org-directory "~/org/")
  (org-default-notes-file "~/org/inbox.org")
  (org-agenda-files '("~/org/inbox.org"
                      "~/org/gtd.org"
                      "~/org/tickler.org"
                      "~/org/notes.org"
                      "~/org/gcal.org"))
  (org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
  (org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                        ("~/org/someday.org" :level . 1)
                        ("~/org/tickler.org" :maxlevel . 2)
                        ("~/org/notes.org" :maxlevel . 2)))
  (org-capture-templates '(("a" "Appointment" entry
                            (file "~/org/gcal.org")
                            "* %i%? \n%^T\n")
                           ("t" "Todo [inbox]" entry
                            (file "~/org/inbox.org")
                            "* TODO %i%? \n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ("T" "Tickler" entry
                            (file+headline "~/org/tickler.org" "Tickler")
                            "* %i%? \n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ("j" "Journal" entry
                            (file+datetree "~/org/journal.org")
                            "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
                           ))
  :delight (org-indent-mode))
(setq org-hide-emphasis-markers t)
(setq org-startup-indented t)
(setq org-agenda-start-on-weekday nil)
(setcar (nthcdr 4 org-emphasis-regexp-components) 10)
(bind-key (kbd "C-k") 'xah-cut-line-or-region org-mode-map)
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
*** Google Calendar
#+BEGIN_SRC emacs-lisp
(setq package-check-signature nil)
(use-package org-gcal
  :defer t)
(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
#+END_SRC
*** Org Babel
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages '((python . t)))
(setq org-babel-python-command "python3.6")
#+END_SRC
** Prettifying
*** Org Bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets)
(add-hook 'org-mode-hook #'org-bullets-mode)
#+END_SRC
*** Bullet List
Have lists begun by, for example, ~-~ look like a bullet-pointed list.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
** LaTeX
*** Keychord for Math Mode
#+BEGIN_SRC emacs-lisp
(defun gm/enter-math ()
  (interactive)
  (yas-expand-snippet (yas-lookup-snippet "enter-math-mode")))
(key-chord-define org-mode-map "r4" #'gm/enter-math)
#+END_SRC
*** Autocomplete ~$$~
#+BEGIN_SRC emacs-lisp
(defvar org-electric-pairs '((?$ . ?$) ))
(defun dollar-add-electric-pairs ()
  (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))
  (setq-local electric-pair-text-pairs electric-pair-pairs))
(add-hook 'org-mode-hook 'dollar-add-electric-pairs)
#+END_SRC
*** Don't Break Paragraph on Comments
Remove comments from org document when exporting to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Equation Auto Preview
Not too small.
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.75))
#+END_SRC
Obtained from [[https://gist.github.com/cvcore/760008a4dfb2eadf42afdc9cf01ef979][Charles Wang]].
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar cw/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on. Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)"
  )

(setq cw/org-valid-fragment-type
      '(latex-fragment
        latex-environment
        link))

(defun cw/org-curr-fragment ()
  "Returns the type and position of the current fragment available for preview inside org-mode. Returns nil at non-displayable fragments"
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type cw/org-valid-fragment-type)
      (list fr-type
            (org-element-property :begin fr))))
  )

(defun cw/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type)
               (eq 'latex-environment fr-type))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov))))
          ((eq 'link fr-type)
           nil;; delete image overlay here?
           ))
    ))

(defun cw/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type) ;; latex stuffs
               (eq 'latex-environment fr-type))
           (when (cw/org-curr-fragment) (org-preview-latex-fragment))) ;; only toggle preview when we're in a valid region (for inserting in the front of a fragment)
          ((eq 'link fr-type) ;; for images
           (let ((fr-end (org-element-property :end (org-element-context))))
             (org-display-inline-images nil t fr-begin fr-end))))
    ))

(defun cw/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment"
  (and (eq 'org-mode major-mode)
       (let ((curr (cw/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            cw/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr cw/org-last-fragment)))

           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment)
             ;; now remove current image
             (cw/org-remove-fragment-overlay curr)
             ;; and save new fragment
             )
           (setq cw/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            cw/org-last-fragment)
           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment))

           ;; unset last fragment
           (setq cw/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not cw/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (cw/org-remove-fragment-overlay curr)
             )
           (setq cw/org-last-fragment curr))
          ))))

(defvar gm/eq-preview nil)
(defun gm/toggle-equation-preview ()
  (interactive)
  (if gm/eq-preview
      (progn
        (remove-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display)
        (message "Equation preview disabled."))
    (progn
      (add-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display)
      (message "Equation preview enabled.")))
  (let ((var gm/eq-preview))
    (setq gm/eq-preview (not var))))
(bind-key "C-c p" 'gm/toggle-equation-preview)
#+END_SRC
*** Export
#+BEGIN_SRC emacs-lisp
(defun org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-latex-export-to-latex nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))

(defun gm/org-latex-export ()
  (interactive)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (save-restriction
    (org-narrow-to-subtree)
    (org-export-headlines-to-pdf))))
#+END_SRC
**** Export Classes
***** Tufte-LaTeX
#+BEGIN_SRC emacs-lisp
(require 'ox-tufte-latex)
(require 'ox-extra)
#+END_SRC
****** Command Links
******* No Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "latex" nil
 (lambda (path desc format)
   (when(eq format 'latex)
     (format "\\%s{%s}" path desc))))
#+END_SRC
******* One Option
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "latex-opt" nil
 (lambda (path desc format)
   (when (eq format 'latex)
     (let* ((desc-list (split-string desc ";"))
            (opt (nth 1 desc-list))
            (arg (nth 0 desc-list)))
       (format "\\%s%s{%s}" path
               (if (equal "" opt) opt (format "[%s]" opt))
               arg)))))
#+END_SRC
****** Class Options
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-handout"
               "\\documentclass[symmetric,nobib]{gm-tufte-handout}
   [NO-DEFAULT-PACKAGES]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
****** Biber
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
        "biber %b"
        "pdflatex -interaction nonstopmode -output-directory %o %f"
        "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
****** Keyword Search
#+BEGIN_SRC emacs-lisp
(defun jk-org-kwds ()
  "parse the buffer and return a cons list of (property . value)
from lines like:
,#+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
    (lambda (keyword) (cons (org-element-property :key keyword)
                            (org-element-property :value keyword)))))

(defun jk-org-kwd (KEYWORD)
  "get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (jk-org-kwds))))
#+END_SRC
***** Assignment
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
***** Math Notes
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("gm-notes"
               "\\documentclass[10pt,twoside]{article}
\\usepackage{gm-notes}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
**** Export Settings
#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex))
(setq org-latex-to-pdf-process
 '("xelatex -interaction nonstopmode %f"
   "xelatex -interaction nonstopmode %f")) ;; for multiple passes
(setq org-export-with-smart-quotes t)
#+END_SRC
**** Cleverref
#+BEGIN_SRC emacs-lisp
(defun org-latex-ref-to-cref (text backend info)
  "Use \\cref instead of \\ref in latex export."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string "\\\\ref{" "\\\\cref{" text)))

(add-to-list 'org-export-filter-final-output-functions
             'org-latex-ref-to-cref)
#+END_SRC
* TeX
Of course we use =auctex=. I do most of my LaTeX editing in Org Mode now.
#+BEGIN_SRC emacs-lisp
(use-package auctex
  :defer t
  :init (require 'tex-site)
  :config (setq font-latex-fontify-script nil))
#+END_SRC
** Electric Dollars and Parens
Insert dollar signs electrically.
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook
	      (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
			              (cons "$" "$"))))
#+END_SRC
* Mail
Set up the requirements.
#+BEGIN_SRC emacs-lisp
(use-package notmuch)
(require 'smtpmail)
(require 'smtpmail-async)
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp
(setq message-directory "~/mail/")
(setq message-auto-save-directory "~/mail/draft")
(setq message-fcc-dirs "~/mail/mbsyncmail/Sent Items")
#+END_SRC
Provide my email and name.
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'message-user-agent
      user-mail-address gm/email
      user-full-name "Gautam Manohar")
#+END_SRC
SMTP for sending mail. The =stream-type= is important because I want my outgoing
mail to at least use TLS encryption. One day, though, I would like to adopt a
more rigorous system of encryption.
#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'async-smtpmail-send-it
      message-send-mail-function 'async-smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-debug-verb t
      smtpmail-stream-type 'starttls
      smtpmail-smtp-server gm/send-mail-server
      smtpmail-smtp-service 587)
#+END_SRC
Nice stuff to have for sending mail.
#+BEGIN_SRC emacs-lisp
(setq message-kill-buffer-on-exit t)
(setq notmuch-address-command 'internal)
#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key "i" :sort-order oldest-first)
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s" :sort-order newest-first)
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a" :sort-order newest-first)))
#+END_SRC
Keybindings to open mail buffer.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c m" 'notmuch)
#+END_SRC
* Snippets
** Load Snippets
#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(use-package yasnippet
  :diminish (yas-minor-mode))
(yas-global-mode 1)
#+END_SRC
** SPC Expansion
Use SPC instead of TAB to expand snippets.
#+BEGIN_SRC emacs-lisp
(define-key yas-minor-mode-map (kbd "<tab>") nil)
(define-key yas-minor-mode-map (kbd "TAB") nil)
(define-key yas-minor-mode-map (kbd "SPC")
  (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
#+END_SRC
** Fast Latex Snippets
*** Requirements
Use =texmathp= to tell if you are in math mode.
#+BEGIN_SRC emacs-lisp
(require 'texmathp)
#+END_SRC
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=.
#+BEGIN_SRC emacs-lisp
(require 'hydra)
#+END_SRC
To automate the generation of my main math snippets, I use a data structure
called a prefix tree, also known as a trie.
#+BEGIN_SRC emacs-lisp
(require 'strie)
#+END_SRC
*** Helper Functions
**** Delete n Characters
Delete n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/delete-chars (n)
  (dotimes (i n) (delete-char -1)))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n)
  (buffer-substring-no-properties (- (point) n) (point)))
#+END_SRC
**** Math Mode Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/snippet (key snippet)
  (let ((len (length key)))
        (progn
          (gm/delete-chars (- len 1))
          (yas-expand-snippet (yas-lookup-snippet snippet)))))
#+END_SRC
**** Generate Snippets
I wrote this to reduce the amount of redundant code needed to set up the
snippets. First, we create a suffix tree of all the math snippets.
#+BEGIN_SRC emacs-lisp
(setq gm/math-snippet-file "~/.emacs.d/math-snippets")
(defun gm/math-setup ()
  (interactive)
  (setq gm/math-snippets (gm/read-from-file gm/math-snippet-file))
  (setq gm/math-trie (strie-new))
  (loop for (key . value) in gm/math-snippets
        do (strie-add gm/math-trie (reverse key) value))

  (setq gm/math-suffix (mapcar #'car (strie-children gm/math-trie)))

  (setq gm/math-completion
        (loop for x in gm/math-suffix
              collect (list x (mapcar (lambda (s) (reverse (substring s 1 (length s))))
                                      (strie-complete gm/math-trie x)))
              collect (eval (macroexpand
                             `(define-conditional-key org-mode-map
                                  ,x (lambda () (interactive)
                                       (gm/math-snippet ,x)) (texmathp))))))
  (gm/print-to-file gm/math-snippet-file gm/math-snippets)
)
(add-hook 'org-mode-hook 'gm/math-setup)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun gm/math-snippet (key)
  (setq buff-cand
        (loop for i from 1 to 6
              collect (gm/last-n-chars i)))
  (setq comp (cadr (assoc key gm/math-completion)))
  (setq cand (loop for x in buff-cand if (member x comp)
                   collect x))
  (setq snippet (assoc
                      (concat (car (sort cand
                                         (lambda (a b) (> (length a) (length b))))) key)
                      gm/math-snippets))
  (if snippet
      (gm/snippet (car snippet) (cdr snippet)) (insert key)
    ))
#+END_SRC
And finally some utility functions.
#+BEGIN_SRC emacs-lisp
(defun gm/print-to-file (filename data)
  (with-temp-file filename
    (prin1 data (current-buffer))))

(defun gm/read-from-file (filename)
  (with-temp-buffer
    (insert-file-contents filename)
    (cl-assert (eq (point) (point-min)))
    (read (current-buffer))))

(defun gm/new-math-snippet (snippet-key snippet-name)
  (interactive
   (list
    (read-string "Snippet key: ")
    (read-string "Snippet name: ")))
  (unless (or (string= "" snippet-key)
              (string= "" snippet-name))
    (add-to-list 'gm/math-snippets (cons snippet-key snippet-name))
    (setq file-cand (expand-file-name
                     (concat (concat (car (yas-snippet-dirs)) "/latex-mode/")
                             snippet-name)))
    (unless (file-exists-p file-cand)
      (find-file file-cand)
      (yas-expand-snippet (yas-lookup-snippet "new-math-snippet")))
    (gm/print-to-file gm/math-snippet-file gm/math-snippets)
    (gm/math-setup)
    ))
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as $x_0$ or $a_{18}$. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering.
#+BEGIN_SRC emacs-lisp
(defun gm/char-is-letter (char)
  (memq (get-char-code-property char 'general-category)
        '(Ll Lu Lo Lt Lm Mn Mc Me Nl)))

(defun gm/math-subscript ()
  (cond ((gm/char-is-letter (char-before)) (insert "_"))
        ((string-match "\_[0-9]" (gm/last-n-chars 2))
         (save-excursion
           (backward-char)
           (insert "\{")
           (forward-char)
           (insert "\}")))))
#+END_SRC
Activate the subscript command for all digits.
#+BEGIN_SRC emacs-lisp
(loop for n from 0 to 9
      collect (eval (macroexpand
                     `(define-conditional-key org-mode-map
                          (number-to-string ,n)
                          (gm/math-subscript) (texmathp)))))
(define-conditional-key org-mode-map "9" (gm/math-subscript) (texmathp))
#+END_SRC
**** Fraction
Typing "/" after an appropriate block (a number or a balanced set of
parentheses) creates a fraction with this block in the numerator and the point
in the denominator. The outside parentheses will be removed; for example, =(\sin
x)= and then =/= will result in =\frac{\sin x}{|}=.
#+BEGIN_SRC emacs-lisp
(defun gm/line-to-point ()
  (let (start my-string)
    (setq start (line-beginning-position) )
    (setq my-string (buffer-substring-no-properties start (point)))))

(defun gm/math-insert-frac-match (match)
  (when match
    (progn (yas-expand-snippet (yas-lookup-snippet "frac"))
           (insert match)
           (yas-next-field)
           )))

(defun gm/math-frac-helper (regexp)
  (let (my-line start end match)
    (setq my-line (gm/line-to-point))
    (when (looking-back regexp (line-beginning-position) t)
      (setq start (match-beginning 0))
      (setq end (match-end 0))
      (setq match (substring my-line
                             (- start (line-beginning-position))
                             (- end (line-beginning-position))))
      (delete-region start end))
    (gm/math-insert-frac-match match)))

(defun gm/math-frac ()
  (interactive)
  (cond ((string-match "[\])]" (char-to-string (char-before)))
         (let (match)
           (progn
             (set-mark-command nil)
             (backward-sexp)
             (setq match (buffer-substring-no-properties
                          (region-beginning) (region-end)))
             (delete-region (region-beginning) (region-end))
             (gm/math-insert-frac-match (substring match 1 -1)))))
        ((string-match "}" (char-to-string (char-before)))
         (gm/math-frac-helper "[\\][A-Za-z]*[\[{].*[\]}]"))
        ((string-match "[0-9a-z]" (char-to-string (char-before)))
         (gm/math-frac-helper "[\\]?[0-9A-Za-z_^]*"))
        (t (yas-expand-snippet (yas-lookup-snippet "frac")))))

(define-conditional-key org-mode-map "/" #'gm/math-frac (texmathp))
#+END_SRC
**** Simplify Super/Subscripts
#+BEGIN_SRC emacs-lisp
(defun gm/simplify-math-script (&rest r)
  (when (string-match "[_^]{.}" (gm/last-n-chars 4))
    (save-excursion
      (delete-backward-char 1)
      (backward-char)
      (delete-backward-char 1))))
(advice-add 'yas-next-field-or-maybe-expand-snippet
            :after #'gm/simplify-math-script)
#+END_SRC
*** Math Symbols
#+BEGIN_SRC emacs-lisp
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta") "β")
  ("C" (insert "\\mathbb{C}") "ℂ")
  ("d" (insert "\\delta") "δ")
  ("D" (insert "\\Delta") "Δ")
  ("e" (insert "\\epsilon") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi") "φ")
  ("F" (insert "\\Phi") "Φ")
  ("g" (insert "\\gamma") "γ")
  ("G" (insert "\\Gamma") "Γ")
  ("h" (insert "\\eta") "η")
  ("k" (insert "\\kappa") "κ")
  ("l" (insert "\\lambda") "λ")
  ("L" (insert "\\Lambda") "Λ")
  ("m" (insert "\\mu") "µ")
  ("n" (insert "\\nu") "ν")
  ("N" (insert "\\nabla ") "∇")
  ("o" (insert "\\omega") "ω")
  ("O" (insert "\\Omega") "Ω")
  ("p" (insert "\\pi") "π")
  ("P" (insert "\\Pi") "Π")
  ("q" (insert "\\theta") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma") "σ")
  ("t" (insert "\\tau") "τ")
  ("u" (insert "\\upsilon") "υ")
  ("U" (insert " \\cup ") "∪")
  ("v" (insert "\\vec ") "v")
  ("w" (insert "\\xi") "ξ")
  ("W" (insert "\\Xi") "Ξ")
  ("x" (insert "\\chi") "χ")
  ("y" (insert "\\psi") "ψ")
  ("Y" (insert "\\Psi") "Ψ")
  ("z" (insert "\\zeta") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph") "ℵ")
  ("e" (insert "\\varepsilon") "ε")
  ("f" (insert "\\phi") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell") "ℓ")
  ("q" (insert "\\Theta") "Θ")
  ("r" (insert "\\varrho") "ρ")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert " \\cdots ") "···")
  ("-" (gm/snippet "" "conjugate") "-"))

(define-conditional-key org-mode-map ";" #'hydra-semicolon-a/body (texmathp))
#+END_SRC

#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results silent
* Starting Up
:PROPERTIES:
:EXPORT_FILE_NAME: Starting_Up
:END:
** Lexical Scoping
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC
** Start Server
Always load up a server when opening Emacs.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
** Hooks
#+BEGIN_SRC emacs-lisp
(defvar gmacs-post-init-hook nil
  "A list of hooks run after GMACS initialization is complete, and after
`gmacs-init-hook'.")
#+END_SRC
** Init Settings
I was inspired to implement these optimizations in GMACS thanks to
[[https://github.com/nilcons/emacs-use-package-fast][nilcons/emacs-use-package-fast]].

To increase startup speed, we're going to set =gc-cons-threshold= to a very high
number. This is not ideal when actually using Emacs, so we turn this off when we
finish starting up. If we were to leave this on, we would experience long
garbage collection pauses during use.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

(add-hook 'gmacs-post-init-hook (lambda () (setq gc-cons-threshold 16777216
                                                 gc-cons-percentage 0.1)))
#+END_SRC
We increase these so that we don't exceed recursion limits unless there is some
kind of infinite loop.
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000
      max-specpdl-size 10000)
#+END_SRC
Now we prevent loading double buffers. This reduces stuttering.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC
Silence some common warnings from the byte-compiler.
#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
Let the user know how quickly GMACS started.
#+BEGIN_SRC emacs-lisp
(add-hook 'gmacs-post-init-hook
          (lambda ()
            (message "GMACS ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Directories
We define a few custom directories to satisfy my own wishes for how things
should be named and to speed up the package initialization process by doing it
ourselves, rather than relying on =package-initialize=. Note that the whole thing
is wrapped in a byte-compile block.

We make the directories if they don't exist. This is done by iterating over a
list to make it easy for to extend to more directories if needed.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar gmacs-emacs-dir (expand-file-name user-emacs-directory)
    "The path to the emacs.d directory.")

  (defvar gmacs-packages-dir (concat gmacs-emacs-dir "packages/")
    "Where package.el and elpa plugins (and their caches) are stored.")

  (defvar gmacs-custom-dir (concat gmacs-emacs-dir "elisp/")
    "Where custom lisp files are stored")

  (defvar gmacs-cache-dir (concat gmacs-emacs-dir "cache/")
    "Where temporary files that could be deleted without anything terrible happening are stored.")

  (dolist (dir (list gmacs-packages-dir))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC
** Add Package Sources
We're going to use a custom package directory, so we need to trick Emacs into
thinking it has initialized packages by setting =package--init-file-ensured= to =t=.
Also, we don't enable packages at startup, because we will let =use-package=
intelligently defer and handle package loading.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir gmacs-packages-dir
        package--init-file-ensured t
        package-enable-at-startup nil))
#+END_SRC
Get =use-package= to always defer loading packages until they are actually needed.
This reduces startup time significantly. We're doing this now, before
=use-package= is even loaded, because otherwise it won't help us when the code
that loads =use-package= is evaluated upon byte-compilation.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t
      use-package-verbose t)
#+END_SRC
We set the =load-path= ourselves. This will be faster than letting
=package-intialize= handle it, because we only add directories we know are from
packages. This way, we don't need to search all third party paths eveyr time we
require a file. We'll also store custom or third-party Emacs Lisp files in
=gmacs-custom-dir=, so we add that to the =load-path=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
  (add-to-list 'load-path gmacs-custom-dir))
#+END_SRC
Our next step is to load =package.el=. We add our package repositories "melpa" and
"gnu," because Emacs' default list of packages is so conservative. Then we need
to initialize the packages and make sure that =use-package= is installed if its
missing. Finally, we tell =use-package= to always install missing packages.
Otherwise, an error would be thrown when a package is missing.

Note that this whole process only run when the file is byte-compiled. This means
that by the time the code is actually evaluated, the =use-package= macro has been
expanded, so the package is not needed anymore. As such, we can do all the
expensive and time-consuming work of getting the packages ready before Emacs has
even started, during byte-compilation.If this config has not been manually
byte-compiled, Emacs will initialize packages on startup as usual.
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)

  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
  (unless (assoc-default "gnu" package-archives)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t))
  (unless (assoc-default "melpa-stable" package-archives)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t))

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t))
#+END_SRC
We also require =diminish= and =bind= because I often use these keywords within
=use-package= declarations.
#+BEGIN_SRC emacs-lisp
(require 'bind-key)
(require 'diminish)
#+END_SRC
** Add Elisp Directory and Custom Directory
I put custom variables outside of my =init.el= file.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" gmacs-emacs-dir))
(load custom-file)
#+END_SRC
I put my personal information in =private.el=.
#+BEGIN_SRC emacs-lisp
(load (expand-file-name "private" gmacs-emacs-dir))
#+END_SRC
** Libraries
We load in some common libraries. The =:demand= keyword overrides the global
deferral we set earlier.
#+BEGIN_SRC emacs-lisp
(use-package async :demand t)
(use-package dash :demand t)
(use-package f :demand t)
(use-package s :demand t)
(use-package cl-lib :ensure t :demand t)
#+END_SRC
* General Configuration
** Graphics
*** Decluttering
**** Fullscreen
Start emacs in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "GMACS")
#+END_SRC
**** Cursor Blinking
I find cursor blinking distracting.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor 1)
#+END_SRC
**** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
**** Auto-revert
Turn off reverting buffer messages.
#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
#+END_SRC
**** Modeline
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 2
  :config (sml/setup))
#+END_SRC
***** Time
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
***** Column
Show the column number in the modeline. I don't find that this is too slow.
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
*** Indentation
**** Keep Things Indented
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :diminish aggressive-indent-mode
  :hook (prog-mode . aggressive-indent-mode)
  :config (add-to-list 'aggressive-indent-excluded-modes 'python-mode))
#+END_SRC
**** Wrap Indented Lines Sensibly
This way, indented lines that are wrapped with ~visual-line-mode~ do not begin at
character 0, but from where they are indented.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap)
(when (fboundp 'adaptive-wrap-prefix-mode)
  (defun my-activate-adaptive-wrap-prefix-mode ()
    "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
  (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))
#+END_SRC
*** Mouse Scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2)
(setq indent-line-function #'insert-tab)
#+END_SRC
** Ease of Use
*** DOOM! Macros
Some great macros from the popular DOOM! Emacs configuration. The documentation
on these will be sparse, because the docstrings do an excellent job of
explaining what's going on.
**** after!
#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
**** λ!
#+BEGIN_SRC emacs-lisp
(defmacro λ! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))
#+END_SRC
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with. And
it's two less characters to type.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me. I also don't
live in the typewriter days where the
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Stop Cursor Going into Minibuffer Prompt
Sometimes when going back in the minibuffer by using backspace or the left arrow
key, the cursor will move right back into the prompt, and when you start to type
again, Emacs will display the annoying message that the minibuffer text is read
only. This prevents you from manually having to move the cursor out of the
prompt and then back, or pressing =C-g= and starting over.
#+BEGIN_SRC emacs-lisp
(customize-set-variable
 'minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
**** Delete The Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil)
(setq split-width-threshold 0)
#+END_SRC
**** Kill Current Buffer
Kill the current buffer.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
**** Reload Files On Update
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC
**** Complete Reload
Completely reload emacs, by reloading the init file.
#+BEGIN_SRC emacs-lisp
(defun gm/reload ()
  (interactive)
  (if current-prefix-arg
      (progn
        (org-babel-tangle-file (expand-file-name "gmacs.org" gmacs-emacs-dir)
                               (expand-file-name "gmacs.el" gmacs-emacs-dir))
        (byte-compile-file (expand-file-name "gmacs.el" gmacs-emacs-dir))
        (load-file (expand-file-name "init.el" gmacs-emacs-dir)))
    (org-babel-load-file (expand-file-name "gmacs.org" gmacs-emacs-dir))))
#+END_SRC
**** Dictionary
#+BEGIN_SRC emacs-lisp
(autoload 'sdcv-search "sdcv-mode")
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
**** Uniquify
Make two buffers with the same file name distinguishable.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves so much clutter
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name (concat gmacs-cache-dir "backups")))))
#+END_SRC
Also, I have lots of disk space, and not so much patience when I lose an
important file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq create-lockfiles nil)
(setq auto-save-file-name-transforms `((".*" ,(expand-file-name (concat gmacs-cache-dir "auto-save")) t)))
(setq auto-save-list-file-name (expand-file-name (concat gmacs-cache-dir "auto-save/.saves~")))
#+END_SRC
Store more undo information in memory.
#+BEGIN_SRC emacs-lisp
(setq undo-limit 250000)
#+END_SRC
**** History
It's nice to have a history of commands so that when you open a new emacs instance, you can get right to work.
#+BEGIN_SRC emacs-lisp
(setq-default savehist-file (expand-file-name "savehist" gmacs-cache-dir)
      save-place-file (expand-file-name "saveplaces" gmacs-cache-dir)
      recentf-save-file (expand-file-name "recentf" gmacs-cache-dir)
      transient-history-file (expand-file-name "transient-history.el" gmacs-cache-dir)
      bookmark-default-file (expand-file-name "bookmarks" gmacs-cache-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
Open files to the same place in which they were last closed.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
*** Abbreviations
Load them.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/abbrevs.el")
#+END_SRC
Always use this wonderful tool.
#+BEGIN_SRC emacs-lisp
(abbrev-mode 1)
#+END_SRC
Because it's always on, we don't need to know about it.
#+BEGIN_SRC emacs-lisp
(diminish 'abbrev-mode)
#+END_SRC
Save them in the ~.emacs.d~ dir.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/abbrevs.el")
#+END_SRC
Save abbreviations upon saving a file.
#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silent)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :defer 2
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
*** Programming
Set up =flycheck=.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package flycheck
  :diminish (flycheck-mode " Ψ")
  :config (global-flycheck-mode)
    <<proselint>>
  :custom (flycheck-display-errors-delay .3)
  :hook (prog-mode . flycheck-mode))
#+END_SRC
Relative line numbers, useful for vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
     :hook
   (prog-mode . nlinum-relative-mode))
#+END_SRC
**** Flycheck Hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-flycheck (:color blue)
  "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("M" flycheck-manual)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-mode)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))
(bind-key "C-c f" #'hydra-flycheck/body)
#+END_SRC
**** Python
Indent with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq-default python-indent-offset 4)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (use-package py-autopep8
    :hook (elpy-mode . py-autopep8-enable-on-save))
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  :hook
  (python-mode . elpy-enable)
  (python-mode . elpy-mode)
  (elpy-mode . flycheck-mode))
#+END_SRC
**** Lisp
We don't want annoying comments about having, for example, =;;; package ---
summary= at the top of an Emacs Lisp file.
#+BEGIN_SRC emacs-lisp
(defun disable-fylcheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

(add-hook 'org-src-mode-hook 'disable-fylcheck-in-org-src-block)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'emacs-lisp-mode
  '(("use-package" . font-lock-keyword-face)))
#+END_SRC
*** Proselinting
Check prose style.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref proselint
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
	    (id (one-or-more (not (any " "))))
	    (message) line-end))
  :modes (text-mode org-mode markdown-mode gfm-mode))
;; (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp
(use-package company)
#+END_SRC
*** Which Key Mode
Helpful when you want to see completion for a certain sequence of prefix keys.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 2
  :diminish
  :config (which-key-mode))
#+END_SRC
*** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind (("C-=" . er/expand-region)))
#+END_SRC
*** Highlighting/Comments
#+BEGIN_SRC emacs-lisp
(autoload 'ov-highlight/body "ov-highlight")
(bind-key "C-c h" 'ov-highlight/body)
(bind-key "C-c C-h" 'ov-highlight/body)
#+END_SRC
*** Async Without Window
#+BEGIN_SRC emacs-lisp
(defun async-shell-command-no-window (command)
  (interactive)
  (let ((display-buffer-alist
        (list (cons "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+END_SRC
*** Revert All Buffers
From [[https://emacs.stackexchange.com/questions/24459/revert-all-open-buffers-and-ignore-errors][Emacs Stack Exchange]].
#+BEGIN_SRC emacs-lisp
(defun modi/revert-all-file-buffers ()
  "Refresh all open file buffers without confirmation.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer t t))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers."))
#+END_SRC
** Packages
*** Async
Authorize actions.
#+BEGIN_SRC emacs-lisp
(require 'auth-source-pass)
(auth-source-pass-enable)
(setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
Set tramp connection history location.
#+BEGIN_SRC emacs-lisp
(setq tramp-persistency-file (expand-file-name "tramp" gmacs-cache-dir))
#+END_SRC
*** Magit
Magit, the magical Git client, is an amazing porcelain for Git inside of Emacs.
Seriously, I've forgotten how tedious using Git on the command line is, and
every time I have to is a pain. Emacs is worth using for this package alone. We
only load it from the entry points given in =:commands=. We also define a
quick-bind to quit the current magit session and return to the previous window
configuration. This way, we can let magit take up the full real estate on the
screen, and once we're done, we can get right back to where we left off.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all)
  :init
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  :bind (:map magit-status-mode-map
              ("q" . magit-quit-session)))
#+END_SRC
*** Dired
**** Async
#+BEGIN_SRC emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC
**** Revert Buffer
Have the most up-to-date version of the buffer when using dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
**** Declutter
#+BEGIN_SRC emacs-lisp
(defun xah-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook #'xah-dired-mode-setup)
#+END_SRC
**** Copy and Delete
Allow dired to recursively copy and delete directories. ~always~ ensures that no
confirmation dialog comes up, and ~top~ does it only once.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies (quote always))
(setq dired-recursive-deletes (quote top))
#+END_SRC
**** Speed Sorting
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :config (dired-quick-sort-setup))
#+END_SRC
**** Sudo
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :bind (("C-c C-x r" . sudo-edit)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish
  :demand t
  :config
  (ivy-mode 1)
  (use-package flx)
  (use-package swiper
    :commands (swiper swiper-all))
  (use-package counsel
    :demand t
    :bind ([remap execute-extended-command] . counsel-M-x)
    ([remap org-goto] . counsel-org-goto)
    ([remap swiper] . counsel-grep-or-swiper)
    :config
    (setq counsel-grep-base-command
 "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))
  (use-package smex)
  :custom
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)
     (t      . ivy--regex-fuzzy)))
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil)
  (smex-save-file (expand-file-name "smex" gmacs-cache-dir)))
#+END_SRC

*** God Mode
Enable god-mode.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
 :commands (god-local-mode god-mode-all))
#+END_SRC
Indicate mode with modeline.
#+BEGIN_SRC emacs-lisp
(defun gm/god-mode-indicator ()
  (cond (god-local-mode
         (progn (set-cursor-color "#dc322f")))
        (t (progn (set-cursor-color "#657b83")))))

(add-hook 'god-mode-enabled-hook #'gm/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'gm/god-mode-indicator)
#+END_SRC
*** PDF Tools
Basic configuration.
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :commands pdf-view-mode
  :config
  (setq pdf-annot-activate-created-annotations t)
  :diminish pdf-view-midnight-minor-mode
  :bind (:map pdf-view-mode-map
              ("C-s" . counsel-grep-or-swiper)
              ("h" . pdf-annot-add-highlight-markup-annotation)
              ("t" . pdf-annot-add-text-annotation)
              ("D". pdf-annot-delete)
              ("r" . pdf-view--rotate))
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-width-to-window))
(eval-when-compile (pdf-tools-install))
#+END_SRC
Allow rotation.
#+BEGIN_SRC emacs-lisp
(defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  (interactive)
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!"))))))
#+END_SRC
*** TeX
#+BEGIN_SRC emacs-lisp
(use-package auctex)
#+END_SRC
*** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.scss\\'" . web-mode)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Screencast
#+BEGIN_SRC emacs-lisp
(autoload 'gif-screencast-toggle-pause "gif-screencast" "Start GIF Screencast" t)
(autoload 'gif-screencast-toggle-pause "keycase" "Start GIF Screencast" t)
(after! gif-screencast
  (bind-key "<f8>" 'gif-screencast-toggle-pause gif-screencast-mode-map)
  (bind-key "<f9>" 'gif-screencast-stop) gif-screencast-mode-map)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package hydra
  :config <<hydra>>)
#+END_SRC
** Theme
*** Solarized
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :demand t
  :config (load-theme 'solarized-dark))
#+END_SRC
*** Font Face
Normally use Hack.
#+BEGIN_SRC emacs-lisp
(set-face-font 'default "Hack")
(set-frame-font "Hack" nil t)
(custom-set-faces
 '(variable-pitch ((t (:family "Palatino Linotype")))))
#+END_SRC
*** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
(diminish 'visual-line-mode)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC
**** 80 Columns
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC
*** Highlighting
**** Syntax
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
**** Rainbow Mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer 2
  :diminish
  :config (rainbow-mode 1))
#+END_SRC
**** Source Code Blocks
Native syntax highlighting for source blocks in org mode.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC
**** Parentheses
Normally, I want the opening and closing parentheses highlighted. I used to set
=show-paren-style= to =expression=, all that highlighting was not really necessary.
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'parenthesis)
#+END_SRC
When I'm doing dedicated editing, it's sometimes nice to have more colours,
especially for Lisps such as Emacs Lisp. However, it's too distracting in org
mode source blocks, and it also slows down the point's movement, so I find it
best not to enable it globally.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (emacs-lisp-mode . rainbow-delimiters-mode))
#+END_SRC
**** Except in Large Buffers
#+BEGIN_SRC emacs-lisp
(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))
(add-hook 'prog-mode-hook
          (lambda ()
            ;; turn off `nlinum-relative-mode' when there are more than 5000 lines
            (when (buffer-too-big-p)
              (nlinum-relative-mode -1)
              (font-lock-mode -1))))
#+END_SRC
* Keybindings
** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Define context-aware keys in Emacs · Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def
                                                 &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
** Better Defaults
These are what I think are better bindings for or better versions of the default
 commands.
*** Easy M-x
Alt is simply too hard to hit for such a commonly used command.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" #'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" 'set-mark-command)
#+END_SRC
*** Shell Kill Word
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" 'backward-kill-word)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring
  :config (browse-kill-ring-default-keybindings))
#+END_SRC
*** Cut/Paste
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2)))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
Org Mode rebinds =C-k= to its own kill line function, so we set up another binding
here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-k" . xah-cut-line-or-region)
#+END_SRC
*** Fill/Unfill
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands unfill-paragraph)
(defun gm/fill-or-unfill ()
  (interactive)
  (let ((length-of-line
         (length (buffer-substring-no-properties
               (line-beginning-position)
               (line-end-position)))))
    (if (> length-of-line 81) (fill-paragraph) (unfill-paragraph))))
(bind-key "M-q" #'gm/fill-or-unfill)
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(bind-key "M-j" (λ! (join-line -1)))
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Paragraph Naviagation
Keep blank lines as paragraph delimiters, no matter the major mode. From [[http://endlessparentheses.com/meta-binds-part-2-a-peeve-with-paragraphs.html][Meta
Binds Part 2: A peeve with paragraphs · Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(bind-key "M-p" 'endless/backward-paragraph)
(bind-key "M-n" 'endless/forward-paragraph)

(defun endless/forward-paragraph (&optional n)
  "Advance just past next blank line."
  (interactive "p")
  (let ((para-commands
         '(endless/forward-paragraph endless/backward-paragraph)))
    ;; Only push mark if it's not active and we're not repeating.
    (or (use-region-p)
        (not (member this-command para-commands))
        (member last-command para-commands)
        (push-mark))
    ;; The actual movement.
    (dotimes (_ (abs n))
      (if (> n 0)
          (skip-chars-forward "\n[:blank:]")
        (skip-chars-backward "\n[:blank:]"))
      (if (search-forward-regexp
           "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
          (goto-char (match-end 0))
        (goto-char (if (> n 0) (point-max) (point-min)))))))

(defun endless/backward-paragraph (&optional n)
  "Go back up to previous blank line."
  (interactive "p")
  (endless/forward-paragraph (- n)))
#+END_SRC
But Org Mode messes this up. So we setup a binding using the =:bind= keyword from
=use-package=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("M-n" . forward-paragraph)
("M-p" . backward-paragraph)
#+END_SRC
*** Better Narrowing
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim · Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
#+END_SRC
Then we can use =narrow-or-widen-dwim= to easily edit org =src= blocks.
#+BEGIN_SRC emacs-lisp
(after! org-src
  (define-key org-src-mode-map
     "\C-x\C-s" #'org-edit-src-exit))
#+END_SRC
*** Delete Better
When using =C-d= or =Backspace=, delete all white space in a certain direction, and
not just one.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :config (global-hungry-delete-mode))
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" #'delete-current-buffer-file)
#+END_SRC
Rename better.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file." name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" #'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key [remap switch-buffer] #'ivy-switch-buffer)
#+END_SRC
Use ibuffer.
#+BEGIN_SRC emacs-lisp
(autoload 'ibuffer "ibuffer" "List buffers." t)
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC
*** Beacon Mode
Never lose your cursor again.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 2
  :diminish (beacon-mode " ☀")
  :config (beacon-mode 1)
  :custom
  (beacon-push-mark 35)
  (beacon-color "#b58900"))
#+END_SRC
*** Window Management
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window delete-window delete-other-windows split-window-below split-window right)
  :bind (("C-x o" . ace-window)
         ("M-o" . ace-window)
         ("C-x 0" . delete-window)
         ("C-x 1" . delete-other-windows)
         ("C-x 2" . split-window-below)
         ("C-x 3" . split-window-right)))
#+END_SRC
*** Transpose
**** Sentences and Paragraphs
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
#+END_SRC
**** Characters
#+BEGIN_SRC emacs-lisp
(bind-key "C-r" 'transpose-chars)
#+END_SRC
*** Search
#+BEGIN_SRC emacs-lisp
(bind-key "C-s" 'swiper)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
*** Unbind Return
I sometimes activate this when exiting God Mode.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-j")
#+END_SRC
** Word Count
Count org-wc.
#+BEGIN_SRC emacs-lisp
(defun gm/wc-display-current-subtree (arg)
  (interactive "P")
  (if arg
      (org-wc-display nil)
    (save-restriction
      (org-narrow-to-subtree)
      (org-wc-display nil))))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(bind-key "C-x g" 'magit-status)
#+END_SRC
** Dictionary
#+BEGIN_SRC emacs-lisp
(bind-key "C-c d" 'sdcv-search)
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (λ! (find-file "~/org/inbox.org")))
#+END_SRC
** Complete Reload
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'gm/reload)
#+END_SRC
** Switch Theme
I only use Solarized Light and Dark, and I switch between them depending on my
surroundings. If I am in a brightly lit room, I prefer to use the light theme
because the dark theme allows too much glare. If it is late at night, I prefer
the dark theme, because there is less bright light going into my eyes.
#+BEGIN_SRC emacs-lisp
(setq gm/theme nil)
(defun gm/switch-theme ()
  (interactive)
  (setq gm/theme (not gm/theme))
  (if (equal gm/theme nil)
      (progn (load-theme 'solarized-light)
             (setq pdf-view-midnight-colors '("#839496" . "#fdf6e3")))
    (progn (load-theme 'solarized-dark)
           (setq pdf-view-midnight-colors '("#839496" . "#002b36"))))
  (modi/revert-all-file-buffers))

(bind-key "C-c t" #'gm/switch-theme)
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols. The dollar sign ($) keychord is
especially useful when typing LaTeX.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC
*** God Mode
Easily enter god mode.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "jk" 'god-mode-all)
#+END_SRC
***
* Org Mode
We have to use ~require~ to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package org
  :init
  (require 'org)
  (require 'ox-latex)
  (require 'org-protocol)
  (use-package ox-hugo :after ox)
  :bind (:map org-mode-map
              <<org-keys>>)
  :config
  <<org-settings>>)
#+END_SRC
** Utilities
*** Locations
We need a place where Org files go by default. Org Mode uses this to, for
example, decide where to put the result of an Org Capture.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-directory "~/org/")
#+END_SRC
We similarly decide other default locations.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-default-notes-file "~/org/inbox.org"
      org-agenda-files '("~/org/inbox.org"
                         "~/org/gtd.org"
                         "~/org/notes.org"
                         "~/org/gcal.org"))
#+END_SRC
Keeping my refile locations minimal makes refiling faster; besides, my primary
use case for refiling is to stow something away in its proper place for later
use. and we just set our "proper places."
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                           ("~/org/someday.org" :level . 1)
                           ("~/org/tickler.org" :maxlevel . 2)
                           ("~/org/notes.org" :maxlevel . 2)))
#+END_SRC
*** Capture
I use Org Capture to organize my todo list, keep notes of ideas I think of, and
kickstart blog posts.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c c" . org-capture)
#+END_SRC
Here are my capture templates.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-capture-templates
 '(("a" "Appointment" entry
    (file "~/org/gcal.org")
    "* %i%? \n%^T\n")
   ("t" "Todo [inbox]" entry
    (file "~/org/inbox.org")
    "* TODO %i%? \n:PROPERTIES:\n:CREATED: %U\n:END:")
   ("j" "Journal" entry
    (file+olp+datetree "~/org/journal.org")
    "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
   ("e" "euler" entry
    (file+olp "~/website/content-org/blog.org" "Euler")
    "** Project Euler %^{Problem Number}: %^{Problem Name} %^g\n:PROPERTIES:\n:EXPORT_FILE_NAME: %\\1\n:EXPORT_DATE: %u\n:EXPORT_DESCRIPTION: My solution to problem %\\1 of Project Euler.\n:END:\n*** Problem Statement\n%?\n*** My Algorithm")
   ("b" "Bookmark"  entry
    (file "~/org/inbox.org")
    "* [[%:link][%:description]]\n:PROPERTIES:\n:CREATED: %U\n:END:\n%:initial\n%?")))
#+END_SRC
*** Todo Lists
I like the following set of =TODO= words. This is what appears
before an Org headline when a todo state is activated.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
*** Google Calendar
I manage deadlines with Org Agenda.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c a" . org-agenda)
#+END_SRC
However, that's not quite enough, because when I'm out and about, I want whatever
I have in my Org Agenda to be able to alert me on my phone. I also want to be
able to enter new events on the go. The best solution I've found for this is to
integrate Org Mode with Google Calendar. The setup is contained in the file for
my personal settings, =private.el=.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(use-package org-gcal
  :commands org-gcal-sync
  :init (setq package-check-signature nil)
  :custom (org-gcal-dir gmacs-cache-dir)
  :hook (org-agenda-mode . org-gcal-sync))
#+END_SRC
*** Miscellaneous
It's very useful to be able to see the word count of a subtree when I am writing
a paper for school.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(use-package org-wc
  :commands org-wc-display
  :bind (:map org-mode-map ("C-c w" . gm/wc-display-current-subtree)))
#+END_SRC
I often use links to easily navigate to a relevant file in cases where I would
rather not use =org-attach=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c l" . org-store-link)
#+END_SRC
I can use =org-cliplink= to paste in a website's URL with the link's description
being the title of that website.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(use-package org-cliplink
  :commands org-cliplink
  :bind (:map org-mode-map ("C-c y" . org-cliplink)))
#+END_SRC
** Prettifying
*** Headlines
Let's make our headings look a bit nicer. The package =org-bullet-mode= replaces the
asterisks that define an Org heading with pretty symbols, like stylized bullet
points.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(use-package org-bullets
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))
#+END_SRC
In a similar vein, it helps the visual hierarchy to have text indented in
accordance with the level of the heading, so I always use =org-indent-mode=.
Because it's always active, it's best to diminish it.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-startup-indented t)
(diminish 'org-indent-mode)
#+END_SRC
*** Emphasis Markers
It looks much cleaner if we omit emphasis markers such as the =*= asterisks that
make something bold. It is enough to just display the argument as bold.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+END_SRC
This snippet from [[https://fuco1.github.io/2018-12-23-Multiline-fontification-with-org-emphasis-alist.html][Multiline fontification with org-emphasis-alist]] lets bolded or
italic blocks stretch across multiple lines. This is useful when I want to
format an entire sentence or paragraph, because I hard-wrap just about
everything I write.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setcar (nthcdr 4 org-emphasis-regexp-components) 10)
#+END_SRC
*** Lists
Have lists begun by, for example, =-= look like a bullet list.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
** Programming
Set up languages loaded for use in Org source blocks and their respective
execution commands.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(org-babel-do-load-languages
      'org-babel-load-languages '((python . t)
                                  (latex . t)))
(setq org-babel-python-command "python3.6"
      org-babel-latex-command "pdflatex")
#+END_SRC
** LaTeX
*** Math Mode
Define a keychord to enter inline math mode. This allows me to get around
messing with making =$= an electrically paired delimieter.
#+BEGIN_SRC emacs-lisp
(key-chord-define org-mode-map "r4" #'gm/enter-math-mode)
#+END_SRC
*** Don't Break Paragraph on Comments
Remove comments from Org document when exporting to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Equation Auto Preview
Not too small.
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.75))
#+END_SRC
Where should it be?
#+BEGIN_SRC emacs-lisp
(setq org-preview-latex-image-directory "cache/ltximg/")
#+END_SRC
Obtained from [[https://gist.github.com/cvcore/760008a4dfb2eadf42afdc9cf01ef979][Charles Wang]].
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar cw/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on. Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)")

(defvar cw/org-valid-fragment-type
      '(latex-fragment
        latex-environment
        link))

(defun cw/org-curr-fragment ()
  "Returns the type and position of the current fragment available for preview inside org-mode. Returns nil at non-displayable fragments"
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type cw/org-valid-fragment-type)
      (list fr-type
            (org-element-property :begin fr)))))

(defun cw/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type)
               (eq 'latex-environment fr-type))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov))))
          ((eq 'link fr-type)
           nil;; delete image overlay here?
           ))))

(defun cw/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (cond ((or (eq 'latex-fragment fr-type) ;; latex stuffs
               (eq 'latex-environment fr-type))
           (when (cw/org-curr-fragment) (org-toggle-latex-fragment))) ;; only toggle preview when we're in a valid region (for inserting in the front of a fragment)
          ((eq 'link fr-type) ;; for images
           (let ((fr-end (org-element-property :end (org-element-context))))
             (org-display-inline-images nil t fr-begin fr-end))))))

(defun cw/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment"
  (and (eq 'org-mode major-mode)
       (let ((curr (cw/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            cw/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr cw/org-last-fragment)))

           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment)
             ;; now remove current image
             (cw/org-remove-fragment-overlay curr)
             ;; and save new fragment
             )
           (setq cw/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            cw/org-last-fragment)
           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment))

           ;; unset last fragment
           (setq cw/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not cw/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (cw/org-remove-fragment-overlay curr)
             )
           (setq cw/org-last-fragment curr))))))

(defvar gm/eq-preview nil)
;; this is buffer local
(defun gm/toggle-equation-preview ()
  (interactive)
  (if gm/eq-preview
      (progn
        (remove-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display t)
        (message "Equation preview disabled."))
    (progn
      (add-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display nil t)
      (message "Equation preview enabled.")))
    (setq gm/eq-preview (not gm/eq-preview)))

(bind-key "C-c p" 'gm/toggle-equation-preview)
#+END_SRC
*** Export
#+BEGIN_SRC emacs-lisp
(defun gm/org-latex-export ()
  (interactive)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (org-latex-export-to-pdf t t)))

(bind-key "C-c b" #'gm/org-latex-export org-mode-map)
#+END_SRC
**** Export Classes
***** Tufte-LaTeX
#+BEGIN_SRC emacs-lisp
(require 'ox-tufte-latex)
(require 'ox-extra)
#+END_SRC
****** Command Links
******* No Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\%s{%s}" path desc))))
#+END_SRC
******* One Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s%s{%s}" path
                       (if (equal "" opt) opt (format "[%s]" opt))
                       arg)))))
#+END_SRC
******* One Option (After Main)
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt-after"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s{%s}%s" path arg
                       (if (equal "" opt) opt (format "[%s]" opt)))))))
#+END_SRC
****** Class Options
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-handout"
               "\\documentclass[symmetric,nobib]{gm-tufte-handout}
   [NO-DEFAULT-PACKAGES]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
****** Keyword Search
#+BEGIN_SRC emacs-lisp
(defun jk-org-kwds ()
  "parse the buffer and return a cons list of (property . value)
from lines like:
,#+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
    (lambda (keyword) (cons (org-element-property :key keyword)
                            (org-element-property :value keyword)))))

(defun jk-org-kwd (KEYWORD)
  "get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (jk-org-kwds))))
#+END_SRC
***** Assignment
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
***** MLA
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-mla"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-mla}
\\renewcommand{\\maketitle}{}
\\renewcommand{\\tableofcontents}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}"))))
#+END_SRC
***** Math Notes
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-notes"
                 "\\documentclass{gm-notes}
[NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC
**** Export Settings
#+BEGIN_SRC emacs-lisp
(setq org-highlight-latex-and-related '(latex))
(setq org-export-with-smart-quotes t)
#+END_SRC
* Mail
Set up the requirements.
#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :commands (notmuch)
  :custom
  (nms-settings-file (expand-file-name "network-security.data" gmacs-cache-dir))
  :config
  (require 'smtpmail)
  (require 'smtpmail-async)
  (run-with-timer 0 (* 15 60)
                (lambda () (progn (shell-command "~/checkmail.sh")
                                  (notmuch-refresh-all-buffers)))))
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp
(setq message-directory "~/mail/"
      message-auto-save-directory "~/mail/draft"
      message-fcc-dirs "~/mail/mbsyncmail/Sent Items")
#+END_SRC
Provide my email and name.
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'message-user-agent
      user-mail-address gm/email
      user-full-name "Gautam Manohar")
#+END_SRC
SMTP for sending mail. The =stream-type= is important because I want my outgoing
mail to at least use TLS encryption. One day, though, I would like to adopt a
more rigorous system of encryption.
#+BEGIN_SRC emacs-lisp
(setq send-mail-function #'async-smtpmail-send-it
      message-send-mail-function #'async-smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-debug-verb t
      smtpmail-stream-type 'starttls
      smtpmail-smtp-server gm/send-mail-server
      smtpmail-smtp-service 587)
#+END_SRC
Nice stuff to have for sending mail.
#+BEGIN_SRC emacs-lisp
(setq message-kill-buffer-on-exit t
      notmuch-address-command 'internal)
#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:unread" :key "i" :sort-order oldest-first)
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s" :sort-order newest-first)
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a" :sort-order newest-first)))
#+END_SRC
Accessing mail, including checking for new mail.
#+BEGIN_SRC emacs-lisp
(defun gm/open-mail ()
  (interactive)
  (shell-command "systemctl --user start checkmail.timer")
  (notmuch)
  (notmuch-refresh-this-buffer))

(bind-key "C-c m" #'gm/open-mail)
#+END_SRC
* Snippets
** Load Snippets
Use SPC instead of TAB to expand snippets. We need to bind =TAB= to =org-cycle= even
though that is the default, because otherwise binding =TAB= to =nil= in
=yas-minor-mode= overrides the default behaviour.
#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(use-package yasnippet
  :defer 3
  :diminish (yas-minor-mode)
  :config
  (yas-global-mode 1)
  (bind-key "<tab>" nil yas-minor-mode-map)
  (bind-key "TAB" nil yas-minor-mode-map)
  (bind-key "SPC" (or (bound-and-true-p yas-maybe-expand) #'yas-expand) yas-minor-mode-map))
#+END_SRC
** Fast Latex Snippets
*** Requirements
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=. To maintain and generate my main snippets,
I use a data structure called a radix tree.
#+BEGIN_SRC emacs-lisp
(require 'radix-tree)
#+END_SRC
*** Helper Functions
**** Simpler =texmathp=
The default =texmathp= function assumes that you are writing valid LaTeX code.
This is all well and good when you are actually writing LaTeX, where things like
the dollar sign have only one meaning, but I write documents almost
entirely in Org Mode (I export them to LaTeX). Here the function easily gets
confused. So I make my own for checking if you are in math mode, which just
looks at the surrounding paragraph. We first make a list of math environments
that our function will look for.
#+BEGIN_SRC emacs-lisp
(setq gm/math-environments '("equation" "align"))
#+END_SRC
The idea is that we search the regin from the beginning of the paragraph to the
point for delimiters for inline math (=\(= and =\)=) and display math (=\begin{ENV}=
and =\end{ENV}=, where =ENV= is an element of =gm/math-environments=). The one
subtlety is that we also look at the starred versions of =ENV=. If there are more
open delimiters than closed delimiters, then the point must be inside a math
block, and so we return true.
#+begin_SRC emacs-lisp
(defun gm/in-math-p ()
  (let ((end (point))
        (start (save-excursion (org-backward-paragraph) (point))))
    (defun gm/in-math-p-helper (s-begin)
      (concat s-begin (mapconcat 'identity
                                 (mapcar (lambda (s) (concat "\\(" s "\\)"))
                                         gm/math-environments) "\\|") "[\\*]?}"))
    (let ((inline-open (how-many "\\\\(" start end))
          (inline-close (how-many "\\\\)" start end))
          (env-open (how-many (gm/in-math-p-helper "\\\\begin{") start end))
          (env-close (how-many (gm/in-math-p-helper "\\\\end{") start end)))
      (or (> (- inline-open inline-close) 0)
              (> (- env-open env-close) 0)))))
#+END_SRC
**** Enter Math Mode
This command will enter inline math mode if not in math mode, and exit otherwise.
#+BEGIN_SRC emacs-lisp
(defun gm/enter-math-mode ()
  (interactive)
  (if (gm/in-math-p)
      (progn
        (goto-char (org-element-property :begin (org-element-context)))
        (forward-char)
        (forward-sexp))
    (insert "\\(\\)")
    (backward-char 2)))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n)
  (buffer-substring-no-properties (- (point) n) (point)))
#+END_SRC
**** Math Mode Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/snippet (key snippet)
  (let ((len (length key)))
        (progn
          (delete-char (- 1 len)) ;; this has to be negative
          (when (= (char-before) ?\\) (delete-char -1))
          (yas-expand-snippet (yas-lookup-snippet snippet)))))
#+END_SRC
**** Get String from File
Put file contents into string. Not recommended for large files.
#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (path)
  (with-temp-buffer
    (insert-file-contents path)
    (buffer-string)))
#+END_SRC
**** Generate Snippets
I wrote this to reduce the amount of redundant code needed to set up the
snippets. First, we create a suffix tree of all the math snippets.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-snippet-file (expand-file-name "math-snippets.el" gmacs-emacs-dir))

(defun gm/math-setup ()
   (setq gm/math-snippets (car (read-from-string (get-string-from-file gm/math-snippet-file))))
   (setq gm/math-suffix
         (--reduce-from (radix-tree-insert acc (car it) (cdr it))
                        radix-tree-empty (mapcar (lambda (x) (cons (reverse (car x)) (cdr x)))
                                                 gm/math-snippets)))
   (loop for x in (delete-dups (mapcar (lambda (x) (substring (car x) (1- (length (car x))) (length (car x)))) gm/math-snippets))
         collect (eval (macroexpand
                        `(define-conditional-key org-mode-map
                             ,x (λ! (gm/math-snippet ,x)) (gm/in-math-p)))))

   (gm/print-sorted-math-snippets-to-file gm/math-snippet-file gm/math-snippets)
   (message nil))
#+END_SRC
We make a completion function.
#+BEGIN_SRC emacs-lisp
(defun radix-tree-keys (subtree prefix)
  (let (keys '())
    (radix-tree-iter-mappings (radix-tree-subtree subtree prefix)
			                  (lambda (key val)
				                (!cons (cons (concat prefix key) val) keys)))
    keys))
#+END_SRC
And a function to get the possible completion candidates from the buffer.
#+BEGIN_SRC emacs-lisp
(defun gm/buff-cand (n key)
  (loop for i from 1 to n
        collect (concat (gm/last-n-chars i) key)))
#+END_SRC
Then, we set up the creation of an actual snippet (note that its length is
capped at 5 characters). The longest snippet is currently =binom=, for the
binomial coefficient (choose function).
#+BEGIN_SRC emacs-lisp
(defun gm/math-snippet (key)
  (setq buff-cand (gm/buff-cand 5 key))
  (setq completions
        (loop for x in (radix-tree-keys gm/math-suffix key) if (member (reverse (car x)) buff-cand)
              collect x))
  (setq snippet (car (sort completions (lambda (a b) (> (length (car a)) (length (car b)))))))
  (if snippet
      (gm/snippet (car snippet) (cdr snippet)) (insert key)))
#+END_SRC
And finally some utility functions. First we get a way to dump our snippet data
to a file.
#+BEGIN_SRC emacs-lisp
(defun gm/print-sorted-math-snippets-to-file (filename data)
  (setq data (sort data (lambda (a b) (string< (car a) (car b)))))
  (with-temp-file filename
    (insert (pp data))))
#+END_SRC
Now we give the user a way to easily add snippets.
#+BEGIN_SRC emacs-lisp
(defun gm/new-math-snippet (snippet-key snippet-name)
  """Creates a new math snippet. If the given 'snippet-name' does not already exist, the given snippet-key is added as another expansion for that snippet name. Otherwise, the user is prompted with a yasnippet file in which they may write the code into which the snippet should expand."""
  (interactive
   (list
    (read-string "Snippet key: ")
    (read-string "Snippet name: ")))
  (unless (or (string= "" snippet-key)
              (string= "" snippet-name))
    (add-to-list 'gm/math-snippets (cons snippet-key snippet-name))
    (setq file-cand (expand-file-name
                     (concat (concat (car (yas-snippet-dirs)) "/latex-mode/")
                             snippet-name)))
    (unless (file-exists-p file-cand)
      (find-file file-cand)
      (yas-expand-snippet (yas-lookup-snippet "new-math-snippet")))
    (gm/print-sorted-math-snippets-to-file gm/math-snippet-file gm/math-snippets)
    (gm/math-setup)))
#+END_SRC
**** Tab Jump to Next LaTeX Position
Modified from the =cdlatex-tab= function in =cdlatex.el=.
#+BEGIN_SRC emacs-lisp
(defun math-tab ()
  (interactive)
  (if (gm/in-math-p)
      (catch 'stop
        (cond
         ((looking-at "}\\|\\]\\|)")
          (forward-char 1)
          (if (or (looking-at "\\\\") (looking-at "[^_\\^({\\[]"))
              (throw 'stop t)))
         ((= (following-char) ?$)
          (while (= (following-char) ?$) (forward-char 1))
          (throw 'stop t))
         ((= (following-char) ?\ )
          (forward-char 1)
          (re-search-forward "[^ ]")
          (if (/= (preceding-char) ?\n) (forward-char -1)))
         (t
          (forward-char 1)))
        (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
          (forward-char -1)
          (cond
           ((= (following-char) ?\ )
            (if (not (bolp)) (forward-char 1)) (throw 'stop t))
           ((= (following-char) ?\n)
            (if (and (bolp) (not (eobp)))
                (throw 'stop t)
              (if (equal "\\\\" (buffer-substring-no-properties
                                 (- (point) 2) (point)))
                  (forward-char 1)
                (throw 'stop t))))
           (t
            (if (or (= (char-syntax (preceding-char)) ?\()
                    (= (char-syntax (preceding-char)) ?\))
                    (= (preceding-char) ?-))
                (throw 'stop t)
              (forward-char 1)
              (if (looking-at "[^_\\^({\\[]")
                  (throw 'stop t)))))))
    (org-cycle)))
#+END_SRC
Bind to tab.
#+BEGIN_SRC emacs-lisp
(bind-key (kbd "<tab>") #'math-tab org-mode-map)
(bind-key (kbd "TAB") #'math-tab org-mode-map)
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as $x_0$ or $a_{18}$. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering.
#+BEGIN_SRC emacs-lisp
(defun gm/char-is-letter (char)
  (memq (get-char-code-property char 'general-category)
        '(Ll Lu Lo Lt Lm Mn Mc Me Nl)))

(defun gm/math-subscript (&rest)
  (cond ((gm/char-is-letter (char-before)) (insert "_"))
        ((string-match "\_[0-9]" (gm/last-n-chars 2))
         (save-excursion
           (backward-char)
           (insert "\{")
           (forward-char)
           (insert "\}")))))
#+END_SRC
Add subscript bindings to each of the ten digits.
#+BEGIN_SRC emacs-lisp
(defun gm/bind-subscript (n)
  (eval (macroexpand
         `(define-conditional-key org-mode-map
              (number-to-string ,n)
              (gm/math-subscript) (gm/in-math-p)))))
(dotimes (n 10) (progn (gm/bind-subscript n) (gm/bind-subscript 9)))
#+END_SRC
**** Simplify Super/Subscripts
#+BEGIN_SRC emacs-lisp
(defun gm/simplify-math-script (&rest)
  (when (string-match "[_^]{.}" (gm/last-n-chars 4))
    (save-excursion
      (delete-char -1)
      (backward-char)
      (delete-char 1))))
(add-hook 'yas-exit-snippet-hook #'gm/simplify-math-script)
#+END_SRC
**** Fraction
Typing "/" after an appropriate block (a number or a balanced set of
parentheses) creates a fraction with this block in the numerator and the point
in the denominator. The outside parentheses will be removed; for example, =(\sin
x)= and then =/= will result in =\frac{\sin x}{|}=.
#+BEGIN_SRC emacs-lisp
(defun gm/line-to-point ()
  (let (start)
    (setq start (line-beginning-position) )
    (buffer-substring-no-properties start (point))))

(defun gm/math-insert-frac-match (match)
  (when match
    (progn (yas-expand-snippet (yas-lookup-snippet "frac"))
           (insert match)
           (yas-next-field))))

(defun gm/math-frac-helper (regexp)
  (let (my-line start end match)
    (setq my-line (gm/line-to-point))
    (when (looking-back regexp (line-beginning-position) t)
      (setq start (match-beginning 0))
      (setq end (match-end 0))
      (setq match (substring my-line
                             (- start (line-beginning-position))
                             (- end (line-beginning-position))))
      (delete-region start end))
    (gm/math-insert-frac-match match)))

(defun gm/math-frac ()
  (interactive)
  (cond ((string-match "[\])]" (char-to-string (char-before)))
         (let (match)
           (progn
             (set-mark-command nil)
             (backward-sexp)
             (setq match (buffer-substring-no-properties
                          (region-beginning) (region-end)))
             (delete-region (region-beginning) (region-end))
             (gm/math-insert-frac-match (substring match 1 -1)))))
        ((string-match "}" (char-to-string (char-before)))
         (gm/math-frac-helper "[\\][A-Za-z]*[\[{].*[\]}]"))
        ((string-match "[0-9a-z]" (char-to-string (char-before)))
         (gm/math-frac-helper "[\\]?[0-9A-Za-z_^]*"))
        (t (yas-expand-snippet (yas-lookup-snippet "frac")))))

(define-conditional-key org-mode-map "/" #'gm/math-frac (gm/in-math-p))
#+END_SRC
**** Easy Split Environments
I wanted to make writing environments like =split= and =align= easier, so that I
wouldn't have to manually add the newline (=\\=) at the end of each line required
to make LaTeX happy.
#+BEGIN_SRC emacs-lisp
(defun gm/math-split-p ()
  (when (gm/in-math-p)
    (save-excursion
      (org-backward-paragraph)
      (forward-line)
      (equal (buffer-substring-no-properties (line-beginning-position) (line-end-position))
                   "\\begin{split}"))))

(defun gm/tex-newline ()
  (interactive)
  (if (equal (buffer-substring-no-properties (line-beginning-position) (line-end-position))
             "\\begin{split}")
      (newline)
    (progn (end-of-line)
           (if (equal (gm/last-n-chars 2) "\\\\")
               (forward-line)
             (insert " \\\\")
             (newline)))))

(define-conditional-key org-mode-map (kbd "RET") #'gm/tex-newline (gm/math-split-p))
#+END_SRC
*** Math Symbols
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta") "β")
  ("C" (insert "\\mathbb{C}") "ℂ")
  ("d" (insert "\\delta") "δ")
  ("D" (insert "\\Delta") "Δ")
  ("e" (insert "\\epsilon") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi") "φ")
  ("F" (insert "\\Phi") "Φ")
  ("g" (insert "\\gamma") "γ")
  ("G" (insert "\\Gamma") "Γ")
  ("h" (insert "\\eta") "η")
  ("k" (insert "\\kappa") "κ")
  ("l" (insert "\\lambda") "λ")
  ("L" (insert "\\Lambda") "Λ")
  ("m" (insert "\\mu") "µ")
  ("n" (insert "\\nu") "ν")
  ("N" (insert "\\nabla ") "∇")
  ("o" (insert "\\omega") "ω")
  ("O" (insert "\\Omega") "Ω")
  ("p" (insert "\\pi") "π")
  ("P" (insert "\\Pi") "Π")
  ("q" (insert "\\theta") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma") "σ")
  ("t" (insert "\\tau") "τ")
  ("u" (insert "\\upsilon") "υ")
  ("U" (insert " \\cup ") "∪")
  ("v" (insert "\\vec ") "v")
  ("w" (insert "\\xi") "ξ")
  ("W" (insert "\\Xi") "Ξ")
  ("x" (insert "\\chi") "χ")
  ("y" (insert "\\psi") "ψ")
  ("Y" (insert "\\Psi") "Ψ")
  ("z" (insert "\\zeta") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph") "ℵ")
  ("e" (insert "\\varepsilon") "ε")
  ("f" (insert "\\phi") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell") "ℓ")
  ("q" (insert "\\Theta") "Θ")
  ("r" (insert "\\varrho") "ρ")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert " \\cdots ") "···")
  ("-" (gm/snippet "" "conjugate") "-"))

(define-conditional-key org-mode-map ";" #'hydra-semicolon-a/body (gm/in-math-p))
#+END_SRC
* Post Init
#+BEGIN_SRC emacs-lisp
(run-hooks 'gmacs-post-init-hook)
#+END_SRC

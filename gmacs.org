#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results silent
* Starting Up
** Early Init
Here's some cutting edge technology. Emacs 27+ introduces =early-init.el=, which
is run before =init.el=, before package initialization.

Package initialization occurs automatically, before =user-init-file= is loaded,
but after =early-init-file=. As we'll see later, we can handle package
initialization ourselves, so there's no need for Emacs to do it first.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC
** Fixing the UI
Emacs ships with a set of pretty strange defaults. The UI is the first thing we
see when we open Emacs, so it better not look ugly. We're going to configure
part of the UI outside Emacs entirely, by editing the =~/.Xresources=. This has
the advantage of killing the ugly parts of the UI before they are born. This is
slightly faster than doing it within Emacs, but it comes at the cost of less
flexibility. For example, if Emacs fails to start up properly, you are possibly
left staring at a chimera of an editor, with default font colours but themed
background colours---because the font is about the same shade as the background,
this makes for some very fun times debugging.
*** Bars
I never use menu bars, tool bars, or scroll bars in Emacs.
#+BEGIN_SRC sh :tangle no
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
#+END_SRC
*** Cursor Blinking
In earlier versions of Emacs, the cursor would blink ten or so times, then
suddenly stop. This got annoying quickly.
#+BEGIN_SRC sh :tangle no
Emacs.cursorBlink: off
#+END_SRC
*** Background Change
Before a theme is initialized, the default background colour that Emacs displays
is white. However, my default theme is a dark theme (Solarized Dark). If I were
to change the background colour after Emacs starts, the screen would flash as it
changes colour. And so I set the default background colour to be that of
Solarized Dark.
#+BEGIN_SRC sh :tangle no
Emacs.background: #002b36
#+END_SRC
The last thing left that is visible throughout startup is the modeline. It
took a bit of Internet sleuthing to figure out how to set this, but here it is.
#+BEGIN_SRC sh :tangle no
Emacs.mode-line.attributeForeground: #93a1a1
Emacs.mode-line.attributeBackground: #002b36
Emacs.mode-line.attributeBox: (:line-width 1 :color "#073642")
#+END_SRC
** Start Server
Always load up a server when opening Emacs.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
** Initialization Settings
I was inspired to implement these optimizations in GMACS thanks to
[[https://github.com/nilcons/emacs-use-package-fast][nilcons/emacs-use-package-fast]].

To increase startup speed, we're going to set =gc-cons-threshold= to a very high
number. This is not ideal when actually using Emacs, so we turn this off when we
finish starting up. If we were to leave this on, we would experience long
garbage collection pauses during use.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

(add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 16777216
                                                 gc-cons-percentage 0.1)))
#+END_SRC
We increase these so that we don't exceed recursion limits unless there is some
kind of infinite loop.
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000
      max-specpdl-size 10000)
#+END_SRC
Now we prevent loading double buffers. This reduces stuttering.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC
Silence some common warnings from the byte-compiler.
#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
Let the user know how quickly GMACS started.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook
          (lambda ()
            (message "GMACS ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Directories
We define a few custom directories to satisfy my own wishes for how things
should be named and to speed up the package initialization process by doing it
ourselves, rather than relying on =package-initialize=. Note that the whole thing
is wrapped in a byte-compile block.

We make the directories if they don't exist. This is done by iterating over a
list to make it easy for to extend to more directories if needed.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar gmacs-emacs-dir (expand-file-name user-emacs-directory)
    "The path to the emacs.d directory.")

  (defvar gmacs-packages-dir (concat gmacs-emacs-dir "packages/")
    "Where package.el and elpa plugins (and their caches) are stored.")

  (defvar gmacs-custom-dir (concat gmacs-emacs-dir "elisp/")
    "Where custom lisp files are stored")

  (defvar gmacs-cache-dir (concat gmacs-emacs-dir "cache/")
    "Where temporary files that could be deleted without anything terrible happening are stored.")

  (dolist (dir (list gmacs-packages-dir))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC
** Add Package Sources
We're going to use a custom package directory, so we need to trick Emacs into
thinking it has initialized packages by setting =package--init-file-ensured= to =t=.
Also, we don't enable packages at startup, because we will let =use-package=
intelligently defer and handle package loading.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir gmacs-packages-dir
        package--init-file-ensured t
        package-enable-at-startup nil))
#+END_SRC
Get =use-package= to always defer loading packages until they are actually needed.
This reduces startup time significantly. We're doing this now, before
=use-package= is even loaded, because otherwise it won't help us when the code
that loads =use-package= is evaluated upon byte-compilation.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t
      use-package-verbose t)
#+END_SRC
We set the =load-path= ourselves. This will be faster than letting
=package-intialize= handle it, because we only add directories we know are from
packages. This way, we don't need to search all third party paths every time we
require a file. We'll also store custom or third-party Emacs Lisp files in
=gmacs-custom-dir=, so we add that to the =load-path=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
  (add-to-list 'load-path gmacs-custom-dir))
#+END_SRC
Our next step is to load =package.el=. We add our package repositories "melpa" and
"gnu," because Emacs' default list of packages is so conservative. Then we need
to initialize the packages and make sure that =use-package= is installed if its
missing. Finally, we tell =use-package= to always install missing packages.
Otherwise, an error would be thrown when a package is missing.

Note that this whole process only run when the file is byte-compiled. This means
that by the time the code is actually evaluated, the =use-package= macro has been
expanded, so the package is not needed anymore. As such, we can do all the
expensive and time-consuming work of getting the packages ready before Emacs has
even started, during byte-compilation.If this config has not been manually
byte-compiled, Emacs will initialize packages on startup as usual.
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)

  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
  (unless (assoc-default "gnu" package-archives)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t))

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package))
#+END_SRC
We also require =diminish= and =bind= because I often use these keywords within
=use-package= declarations.
#+BEGIN_SRC emacs-lisp
(require 'bind-key)
(require 'diminish)
#+END_SRC
** Add Elisp Directory and Custom Directory
I put custom variables outside of my =init.el= file.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" gmacs-emacs-dir))
(when (file-exists-p custom-file) (load custom-file))
#+END_SRC
I put my personal information in =private.el=.
#+BEGIN_SRC emacs-lisp
(setq private-file (expand-file-name "private.el" gmacs-emacs-dir))
(when (file-exists-p private-file) (load private-file))
#+END_SRC
* General Configuration
** User Interface
*** Fullscreen
Start GMACS in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "GMACS")
#+END_SRC
*** Cursor
I prefer a box cursor to a bar cursor.
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor 1)
#+END_SRC
**** Beacon Mode
Never lose your cursor again. This package lights up your cursor when the
screen/cursor position is refactored. It's much more useful than it sounds.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 2
  :diminish (beacon-mode " ☀")
  :config (beacon-mode 1)
  :custom
  (beacon-push-mark 35)
  (beacon-color "#b58900"))
#+END_SRC
*** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Modeline
The =smart-mode-line= package comes with some useful items on the modeline, as
well as colour coding. Some interesting features (which I set in
=sml/replacer-regexp-list=) is shortening features. Another useful thing is that
minor modes are displayed.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 1
  :config
  (sml/setup))
#+END_SRC
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
=line-number-mode= mode displays the current line number in the modeline. Except
when there is a line Emacs decides is too long. In that case, all you see in the
modeline is =??=. See [[https://emacs.stackexchange.com/questions/3824/what-piece-of-code-in-emacs-makes-line-number-mode-print-as-line-number-i][this question]] on Emacs SE for a workaround.
#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC
Given that we're showing the line number in the modeline, it's often nice to
also have the column number.
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Wrap Indented Lines Sensibly
This way, indented lines (such as those visually indented by =org-indent-mode=)
that are wrapped with ~visual-line-mode~ do not begin at character 0, but from
where they are indented.
#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap
  :commands adaptive-wrap-prefix-mode
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+END_SRC
** Quality of Life
*** Macros
Some great macros. =after!= and =lambda!= are from the popular DOOM! Emacs
configuration. The documentation on these will be sparse, because the docstrings
do an excellent job of explaining what's going on.
**** after!
#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
**** lambda!
#+BEGIN_SRC emacs-lisp
(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))
#+END_SRC
**** togglef
Simple macro to avoid having to write a variable name twice.
#+BEGIN_SRC emacs-lisp
(defmacro togglef (place)
  "Toggle PLACE.  non-nil becomes nil, nil becomes t.
PLACE may be a symbol, or any generalized variable allowed by ‘setf’.
The return value is the new value of PLACE."
  `(setf ,place (not ,place)))
#+END_SRC
**** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Define context-aware keys in Emacs · Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with. And
it's two less characters to type.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Stop Cursor Going into Minibuffer Prompt
Sometimes when going back in the minibuffer by using backspace or the left arrow
key, the cursor will move right back into the prompt, and when you start to type
again, Emacs will display the annoying message that the minibuffer text is read
only. This prevents you from manually having to move the cursor out of the
prompt and then back, or pressing =C-g= and starting over.
#+BEGIN_SRC emacs-lisp
(customize-set-variable
 'minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
**** Keystroke Echo Timeout
This is one of those things that I didn't think would be useful until I tried
it. When you type a keybinding, the key sequence shows up in the echo area. But
the default timeout, one second, is a bit too long for me.
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines. To be honest, I have no idea how it works, but it seems to
make Emacs prefer splitting vertically.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil
      split-width-threshold 0)
#+END_SRC
**** Kill Current Buffer
Kill the current buffer.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
**** Uniquify
Make two buffers with the same file name distinguishable. This isn't strictly
necessary because I use =smart-mode-line=, but the default style puts brackets
around the non-unique buffer names, and I prefer a less confusing style.
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
**** Navigation
[[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][This article]] argues that it's usually more useful for =C-a= to take you to the
beginning of the indentation of the line (that is, the logical/contextual
beginning of the line) as opposed to the literal beginning of the line. I tend
to agree.
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
(global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)
#+END_SRC
*** Reloading
As an avid Emacs hacker, it became clear to me very quickly that reloading Emacs
is very useful when testing something out. There are three fronts on which
reloading is useful.

When a file is changed on the disk, I want the content in my Emacs buffer to
reflect that. The only problem with this is that you could lose data if you're
not careful but I autosave almost too often, so this is not a concern for me.
And so I enable =auto-revert-mode= globally. Given this, I silence the messages
that a buffer has been reverted.
#+BEGIN_SRC emacs-lisp
(setq-default auto-revert-mode t)
(setq auto-revert-verbose nil)
(diminish 'auto-revert-mode)
#+END_SRC
Sometimes, however, there are other cases in which we want to reload a buffer.
The change have been not in the file's contents, but in an Emacs setting, such
as the colours of the theme. Or the buffer might not have been representing a
file at all. In these cases, it's usually easiest to revert every open buffer.
This might be a problem for you if you're one of those people who keeps hundreds
of buffers open at a time, but I like to close my buffers liberally with the
knowledge that =recentf= will remember where I've been for me. I obtained the
following function from [[https://emacs.stackexchange.com/questions/24459/revert-all-open-buffers-and-ignore-errors][Emacs Stack Exchange]].
#+BEGIN_SRC emacs-lisp
(defun modi/revert-all-file-buffers ()
  "Refresh all open file buffers without confirmation.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer t t))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers."))
#+END_SRC
Finally, we sometimes need the biggest of guns. To completely reload Emacs, we
just run the procedure of =init.el= again. Usually, we want to load the
byte-compiled version, but for those cases where we just want to load the
uncompiled =.el= file, a prefix argument does the job.
#+BEGIN_SRC emacs-lisp
(defun gm/reload (p)
  (interactive "P")
  (if p
      (org-babel-load-file (expand-file-name "gmacs.org" gmacs-emacs-dir))
    (progn
      (org-babel-tangle-file (expand-file-name "gmacs.org" gmacs-emacs-dir)
                             (expand-file-name "gmacs.el" gmacs-emacs-dir))
      (byte-compile-file (expand-file-name "gmacs.el" gmacs-emacs-dir))
      (load-file (expand-file-name "init.el" gmacs-emacs-dir)))))

(bind-key "C-c r" 'gm/reload)
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves a
lot clutter.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name (concat gmacs-cache-dir "backups")))))
#+END_SRC
I have lots of disk space, and not so much patience when I lose an important
file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq create-lockfiles nil)
(setq auto-save-file-name-transforms `((".*" ,(expand-file-name (concat gmacs-cache-dir "auto-save")) t)))
(setq auto-save-list-file-name (expand-file-name (concat gmacs-cache-dir "auto-save/.saves~")))
#+END_SRC
Store more undo information in memory.
#+BEGIN_SRC emacs-lisp
(setq-default undo-limit 250000)
#+END_SRC
**** History
It's nice to have a history of commands and other things so that you can get
right to work when you open a new Emacs instance, you can get right to work.
Without this, =*table--cell-backward-kill-paragraph= is the default command,
because they are sorted alphabetically. If this has ever been the first command
you wanted to execute after opening Emacs, please let me know.
#+BEGIN_SRC emacs-lisp
(setq-default savehist-file (expand-file-name "savehist" gmacs-cache-dir)
      save-place-file (expand-file-name "saveplaces" gmacs-cache-dir)
      recentf-save-file (expand-file-name "recentf" gmacs-cache-dir)
      transient-history-file (expand-file-name "transient-history.el" gmacs-cache-dir)
      bookmark-default-file (expand-file-name "bookmarks" gmacs-cache-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
Open files to the same place in which they were last closed.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
I like having lots of =recentf= files.
#+BEGIN_SRC emacs-lisp
(setq recentf-auto-cleanup 'never)
#+END_SRC
*** Abbreviations
Abbrevs are a pretty common and useful feature in editors. You can define
abbrevs, which are strings. When you type space after an abbrev, it is expanded
to whatever you want. Saves a lot of keystrokes.
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(setq abbrev-file-name (expand-file-name "abbrevs.el" gmacs-emacs-dir)
        save-abbrevs 'silently)
(bind-key "C-c M a" #'abbrev-mode)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :defer 2
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
*** Programming
The age old debate: tabs or spaces? I say spaces.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2)
#+END_SRC
Make =TAB= indent first then perform completion, if any.
#+BEGIN_SRC emacs-lisp
(setq-default tab-always-indent 'complete)
#+END_SRC
Set up =flycheck=.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package flycheck
  :commands flycheck-mode
  :diminish (flycheck-mode " Ψ")
  :custom (flycheck-display-errors-delay .3)
  :hook (prog-mode . flycheck-mode))
#+END_SRC
Relative line numbers, useful for Vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :hook (prog-mode . nlinum-relative-mode))
#+END_SRC
**** Flycheck Hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-flycheck (:color blue)
  "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("M" flycheck-manual)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-mode)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))
(bind-key "C-c f" #'hydra-flycheck/body)
#+END_SRC
**** Python
Indent with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq-default python-indent-offset 4)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (use-package py-autopep8
    :hook (elpy-mode . py-autopep8-enable-on-save))
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  :hook
  (python-mode . elpy-enable)
  (python-mode . elpy-mode)
  (elpy-mode . flycheck-mode))
#+END_SRC
**** Lisp
Because =use-package= is never actually evaluated/loaded if we byte-compile
=gmacs.el=, it is not automatically syntax-highlighted as a macro.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'emacs-lisp-mode
  '(("use-package" . font-lock-keyword-face)))
#+END_SRC
We don't want annoying comments about having, for example, =;;; package ---
summary= at the top of an Emacs Lisp file.
#+BEGIN_SRC emacs-lisp
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp
(use-package company)
#+END_SRC
*** Which Key Mode
Helpful when you want to see completion for a certain sequence of prefix keys.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 10
  :diminish
  :config (which-key-mode))
#+END_SRC
*** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind (("C-=" . er/expand-region)))
#+END_SRC
*** Async Without Results Window
#+BEGIN_SRC emacs-lisp
(defun async-shell-command-no-window (command)
  (interactive)
  (let ((display-buffer-alist
        (list (cons "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+END_SRC
*** Insert Key Sequence
This command takes a key sequence and inserts it into the buffer. This is
surprisingly much easier than typing it in manually. I got it from [[http://endlessparentheses.com/inserting-the-kbd-tag-in-org-mode.html][this article]].
#+BEGIN_SRC emacs-lisp
(defun endless/insert-key (key)
  "Ask for a key then insert its description.
Will work on both org-mode and any mode that accepts plain html."
  (interactive "kType key sequence: ")
  (let* ((orgp (derived-mode-p 'org-mode))
         (tag (if orgp "=%s=" "<kbd>%s</kbd>")))
    (if (null (equal key "\C-m"))
        (insert
         (format tag (help-key-description key nil)))
      (insert (format tag ""))
      (forward-char (if orgp -1 -6)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c k" . endless/insert-key)
#+END_SRC
** Wordsmithing
*** Basic Configuration
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me. I also don't
live in the typewriter days where the
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

**** Delete Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

**** Don't Adjust Point When Pasting by Mouse
Pasting into Emacs by middle-clicking can be nice, but I don't want the click to
change the location of the point and then paste there instead of where the point
originally was.
#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
**** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
**** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
(diminish 'visual-line-mode)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC
Default wrap at 80 characters.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC
*** Utilities
**** Dictionary
#+BEGIN_SRC emacs-lisp
(autoload 'sdcv-search "sdcv-mode")
(bind-key "C-c d" 'sdcv-search)
#+END_SRC
**** Highlighting/Comments
#+BEGIN_SRC emacs-lisp
(autoload 'ov-highlight/body "ov-highlight")
(bind-key "C-c h" 'ov-highlight/body)
(bind-key "C-c C-h" 'ov-highlight/body)
#+END_SRC
*** Spell Checking
The article [[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]] helped me out in setting up spellchecking in
my own Emacs configuration.

We automatically spellcheck text buffers using =flyspell=. The only mode I write
prose in is Org Mode.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package flyspell
  :diminish
  :init
  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
  :commands (flyspell-mode)
  :bind (:map flyspell-mode-map
              <<flyspell-keys>>)
  :config
  <<flyspell-settings>>)
#+END_SRC
Set up spellchecking using =ispell= and the dictionary =hunspell=. We set the
locally used dictionary to Canadian English, and we set up the list of valid
dictionaries.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_CA"
      ispell-hunspell-dictionary-alist
      '(("en_CA" "[[:alpha:]]" "[^[:alpha:]]" "['’]" nil ("-d" "en_CA") nil utf-8)))
#+END_SRC
As suggested by the Emacs wiki, I suppress messages, which slows down
performance when checking the entire buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(setq-default flyspell-issue-message-flag nil)
#+END_SRC
Spellchecking should not occur inside certain parts of Org Mode buffers like
property drawers and code source blocks. From [[http://endlessparentheses.com/ispell-and-org-mode.html?source=rss][Making Ispell work with org-mode
in Emacs]].
#+BEGIN_SRC emacs-lisp
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("^#\+.*$"))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))

(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
[[http://pragmaticemacs.com/emacs/jump-back-to-previous-typo/][This article]] thinks that going to the previous error is more useful than going
to the next one. This is usually true, and combines well with the abbreviation
feature below.
#+BEGIN_SRC emacs-lisp
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))
        (forward-word)))))
#+END_SRC
We replace =flyspell='s next error command with the above previous error command.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-keys
([remap flyspell-goto-next-error] . flyspell-goto-previous-error)
#+END_SRC
Inspired by [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Artur Malabarba]] and Howard Abrams. With this function, we can go to
the previous error and correct it, then add it to our global abbreviation list.
As long as we spell the word incorrectly the same way, we'll never make that
typo again.
#+BEGIN_SRC emacs-lisp
(defun gm/ispell-word-then-abbrev (p)
  "Call `ispell-word'.  After create an abbrev for the correction made.
With prefix P, create local abbrev.  Otherwise it will be
global."
  (interactive "P")
  (flyspell-goto-previous-error 1)
  (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
    (call-interactively 'ispell-word)
    (setq aft (downcase (or (thing-at-point 'word) "")))
    (unless (string= aft bef)
      (define-abbrev
        (if p global-abbrev-table local-abbrev-table)
        bef aft)
      (abbrev-edit-save-to-file abbrev-file-name)
      (message "\"%s\" now expands to \"%s\" %s"
               bef aft (if p "locally" "globally")))))
#+END_SRC
The default binding on =C-;= is =flyspell='s built-in auto-correct function.
However, it doesn't always give perfect matches, and its use case is usurped by
the above function.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-keys
([remap flyspell-auto-correct-previous-word] . gm/ispell-word-then-abbrev)
#+END_SRC
*** Text Manipulation
**** Cut/Paste
From the infamous Xah Lee.
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2)))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
Org Mode rebinds =C-k= to its own kill line function, so we set up another binding
here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-k" . xah-cut-line-or-region)
#+END_SRC
**** Paragraph Navigation
Keep blank lines as paragraph delimiters, no matter the major mode. From [[http://endlessparentheses.com/meta-binds-part-2-a-peeve-with-paragraphs.html][Meta
Binds Part 2: A peeve with paragraphs]].
#+BEGIN_SRC emacs-lisp
(bind-key "M-p" 'endless/backward-paragraph)
(bind-key "M-n" 'endless/forward-paragraph)

(defun endless/forward-paragraph (&optional n)
  "Advance just past next blank line."
  (interactive "p")
  (let ((para-commands
         '(endless/forward-paragraph endless/backward-paragraph)))
    ;; Only push mark if it's not active and we're not repeating.
    (or (use-region-p)
        (not (member this-command para-commands))
        (member last-command para-commands)
        (push-mark))
    ;; The actual movement.
    (dotimes (_ (abs n))
      (if (> n 0)
          (skip-chars-forward "\n[:blank:]")
        (skip-chars-backward "\n[:blank:]"))
      (if (search-forward-regexp
           "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
          (goto-char (match-end 0))
        (goto-char (if (> n 0) (point-max) (point-min)))))))

(defun endless/backward-paragraph (&optional n)
  "Go back up to previous blank line."
  (interactive "p")
  (endless/forward-paragraph (- n)))
#+END_SRC
But Org Mode messes this up. So we setup a binding using the =:bind= keyword from
=use-package=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("M-n" . forward-paragraph)
("M-p" . backward-paragraph)
#+END_SRC
**** Transpose Elements
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
(bind-key "C-r" 'transpose-chars)
#+END_SRC
** Packages
*** Async
Authorize actions.
#+BEGIN_SRC emacs-lisp
(require 'auth-source-pass)
(auth-source-pass-enable)
(setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
*** Tramp
Make sure to keep backups locally and not remotely.
#+BEGIN_SRC emacs-lisp
(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC
Set tramp connection history location.
#+BEGIN_SRC emacs-lisp
(after! tramp-cache
  (setq tramp-persistency-file (expand-file-name "tramp" gmacs-cache-dir)))
#+END_SRC
*** Magit
Magit, the magical Git client, is an amazing porcelain for Git inside of Emacs.
Seriously, I've forgotten how tedious using Git on the command line is, and
every time I have to is a pain. Emacs is worth using for this package alone. We
only load it from the entry points given in =:commands=. We also define a
quick-bind to quit the current Magit session and return to the previous window
configuration. This way, we can let Magit take up the full real estate on the
screen, and once we're done, we can get right back to where we left off.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all)
  :init
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  :bind (("C-x g" . magit-status)
         :map magit-status-mode-map
              ("q" . magit-quit-session)))
#+END_SRC
*** Dired
**** Async
#+BEGIN_SRC emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC
**** Revert Buffer
Have the most up-to-date version of the buffer when using Dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
**** Declutter
#+BEGIN_SRC emacs-lisp
(defun xah-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook #'xah-dired-mode-setup)
#+END_SRC
**** Copy and Delete
Allow Dired to recursively copy and delete directories. ~always~ ensures that no
confirmation dialog comes up, and ~top~ does it only once.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'top)
#+END_SRC
**** Speed Sorting
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a Dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :config (dired-quick-sort-setup))
#+END_SRC
**** Sudo
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :bind (("C-c C-x r" . sudo-edit)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish
  :demand t
  :config
  (ivy-mode 1)
  (use-package flx)
  (use-package smex
    :commands (counsel-M-x)
    :custom
    (smex-save-file (expand-file-name "smex" gmacs-cache-dir))
    (smex-history-length 50))
  (use-package swiper
    :commands (swiper swiper-all))
  (use-package counsel
    :demand t
    :bind ([remap execute-extended-command] . counsel-M-x)
    ([remap org-goto] . counsel-org-goto)
    ("C-s" . counsel-grep-or-swiper)
    :config
    (setq counsel-grep-base-command
          "rg -i -M 120 --color auto --line-number %s %s"))
  :custom
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)
     (t      . ivy--regex-fuzzy)))
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil))
#+END_SRC
*** God Mode
When =god-mode=, all keypresses are interpreted as if preceded by =C-= (as in
"Control"). For example, the sequence =2 n x s= goes down two lines then saves the
buffer.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
 :commands (god-local-mode god-mode-all))
#+END_SRC
Easily enter God Mode.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "jk" 'god-mode-all)
#+END_SRC
Indicate whether we're in God mode with the cursor colour. I've seen other
people do this by having a bar cursor in "insert mode" (to borrow some
terminology from Vim) and a block cursor in "command mode" (in our case, God
Mode).
#+BEGIN_SRC emacs-lisp
(defun gm/god-mode-indicator ()
  (cond (god-local-mode
         (progn (set-cursor-color "#dc322f")))
        (t (progn (set-cursor-color "#657b83")))))

(add-hook 'god-mode-enabled-hook #'gm/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'gm/god-mode-indicator)
#+END_SRC
*** PDF Tools
Basic configuration.
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :commands pdf-view-mode
  :config
  (setq pdf-annot-activate-created-annotations t)
  :diminish pdf-view-midnight-minor-mode
  :bind (:map pdf-view-mode-map
              ("C-s" . counsel-grep-or-swiper)
              ("h" . pdf-annot-add-highlight-markup-annotation)
              ("t" . pdf-annot-add-text-annotation)
              ("D". pdf-annot-delete)
              ("r" . pdf-view--rotate))
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-width-to-window))
(eval-when-compile (pdf-tools-install))
#+END_SRC
Allow rotation.
#+BEGIN_SRC emacs-lisp
(defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  (interactive)
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!"))))))
#+END_SRC
*** TeX
#+BEGIN_SRC emacs-lisp
(use-package auctex)
#+END_SRC
*** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.scss\\'" . web-mode)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Screencast
#+BEGIN_SRC emacs-lisp
(autoload 'gif-screencast-toggle-pause "gif-screencast" "Start GIF Screencast" t)
(autoload 'gif-screencast-toggle-pause "keycase" "Start GIF Screencast" t)
(after! gif-screencast
  (bind-key "<f8>" 'gif-screencast-toggle-pause gif-screencast-mode-map)
  (bind-key "<f9>" 'gif-screencast-stop) gif-screencast-mode-map)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package hydra
  :config <<hydra>>)
#+END_SRC
*** Window Management
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window delete-window delete-other-windows split-window-below split-window right)
  :bind (("C-x o" . ace-window)
         ("M-o" . ace-window)
         ("C-x 0" . delete-window)
         ("C-x 1" . delete-other-windows)
         ("C-x 2" . split-window-below)
         ("C-x 3" . split-window-right)))
#+END_SRC

** Theme
I use the popular Solarized Light/Dark themes.
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :demand t
  :config (load-theme 'solarized-dark))
#+END_SRC
Also, it turns out we can style tooltips as well.
#+BEGIN_SRC emacs-lisp
(setq x-gtk-use-system-tooltips nil)
#+END_SRC
I switch between the light and dark variants depending on my surroundings. If I
am in a brightly lit room, I prefer to use the light theme, because the dark
theme allows too much screen glare. At night (really, at most times, but in
particular at night) I prefer the dark theme, which, unsurprisingly, spits less
light into my eyes.

The way I switch themes is, admittedly, somewhat hacky. I set a boolean (by
default true) that is true if the active theme is dark, false if light. What can
I say? I prefer the dark side. Then my switch function toggles that value and
changes the theme and the corresponding colours for =pdf-view-mode=. I like to
view my PDFs not in black and white, but in my theme's colours. To make sure
everything looks right, including the colours in PDFs and the asterisks
for headlines in Org Mode (I hide them with =org-bullets-mode= but one of them
comes back when I switch themes, for some reason), I refresh all open buffers.
#+BEGIN_SRC emacs-lisp
(setq gm/dark t)
(defun gm/switch-theme ()
  (interactive)
  (togglef gm/dark)
  (if gm/dark
      (progn (load-theme 'solarized-light)
             (setq pdf-view-midnight-colors '("#839496" . "#fdf6e3")))
    (progn (load-theme 'solarized-dark)
           (setq pdf-view-midnight-colors '("#839496" . "#002b36"))))
  (modi/revert-all-file-buffers))

(bind-key "C-c t" #'gm/switch-theme)
#+END_SRC
*** Font Face
I normally use Hack, a monospace font.
#+BEGIN_SRC emacs-lisp
(set-face-font 'default "Hack")
(set-frame-font "Hack" nil t)
(custom-set-faces
 '(variable-pitch ((t (:family "Palatino Linotype")))))
#+END_SRC
*** Highlighting
**** Syntax
I want syntax highlighting everywhere...
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
except in massive buffers, where it probably wouldn't be that useful (syntax
highlighting doesn't help you read a CSV file with thousands of lines) and would
definitely slow things down. In such buffers I also remove line numbers.
#+BEGIN_SRC emacs-lisp
(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))
(add-hook 'prog-mode-hook
          (lambda ()
            ;; turn off `nlinum-relative-mode' when there are more than 5000 lines
            (when (buffer-too-big-p)
              (nlinum-relative-mode -1)
              (font-lock-mode -1))))
#+END_SRC
**** Rainbow Mode
This is a handy little package that highlights hex-color strings with their
colour.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer 2
  :diminish
  :config (rainbow-mode 1))
#+END_SRC
**** Parentheses
Normally, I want the opening and closing parentheses highlighted. I used to set
=show-paren-style= to =expression=, all that highlighting was not really necessary.
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'parenthesis)
#+END_SRC
When I'm doing dedicated editing, it's sometimes nice to have more colours,
especially for Lisps such as Emacs Lisp. However, it's too distracting in org
mode source blocks, and it also slows down the point's movement, so I find it
best not to enable it globally.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (emacs-lisp-mode . rainbow-delimiters-mode))
#+END_SRC
* Keybindings
** Better Defaults
These are what I think are better bindings for or better versions of the default
commands.
*** Easy M-x
Alt is simply too hard to hit for such a commonly used command.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" #'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above. And I know, I know, everyone
loves =transpose-chars=, but I don't see myself using it that much.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" 'set-mark-command)
#+END_SRC
*** Shell Kill Word
Use the standard Unix shell binding for deleting the previous word. As a result,
it's fine to remove the default Emacs bindings for this. In fact,
=C-<backspace>= in particular can get in the way.
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" 'backward-kill-word)
(unbind-key "C-<backspace>")
(unbind-key "M-DEL")
#+END_SRC
*** Kill Paragraph
This binding takes after the default =M-k= binding for =kill-sentence=.
#+BEGIN_SRC emacs-lisp
(bind-key "M-K" #'kill-paragraph)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring
  :bind ("M-y" . browse-kill-ring)
  :config (browse-kill-ring-default-keybindings))
#+END_SRC
*** Fill/Unfill
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands unfill-paragraph)

(defun gm/fill-or-unfill ()
  (interactive)
  (let ((length-of-line
         (length (buffer-substring-no-properties
               (line-beginning-position)
               (line-end-position)))))
    (if (> length-of-line (1+ fill-column)) (fill-paragraph) (unfill-paragraph))))

(bind-key "M-q" #'gm/fill-or-unfill)
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(bind-key "M-j" (lambda! (join-line -1)))
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Narrowing
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim]].
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(bind-key "n" #'narrow-or-widen-dwim ctl-x-map)
#+END_SRC
Then we can use =narrow-or-widen-dwim= to easily edit org =src= blocks.
#+BEGIN_SRC emacs-lisp
(after! org-src
  (bind-key "C-x C-s" #'org-edit-src-exit org-src-mode-map))
#+END_SRC
*** Delete Better
When using =C-d= or =Backspace=, delete all white space in a certain direction, and
not just one.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :commands (hungry-delete-mode global-hungry-delete-mode)
  :config (setq-default hungry-delete-mode t))
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" #'delete-current-buffer-file)
#+END_SRC
Rename better.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file." name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" #'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key [remap switch-buffer] #'ivy-switch-buffer)
#+END_SRC
Use =ibuffer=.
#+BEGIN_SRC emacs-lisp
(autoload 'ibuffer "ibuffer" "List buffers." t)
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
** Open Shell
I have started to use =eshell= as my primary shell. However, I sometimes want to
use my default =zsh= shell, which I access with =deepin-terminal= as a frontend.
This command ensures that =eshell= is opened next to, not instead of, my current
buffer.
#+BEGIN_SRC emacs-lisp
(defun eshell-other-window ()
  "Open a `eshell' in a new window."
  (interactive)
  (let ((buf (eshell)))
    (switch-to-buffer (other-buffer buf))
    (switch-to-buffer-other-window buf)))
#+END_SRC
I rebind the redundant help binding (there is already a more convenient prefix
map at =C-h=). I would use =C-M-t= to open a normal terminal, rebinding the Ubuntu
default, but I'm not sure how to make this Emacs command override the system
default.
#+BEGIN_SRC emacs-lisp
(bind-key "<f1>" #'eshell-other-window)
(bind-key "C-M-s" (lambda! (shell-command "deepin-terminal")))
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (lambda! (find-file "~/org/inbox.org")))
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols. The dollar sign ($) keychord is
especially useful when typing LaTeX.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC

* Org Mode
We have to require the entire =org.el= file to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package org
  :init
  (require 'org)
  (require 'ox-latex)
  (require 'org-protocol)
  (use-package ox-hugo :after ox)
  :bind (:map org-mode-map
              <<org-keys>>)
  :config
  <<org-settings>>)
#+END_SRC
** Configuration
*** Better Return
[[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][John Kitchin]] explains how to have Org Mode act more like other word processors,
in that =RET= while in a list adds an item. The default in Org is that =M-RET=
serves this purpose.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun ha/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond
     ((eq 'link (car (org-element-context)))
      (org-return))
     ((and (org-in-item-p) (not (bolp)))
      (if (org-element-property :contents-begin (org-element-context))
          (org-insert-heading)
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     ((org-at-heading-p)
      (if (not (string= "" (org-element-property :title (org-element-context))))
          (progn (org-end-of-meta-data)
                 (org-insert-heading))
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")))
     ((org-at-table-p)
      (if (-any?
           (lambda (x) (not (string= "" x)))
           (nth
            (- (org-table-current-dline) 1)
            (org-table-to-lisp)))
          (org-return)
        ;; empty row
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     (t
      (org-return)))))
#+END_SRC
We replace the normal return.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("RET" .  #'gm/org-return)
#+END_SRC
** Utilities
*** File Locations
We need a place where Org files go by default. Org Mode uses this to, for
example, decide where to put the result of an Org Capture.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-directory "~/org/")
#+END_SRC
We similarly decide other default locations.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-default-notes-file "~/org/inbox.org"
      org-agenda-files '("~/org/inbox.org"
                         "~/org/gtd.org"
                         "~/org/notes.org"
                         "~/org/gcal.org"))
#+END_SRC
Keeping my refile locations minimal makes refiling faster; besides, my primary
use case for refiling is to stow something away in its proper place for later
use. and we just set our "proper places."
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                           ("~/org/someday.org" :level . 1)
                           ("~/org/tickler.org" :maxlevel . 2)
                           ("~/org/notes.org" :maxlevel . 2)))
#+END_SRC
*** Capture
I use Org Capture to organize my todo list, take note of ideas I think of, and
kickstart blog posts.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c c" . org-capture)
#+END_SRC
Here are my capture templates.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-capture-templates
 '(("a" "Appointment" entry
    (file "~/org/gcal.org")
    "* %i%? \n%^T\n")
   ("t" "Todo [inbox]" entry
    (file "~/org/inbox.org")
    "* TODO %i%?
:PROPERTIES:\n:CREATED: %U\n:END:")
   ("j" "Journal" entry
    (file+olp+datetree "~/org/journal.org")
    "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
   ("e" "euler" entry
    (file+olp "~/website/content-org/blog.org" "Euler")
    "** Project Euler %^{Problem Number}: %^{Problem Name} %^g
:PROPERTIES:
:EXPORT_FILE_NAME: %\\1
:EXPORT_DATE: %u
:EXPORT_DESCRIPTION: My solution to problem %\\1 of Project Euler.
:END:\n*** Problem Statement\n%?\n*** My Algorithm")
   ("b" "Bookmark"  entry
    (file "~/org/inbox.org")
    "* [[%:link][%:description]]\n:PROPERTIES:\n:CREATED: %U\n:END:\n%:initial\n%?")))
#+END_SRC
*** Todo Lists
I like the following set of =TODO= words. This is what appears
before an Org headline when a todo state is activated.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC
Automatically archive cancelled tasks.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-state-tags-triggers '(("CANCELLED" ("ARCHIVE" . t))))
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
*** Google Calendar
I manage deadlines with Org Agenda.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c a" . org-agenda)
#+END_SRC
However, that's not quite enough, because when I'm out and about, I want whatever
I have in my Org Agenda to be able to alert me on my phone. I also want to be
able to enter new events on the go. The best solution I've found for this is to
integrate Org Mode with Google Calendar. The setup is contained in the file for
my personal settings, =private.el=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-gcal
  :commands org-gcal-sync
  :init (setq package-check-signature nil)
  :custom (org-gcal-dir gmacs-cache-dir)
  :hook (org-agenda-mode . org-gcal-sync))
#+END_SRC
*** Links
I often use links to easily navigate to a relevant file in cases where I would
rather not use =org-attach=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c l" . org-store-link)
#+END_SRC
Follow links using return rather than =C-c C-o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-return-follows-link t)
#+END_SRC
I can use =org-cliplink= to paste in a website's URL with the link's description
being the title of that website.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-cliplink
  :commands org-cliplink
  :bind (:map org-mode-map ("C-c y" . org-cliplink)))
#+END_SRC
*** Word Count
It's very useful to be able to see the word count of a subtree when I am writing
a paper for school.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-wc
  :commands org-wc-display
  :bind (:map org-mode-map ("C-c w" . gm/wc-display-current-subtree)))
#+END_SRC
I narrow to subtree by default because displaying the count for every subtree in
the file is (usually) unnecessary and (always) too slow.
#+BEGIN_SRC emacs-lisp
(defun gm/wc-display-current-subtree (arg)
  (interactive "P")
  (if arg
      (org-wc-display nil)
    (save-restriction
      (org-narrow-to-subtree)
      (org-wc-display nil))))
#+END_SRC
** Prettifying
*** Headlines
Let's make our headings look a bit nicer. The package =org-bullet-mode= replaces the
asterisks that define an Org heading with pretty symbols, like stylized bullet
points.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-bullets
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))
#+END_SRC
In a similar vein, it helps the visual hierarchy to have text indented in
accordance with the level of the heading, so I always use =org-indent-mode=.
Because it's always active, it's best to diminish it.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-startup-indented t)
(diminish 'org-indent-mode)
#+END_SRC
*** Emphasis Markers
It looks much cleaner if we omit emphasis markers such as the =*= asterisks that
make something bold. It is enough to just display the argument as bold.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+END_SRC
This snippet from [[https://fuco1.github.io/2018-12-23-Multiline-fontification-with-org-emphasis-alist.html][Multiline fontification with org-emphasis-alist]] lets bolded or
italic blocks stretch across multiple lines. This is useful when I want to
format an entire sentence or paragraph, because I hard-wrap just about
everything I write.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setcar (nthcdr 4 org-emphasis-regexp-components) 10)
#+END_SRC
*** Lists
Have lists begun by, for example, =-= look like a bullet list.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
This doesn't change anything in the buffer, which is nice.
** Programming
Set up languages loaded for use in Org source blocks and their respective
default execution commands.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(org-babel-do-load-languages
      'org-babel-load-languages '((python . t)
                                  (latex . t)))

(setq org-babel-python-command "python3.6"
      org-babel-latex-command "pdflatex")
#+END_SRC
Make Org Mode source blocks act normally with respect to indentation and syntax
highlighting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC
I'm generally fine with just evaluating a code block.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
** LaTeX
Highlight LateX inline math in org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-highlight-latex-and-related '(latex))
#+END_SRC
*** Math Mode
Define a keychord to enter inline math mode. This allows me to get around
messing with making =$= an electrically paired delimiter.
#+BEGIN_SRC emacs-lisp
(key-chord-define org-mode-map "r4" #'gm/create-math-fragment)
#+END_SRC
**** Pretty Math Symbols
I got the source for this from [[https://bitbucket.org/mortiferus/latex-pretty-symbols.el][mortiferus]]. The file I use is not the one from
their Bitbucket repo; I have, for example, removed subscripts and superscripts.
#+BEGIN_SRC emacs-lisp
(autoload 'latex-unicode-simplified "latex-pretty-symbols")
#+END_SRC
*** Don't Break Paragraph on Comments
Remove comments from Org document when exporting to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Reformat Math Fragment
For my primary use case of typing math in LaTeX, I don't care about how the
source looks when I'm typing it; I'm often typing it live, so the main concern
is speed. But later, I want it to look nice and readable, with spacing and so
on.
#+BEGIN_SRC emacs-lisp
(defun gm/math-reformat (fr)
  (save-excursion
    (goto-char (nth 1 fr))
    (let ((fr-begin (nth 1 fr))
          (fr-end (org-element-property :end (org-element-context)))
          (base))
      (setq base (buffer-substring-no-properties fr-begin fr-end))
      (defun gm/rf-helper (reg to)
        (setq base (replace-regexp-in-string reg to base)))
      ;; spaces around +
      (gm/rf-helper "\\([^ ]?\\)\\+\\([^ ]?\\)" "\\1 + \\2")
      ;; remove space before superscripts like in sin ^2
      (gm/rf-helper "[ ]\\(\\^[^\\]\\)" "\\1 ")
      ;; never more than 1 space in a row
      (gm/rf-helper "\\s-\\s-*" " ")
      (delete-region fr-begin fr-end)
      (insert base)))
  (goto-char (1- (org-element-property :end (org-element-context)))))
#+END_SRC
*** Equation Auto Preview
Not too small.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.75))
#+END_SRC
Where should it be?
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-preview-latex-image-directory "cache/ltximg/")
#+END_SRC
Obtained from [[https://gist.github.com/cvcore/760008a4dfb2eadf42afdc9cf01ef979][Charles Wang]]. I've modified it to be toggleable and to run a hook
on leaving a math fragment.
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar cw/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on. Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)")

(defvar cw/org-valid-fragment-type
  "List of types of fragments that will be previewed by `cw/org-preview-fragment'"
  '(latex-fragment
    latex-environment))

(defun cw/org-curr-fragment ()
  "Returns the type and position of the current fragment available for preview inside org-mode. Returns nil at non-displayable fragments"
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type cw/org-valid-fragment-type)
      ;; \(...\)| cursor there should not result in active fragment
      (unless (eq (1+ (point)) (org-element-property :end fr))
        (list fr-type
              (org-element-property :begin fr))))))

(defun cw/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (when (memq fr-type cw/org-valid-fragment-type)
      (let ((ov (loop for ov in (org--list-latex-overlays)
                      if
                      (and
                       (<= (overlay-start ov) (point))
                       (>= (overlay-end ov) (point)))
                      return ov)))
        (when ov
          (delete-overlay ov))))))

(defun cw/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (when (and (memq fr-type cw/org-valid-fragment-type)
               (cw/org-curr-fragment))
      (org-toggle-latex-fragment))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun cw/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment"
  (and (eq 'org-mode major-mode)
       (let ((curr (cw/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            cw/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr cw/org-last-fragment)))

           ;; reformat old fragment
           (gm/math-reformat cw/org-last-fragment)

           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment)
             ;; now remove current image
             (cw/org-remove-fragment-overlay curr))

           ;; and save new fragment
           (setq cw/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            cw/org-last-fragment)

           ;; reformat old fragment
           (gm/math-reformat cw/org-last-fragment)
           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (cw/org-preview-fragment cw/org-last-fragment))
           ;; unset last fragment
           (setq cw/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not cw/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (cw/org-remove-fragment-overlay curr)
             (setq cw/org-last-fragment curr))
           ;; there is no point being in on the \( or \) part of the math fragment
           ;; this code jumps the point into the actual math part of the fragment
           (cond
            ((equal (gm/last-n-chars -2) "\\(")
             (forward-char 2))
            ((and (eq (char-before) 92)
                  (eq (char-after) 41))
             (backward-char 1))))))))
#+END_SRC
Toggle the "mode" to preview equations.
#+BEGIN_SRC emacs-lisp
(defvar gm/eq-preview nil)
;; this is buffer local
(defun gm/toggle-equation-preview ()
  (interactive)
  (if gm/eq-preview
      (progn
        (remove-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display t)
        (message "Equation preview disabled."))
    (progn
      (add-hook 'post-command-hook 'cw/org-auto-toggle-fragment-display nil t)
      (message "Equation preview enabled.")))
  (togglef gm/eq-preview))

(bind-key "C-c p" 'gm/toggle-equation-preview)
#+END_SRC
*** Export
#+BEGIN_SRC emacs-lisp
(defun gm/org-latex-export ()
  (interactive)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (org-latex-export-to-pdf t t)))
#+END_SRC
Bind this in Org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c b" . gm/org-latex-export)
#+END_SRC
Don't use straight quotes when exporting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-export-with-smart-quotes t)
#+END_SRC
**** Math Macros
I have a LaTeX =.sty= file with macros for math. I want this to be automatically
included in every LaTeX file exported from Org Mode. The optional third argument
makes sure this package is also loaded when compiling LaTeX image previews, such
as equation previews.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-latex-packages-alist
      '(("" "gm-math" t)))
#+END_SRC
**** Latexmk
The command =gm/auto-tex-cmd= looks at your Org file. If it finds that =xelatex= has
been specified as the desired compilation command, then it uses that. Otherwise,
it runs =latexmk= with normal =pdflatex=. We don't need to worry about compiling the
correct number of times to include bibliography information, or to render
graphics correctly; =latexmk= handles all of that.
#+BEGIN_SRC emacs-lisp
(defun gm/auto-tex-cmd ()
  (let ((texcmd)))
  (setq texcmd "latexmk -pdf -quiet %f")
  (if (string-match "LATEX_CMD: xelatex" (buffer-string))
      (setq texcmd "latexmk -pdflatex=xelatex -pdf -quiet %f"))
  (setq org-latex-to-pdf-process (list texcmd)))

(add-hook 'org-export-latex-after-initial-vars-hook 'gm/auto-tex-cmd)
#+END_SRC
**** Command Links
***** No Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\%s{%s}" path desc))))
#+END_SRC
***** One Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s%s{%s}" path
                       (if (equal "" opt) opt (format "[%s]" opt))
                       arg)))))
#+END_SRC
***** One Option (After Main)
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt-after"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s{%s}%s" path arg
                       (if (equal "" opt) opt (format "[%s]" opt)))))))
#+END_SRC
**** Export Classes
***** Tufte-LaTeX
****** Class Options
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-handout"
               "\\documentclass[symmetric,nobib]{gm-tufte-handout}
   [NO-DEFAULT-PACKAGES]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
***** Assignment
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
***** MLA
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-mla"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-mla}
\\renewcommand{\\maketitle}{}
\\renewcommand{\\tableofcontents}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}"))))
#+END_SRC
***** Notes
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-notes"
                 "\\documentclass{gm-notes}
[NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC
We make this our default class.
#+BEGIN_SRC emacs-lisp
(setq org-latex-default-class "gm-notes")
#+END_SRC
* Mail
Set up the requirements.
#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :commands (notmuch)
  :custom
  (nms-settings-file (expand-file-name "network-security.data" gmacs-cache-dir))
  :config
  (autoload 'notmuch "smtpmail")
  (autoload 'notmuch "smtpmail-async"))
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp
(setq message-directory "~/mail/"
      message-auto-save-directory "~/mail/draft"
      message-fcc-dirs "~/mail/mbsyncmail/Sent Items")
#+END_SRC
Provide my email and name.
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'message-user-agent
      user-mail-address gm/email
      user-full-name "Gautam Manohar")
#+END_SRC
SMTP for sending mail. The =stream-type= is important because I want my outgoing
mail to at least use TLS encryption. One day, though, I would like to adopt a
more rigorous system of encryption.
#+BEGIN_SRC emacs-lisp
(setq send-mail-function #'async-smtpmail-send-it
      message-send-mail-function #'async-smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-debug-verb t
      smtpmail-stream-type 'starttls
      smtpmail-smtp-server gm/send-mail-server
      smtpmail-smtp-service 587)
#+END_SRC
Nice stuff to have for sending mail.
#+BEGIN_SRC emacs-lisp
(setq message-kill-buffer-on-exit t
      notmuch-address-command 'internal)
#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:unread" :key "i" :sort-order oldest-first)
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s" :sort-order newest-first)
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a" :sort-order newest-first)))
#+END_SRC
Accessing mail, including checking for new mail.
#+BEGIN_SRC emacs-lisp
(defun gm/open-mail ()
  (interactive)
  (shell-command "systemctl --user start checkmail.timer")
  (notmuch)
  (notmuch-refresh-this-buffer))

(bind-key "C-c m" #'gm/open-mail)
#+END_SRC
* Snippets
** Load Snippets
Use SPC instead of TAB to expand snippets. We need to bind =TAB= to =org-cycle= even
though that is the default, because otherwise binding =TAB= to =nil= in
=yas-minor-mode= overrides the default behaviour.
#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(use-package yasnippet
  :defer 1
  :diminish (yas-minor-mode " ✂")
  :config
  (yas-global-mode 1)
  (bind-key "<tab>" nil yas-minor-mode-map)
  (bind-key "TAB" nil yas-minor-mode-map)
  (bind-key "SPC" (or (bound-and-true-p yas-maybe-expand) #'yas-expand) yas-minor-mode-map))
#+END_SRC
** QuickMath
*** Requirements
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=. To maintain and generate my main snippets,
I use a data structure called a radix tree.
#+BEGIN_SRC emacs-lisp
(require 'radix-tree)
#+END_SRC
*** Helper Functions
**** Simpler =texmathp=
The default =texmathp= function assumes that you are writing valid LaTeX code.
This is all well and good when you are actually writing LaTeX, where things like
the dollar sign have only one meaning, but I write documents almost entirely in
Org Mode (I export them to LaTeX). Here the function easily gets confused. So I
make my own for checking if you are in math mode, which just looks at the
surrounding paragraph. We first make a list of math environments that our
function will look for.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-environments '("equation" "align"))
#+END_SRC
The idea is that we search the region from the beginning of the paragraph to the
point for delimiters for inline math (=\(= and =\)=) and display math (=\begin{ENV}=
and =\end{ENV}=, where =ENV= is an element of =gm/math-environments=). The one
subtlety is that we also look at the starred versions of =ENV=. If there are more
open delimiters than closed delimiters, then the point must be inside a math
block, and so we return true.
#+begin_SRC emacs-lisp
(defun gm/in-math-p ()
  (let ((end (point))
        (start (save-excursion (org-backward-paragraph) (point))))
    (defun gm/in-math-p-helper (begin-delim)
      (concat begin-delim (mapconcat 'identity
                                 (mapcar (lambda (s) (concat "\\(" s "\\)"))
                                         gm/math-environments) "\\|") "[\\*]?}"))
    (let ((inline-open (how-many "\\\\(" start end))
          (inline-close (how-many "\\\\)" start end))
          (env-open (how-many (gm/in-math-p-helper "\\\\begin{") start end))
          (env-close (how-many (gm/in-math-p-helper "\\\\end{") start end)))
      (or (> (- inline-open inline-close) 0)
          (> (- env-open env-close) 0)))))
#+END_SRC
**** Enter Math Mode
This command will enter inline math mode if not in math mode, and exit otherwise.
#+BEGIN_SRC emacs-lisp
(defun gm/create-math-fragment ()
  (interactive)
  (if (gm/in-math-p)
      (progn
        (goto-char (org-element-property :begin (org-element-context)))
        (forward-char)
        (forward-sexp))
    (insert "\\(\\)")
    (backward-char 2)))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n)
  (buffer-substring-no-properties (- (point) n) (point)))
#+END_SRC
**** Math Mode Snippet
#+BEGIN_SRC emacs-lisp
(defun gm/snippet (key snippet)
  (let ((len (length key)))
        (progn
          (delete-char (- 1 len)) ;; this has to be negative
          (when (= (char-before) ?\\) (delete-char -1))
          (yas-expand-snippet (yas-lookup-snippet snippet)))))
#+END_SRC
**** Get String from File
Put file contents into string. Not recommended for large files.
#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (path)
  (with-temp-buffer
    (insert-file-contents path)
    (buffer-string)))
#+END_SRC
**** Generate Snippets
I wrote this to reduce the amount of redundant code needed to set up the
snippets. First, we create a suffix tree of all the math snippets.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-snippet-file (expand-file-name "math-snippets.el" gmacs-emacs-dir))

(defun gm/math-setup ()
   (setq gm/math-snippets (car (read-from-string (get-string-from-file gm/math-snippet-file))))
   (setq gm/math-suffix
         (--reduce-from (radix-tree-insert acc (car it) (cdr it))
                        radix-tree-empty (mapcar (lambda (x) (cons (reverse (car x)) (cdr x)))
                                                 gm/math-snippets)))
   (loop for x in (delete-dups (mapcar (lambda (x) (substring (car x) (1- (length (car x))) (length (car x)))) gm/math-snippets))
         collect (eval (macroexpand
                        `(define-conditional-key org-mode-map
                             ,x (lambda! (gm/math-snippet ,x)) (gm/in-math-p)))))

   (gm/print-sorted-math-snippets-to-file gm/math-snippet-file gm/math-snippets)
   (message nil))
#+END_SRC
We make a completion function.
#+BEGIN_SRC emacs-lisp
(defun radix-tree-keys (subtree prefix)
  (let (keys '())
    (radix-tree-iter-mappings (radix-tree-subtree subtree prefix)
			                  (lambda (key val)
				                (!cons (cons (concat prefix key) val) keys)))
    keys))
#+END_SRC
And a function to get the possible completion candidates from the buffer.
#+BEGIN_SRC emacs-lisp
(defun gm/buff-cand (n key)
  (loop for i from 0 to n
        collect (concat (gm/last-n-chars i) key)))
#+END_SRC
Then, we set up the creation of an actual snippet (note that its length is
capped at 5 characters). The longest snippet is currently =binom=, for the
binomial coefficient (choose function).
#+BEGIN_SRC emacs-lisp
(defun gm/math-snippet (key)
  (setq buff-cand (gm/buff-cand 5 key))
  (setq completions
        (loop for x in (radix-tree-keys gm/math-suffix key) if (member (reverse (car x)) buff-cand)
              collect x))
  (setq snippet (car (sort completions (lambda (a b) (> (length (car a)) (length (car b)))))))
  (if snippet
      (gm/snippet (car snippet) (cdr snippet)) (insert key)))
#+END_SRC
And finally some utility functions. First we get a way to dump our snippet data
to a file.
#+BEGIN_SRC emacs-lisp
(defun gm/print-sorted-math-snippets-to-file (filename data)
  (setq data (sort data (lambda (a b) (string< (car a) (car b)))))
  (with-temp-file filename
    (insert (pp data))))
#+END_SRC
Now we give the user a way to easily add snippets.
#+BEGIN_SRC emacs-lisp
(defun gm/new-math-snippet (snippet-key snippet-name)
  """Creates a new math snippet. If the given 'snippet-name' does not already exist, the given snippet-key is added as another expansion for that snippet name. Otherwise, the user is prompted with a yasnippet file in which they may write the code into which the snippet should expand."""
  (interactive
   (list
    (read-string "Snippet key: ")
    (read-string "Snippet name: ")))
  (unless (or (string= "" snippet-key)
              (string= "" snippet-name))
    (add-to-list 'gm/math-snippets (cons snippet-key snippet-name))
    (setq file-cand (expand-file-name
                     (concat (concat (car (yas-snippet-dirs)) "/latex-mode/")
                             snippet-name)))
    (unless (file-exists-p file-cand)
      (find-file file-cand)
      (yas-expand-snippet (yas-lookup-snippet "new-math-snippet")))
    (gm/print-sorted-math-snippets-to-file gm/math-snippet-file gm/math-snippets)
    (gm/math-setup)))
#+END_SRC
**** Tab Jump to Next LaTeX Position
Modified from the =cdlatex-tab= function in =cdlatex.el=.
#+BEGIN_SRC emacs-lisp
(defun math-tab ()
  (interactive)
  (if (gm/in-math-p)
      (catch 'stop
        (cond
         ((looking-at "}\\|\\]\\|)")
          (forward-char 1)
          (if (or (looking-at "\\\\") (looking-at "[^_\\^({\\[]"))
              (throw 'stop t)))
         ((= (following-char) ?$)
          (while (= (following-char) ?$) (forward-char 1))
          (throw 'stop t))
         ((= (following-char) ?\ )
          (forward-char 1)
          (re-search-forward "[^ ]")
          (if (/= (preceding-char) ?\n) (forward-char -1)))
         (t
          (forward-char 1)))
        (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
          (forward-char -1)
          (cond
           ((= (following-char) ?\ )
            (if (not (bolp)) (forward-char 1)) (throw 'stop t))
           ((= (following-char) ?\n)
            (if (and (bolp) (not (eobp)))
                (throw 'stop t)
              (if (equal "\\\\" (buffer-substring-no-properties
                                 (- (point) 2) (point)))
                  (forward-char 1)
                (throw 'stop t))))
           (t
            (if (or (= (char-syntax (preceding-char)) ?\()
                    (= (char-syntax (preceding-char)) ?\))
                    (= (preceding-char) ?-))
                (throw 'stop t)
              (forward-char 1)
              (if (looking-at "[^_\\^({\\[]")
                  (throw 'stop t)))))))
    (org-cycle)))
#+END_SRC
Bind to tab.
#+BEGIN_SRC emacs-lisp
(bind-key (kbd "<tab>") #'math-tab org-mode-map)
(bind-key (kbd "TAB") #'math-tab org-mode-map)
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as $x_0$ or $a_{18}$. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering.
#+BEGIN_SRC emacs-lisp
(defun gm/char-is-letter (char)
  (memq (get-char-code-property char 'general-category)
        '(Ll Lu Lo Lt Lm Mn Mc Me Nl)))

(defun gm/math-number-subscript ()
  (interactive)
  (cond ((gm/char-is-letter (char-before)) (insert "_"))
        ((string-match "\_[0-9]" (gm/last-n-chars 2))
         (save-excursion
           (backward-char)
           (insert "\{")
           (forward-char)
           (insert "\}")))))
#+END_SRC
Add subscript bindings to each of the ten digits.
#+BEGIN_SRC emacs-lisp
(defun gm/bind-number-subscript (n)
  (eval (macroexpand
         `(define-conditional-key org-mode-map
              (number-to-string ,n)
              (gm/math-number-subscript) (gm/in-math-p)))))
(dotimes (n 10) (progn (gm/bind-number-subscript n) (gm/bind-number-subscript 9)))
#+END_SRC
**** Fraction
Typing =/= after an appropriate block (a number or a balanced set of parentheses)
creates a fraction with this block in the numerator and the point in the
denominator. The outside parentheses will be removed; for example, =(\sin x)= and
then =/= will result in =\frac{\sin x}{|}=.
#+BEGIN_SRC emacs-lisp
(defun gm/math-insert-frac-match (match)
  (when match
    (progn (yas-expand-snippet (yas-lookup-snippet "frac"))
           (insert match)
           (yas-next-field))))

(defun gm/math-frac-helper (regexp)
  (let (start end match)
    (when (looking-back regexp (line-beginning-position) t)
      (setq start (match-beginning 0))
      (setq end (match-end 0))
      (setq match (buffer-substring-no-properties start end))
      (delete-region start end))
    (gm/math-insert-frac-match match)))

(defun gm/math-frac ()
  (interactive)
  (cond
   ((string-match "[\])]" (char-to-string (char-before)))
    (let (match end)
      (progn
        (setq end (point))
        (backward-sexp)
        (setq match (buffer-substring-no-properties (point) end))
        (delete-region (point) end)
        (gm/math-insert-frac-match (substring match 1 -1)))))
   ((string-match "}" (char-to-string (char-before)))
    (gm/math-frac-helper "[\\][a-z]*[\[{].*[\]}]"))
   ((string-match "[[:alnum:]!]" (char-to-string (char-before)))
    (gm/math-frac-helper "[\\]?[[:alnum:]_^!]*"))
   (t (yas-expand-snippet (yas-lookup-snippet "frac")))))

(define-conditional-key org-mode-map "/" #'gm/math-frac (gm/in-math-p))
#+END_SRC
**** Easy Split Environments
I wanted to make writing environments like =split= and =align= easier, so that I
wouldn't have to manually add the newline (=\\=) at the end of each line required
to make LaTeX happy.
#+BEGIN_SRC emacs-lisp
(defun gm/math-split-p ()
  (when (gm/in-math-p)
    (save-excursion
      (org-backward-paragraph)
      (forward-line)
      (equal (buffer-substring-no-properties (line-beginning-position) (line-end-position))
                   "\\begin{split}"))))

(defun gm/tex-newline ()
  (interactive)
  (if (equal (buffer-substring-no-properties (line-beginning-position) (line-end-position))
             "\\begin{split}")
      (newline)
    (progn (end-of-line)
           (if (equal (gm/last-n-chars 2) "\\\\")
               (forward-line)
             (insert " \\\\")
             (newline)))))

(define-conditional-key org-mode-map (kbd "RET") #'gm/tex-newline (gm/math-split-p))
#+END_SRC
*** Math Symbols
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta") "β")
  ("C" (insert "\\mathbb{C}") "ℂ")
  ("d" (insert "\\delta") "δ")
  ("D" (insert "\\Delta") "Δ")
  ("e" (insert "\\epsilon") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi") "φ")
  ("F" (insert "\\Phi") "Φ")
  ("g" (insert "\\gamma") "γ")
  ("G" (insert "\\Gamma") "Γ")
  ("h" (insert "\\eta") "η")
  ("k" (insert "\\kappa") "κ")
  ("l" (insert "\\lambda") "λ")
  ("L" (insert "\\Lambda") "Λ")
  ("m" (insert "\\mu") "µ")
  ("n" (insert "\\nu") "ν")
  ("N" (insert "\\nabla ") "∇")
  ("o" (insert "\\omega") "ω")
  ("O" (insert "\\Omega") "Ω")
  ("p" (insert "\\pi") "π")
  ("P" (insert "\\Pi") "Π")
  ("q" (insert "\\theta") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma") "σ")
  ("t" (insert "\\tau") "τ")
  ("u" (insert "\\upsilon") "υ")
  ("U" (insert " \\cup ") "∪")
  ("v" (insert "\\vec ") "v")
  ("w" (insert "\\xi") "ξ")
  ("W" (insert "\\Xi") "Ξ")
  ("x" (insert "\\chi") "χ")
  ("y" (insert "\\psi") "ψ")
  ("Y" (insert "\\Psi") "Ψ")
  ("z" (insert "\\zeta") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph") "ℵ")
  ("e" (insert "\\varepsilon") "ε")
  ("f" (insert "\\phi") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell") "ℓ")
  ("q" (insert "\\Theta") "Θ")
  ("r" (insert "\\varrho") "ρ")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert " \\cdots ") "···")
  ("-" (gm/snippet "" "conjugate") "-"))
#+END_SRC
Then we bind this to semicolon.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(define-conditional-key org-mode-map ";" #'hydra-semicolon-a/body (gm/in-math-p))
#+END_SRC

#+TITLE: My Emacs Configuration
#+PROPERTY: header-args :results silent
* Starting Up
** Early Init
Here's some cutting edge technology. Emacs 27+ introduces =early-init.el=, which
is run before =init.el=, before package initialization.

Package initialization occurs automatically, before =user-init-file= is loaded,
but after =early-init-file=. As we'll see later, we can handle package
initialization ourselves, so there's no need for Emacs to do it first.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC
** Fixing the UI
:PROPERTIES:
:header-args: :tangle no
:END:
Emacs ships with a set of pretty strange defaults. The UI is the first thing we
see when we open Emacs, so it better not look ugly. We're going to configure
part of the UI outside Emacs entirely, by editing the =~/.Xresources=.

This has the advantage of killing the ugly parts of the UI before they are born.
This is slightly faster than doing it within Emacs, but it comes at the cost of
less flexibility. For example, if Emacs fails to start up properly, you are
possibly left staring at a chimera of an editor, with default font colours but
themed background colours---because the font is about the same shade as the
background, this makes for some very fun times debugging.

After editing =.Xresources=, remember to reload it with =xrdb merge ~/.Xresources=.
*** Bars
I never use menu bars, tool bars, or scroll bars in Emacs.
#+BEGIN_SRC sh
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
#+END_SRC
*** Cursor Blinking
In earlier versions of Emacs, the cursor would blink ten or so times, then
suddenly stop. This got annoying quickly.
#+BEGIN_SRC sh
Emacs.cursorBlink: off
#+END_SRC
*** Background Colour
Before a theme is initialized, the default background colour that Emacs displays
is white. However, my default theme is a dark theme (Solarized Dark). If I were
to change the background colour after Emacs starts, the screen would flash as it
changes colour. And so I set the default background colour to be that of
Solarized Dark.
#+BEGIN_SRC sh
Emacs.background: #002b36
#+END_SRC
The last thing left that is visible throughout startup is the modeline. It
took a bit of Internet sleuthing to figure out how to set this, but here it is.
#+BEGIN_SRC sh
Emacs.mode-line.attributeForeground: #93a1a1
Emacs.mode-line.attributeBackground: #002b36
Emacs.mode-line.attributeBox: (:line-width 1 :color "#073642")
#+END_SRC
*** Default Font
I often experiment with fonts during an Emacs session, so I set up an easy way
to change that [[*Font Face][here]]. On startup, though, I want something neutral, so I go with
Hack.
#+BEGIN_SRC sh
Emacs.font: Hack-10
#+END_SRC
** Lexical Binding
Enable lexical binding.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC
** Start Server
Always load up a server when opening Emacs.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
** Initialization Settings
I was inspired to implement these optimizations in GMACS thanks to
[[https://github.com/nilcons/emacs-use-package-fast][nilcons/emacs-use-package-fast]].

During startup, we make the garbage collection threshold very high. [[*Garbage Collection][After
startup]], we manage garbage collection with a package.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold #x40000000)
#+END_SRC
We increase these so that we don't exceed recursion limits unless there is some
kind of infinite loop.
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000
      max-specpdl-size 10000)
#+END_SRC
Now we prevent loading double buffers. This reduces stuttering.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC
Silence some common warnings from the byte-compiler.
#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
Let the user know how quickly GMACS started.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook
          (lambda ()
            (message "GMACS ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Directories and File Locations
We define a few custom directories to satisfy my own wishes for how things
should be named and to speed up the package initialization process by doing it
ourselves, rather than relying on =package-initialize=. Note that the whole thing
is wrapped in a byte-compile block.

We make the directories if they don't exist by iterating over a list. This
method makes it easy for to extend to more directories if needed.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar gmacs-emacs-dir (expand-file-name user-emacs-directory)
    "The path to the emacs.d directory.")

  (defvar gmacs-packages-dir (concat gmacs-emacs-dir "packages/")
    "Where package.el and elpa plugins (and their caches) are stored.")

  (defvar gmacs-custom-dir (concat gmacs-emacs-dir "elisp/")
    "Where custom lisp files are stored")

  (defvar gmacs-cache-dir (concat gmacs-emacs-dir "cache/")
    "Where temporary files that could be deleted without anything
    terrible happening are stored.")

  (dolist (dir (list gmacs-packages-dir
                     gmacs-custom-dir
                     gmacs-cache-dir))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC
I put custom variables outside of my =init.el= file.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" gmacs-emacs-dir))
(when (file-exists-p custom-file) (load custom-file))
#+END_SRC
I put my personal information in =private.el=.
#+BEGIN_SRC emacs-lisp
(setq private-file (expand-file-name "private.el" gmacs-emacs-dir))
(when (file-exists-p private-file) (load private-file))
#+END_SRC
** Add Package Sources
We're going to use a custom package directory, so we need to trick Emacs into
thinking it has initialized packages by setting =package--init-file-ensured= to =t=.
Also, we don't enable packages at startup, because we will let =use-package=
intelligently defer and handle package loading.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir gmacs-packages-dir
        package--init-file-ensured t
        package-enable-at-startup nil))
#+END_SRC
Get =use-package= to always defer loading packages until they are actually needed.
This reduces startup time significantly. We're doing this now, before
=use-package= is even loaded, because otherwise it won't help us when the code
that loads =use-package= is evaluated upon byte-compilation.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t
      use-package-verbose t)
#+END_SRC
We set the =load-path= ourselves. This will be faster than letting
=package-intialize= handle it, because we only add directories we know are from
packages. This way, we don't need to search all third party paths every time we
require a file. We'll also store custom or third-party Emacs Lisp files in
=gmacs-custom-dir=, so we add that to the =load-path=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
  (add-to-list 'load-path gmacs-custom-dir))
#+END_SRC
Our next step is to load =package.el=. We add our package repositories "melpa" and
"gnu," because Emacs' default list of packages is so conservative. Then we need
to initialize the packages and make sure that =use-package= is installed if its
missing. Finally, we tell =use-package= to always install missing packages.
Otherwise, an error would be thrown when a package is missing.

Note that this whole process is only run when the file is byte-compiled. This
means that by the time the code is actually evaluated, the =use-package= macro has
been expanded, so the package is not needed anymore. As such, we can do all the
expensive and time-consuming work of getting the packages ready before Emacs has
even started, during byte-compilation. If this config has not been manually
byte-compiled, Emacs will initialize packages on startup as usual.
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)
  (setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("gnu" . "https://elpa.gnu.org/packages/")
          ("org" . "http://orgmode.org/elpa/")))
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package)
    (package-refresh-contents))
  (require 'use-package)
  (setq use-package-always-ensure t))
#+END_SRC
We also require =diminish= and =bind= because I often use these keywords within
=use-package= declarations.
#+BEGIN_SRC emacs-lisp
(require 'bind-key)
(require 'diminish)
#+END_SRC
** Common Libraries
#+BEGIN_SRC emacs-lisp
(use-package async :commands (async-start))
(use-package s :demand t)
(use-package dash :demand t :config (dash-enable-font-lock))
(eval-when-compile (require 'cl))
#+END_SRC
* General Configuration
** User Interface
*** Fullscreen
Start GMACS in glorious fullscreen.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq frame-title-format "GMACS")
#+END_SRC
*** Cursor
I prefer a box cursor to a bar cursor. Setting =x-stretch-cursor= means that this
bar will stretch to the full width of the character it is on. For example, on a
tab (evil tabs!), the cursor will look as wide as a tab.
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor t)
#+END_SRC
**** Beacon Mode
Never lose your cursor again. This package lights up your cursor when the
screen/cursor position is refactored. It's much more useful than it sounds.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 2
  :diminish (beacon-mode " ☀")
  :config (beacon-mode 1)
  :custom
  (beacon-color "#b58900"))
#+END_SRC
*** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Modeline
The =smart-mode-line= package comes with some useful items on the modeline, as
well as colour coding. Some interesting features (which I set in
=sml/replacer-regexp-list=) is shortening features. Another useful thing is that
minor modes are displayed.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :defer 1
  :config
  (sml/setup))
#+END_SRC
What time is it, Mr. Emacs?
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
(setq display-time-format "%l:%M%p")
#+END_SRC
=line-number-mode= mode displays the current line number in the modeline. Except
when there is a line Emacs decides is too long. In that case, all you see in the
modeline is =??=. See [[https://emacs.stackexchange.com/questions/3824/what-piece-of-code-in-emacs-makes-line-number-mode-print-as-line-number-i][this question]] on Emacs SE for a workaround.
#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC
Given that we're showing the line number in the modeline, it's often nice to
also have the column number.
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Scrolling
There are two types of scrolling in Emacs: keyboard scrolling and mouse
scrolling. Both of them are quite jarring out of the box and make the screen
lurch around. Let's fix keyboard scrolling.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+END_SRC
And make mouse scrolling smoother.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Theme
I use the popular Solarized Light/Dark themes.
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :demand t
  :config (load-theme 'solarized-dark))
#+END_SRC
I switch between the light and dark variants depending on my surroundings. If I
am in a brightly lit room, I prefer to use the light theme, because the dark
theme allows too much screen glare. At night (really, at most times, but in
particular at night) I prefer the dark theme, which, unsurprisingly, spits less
light into my eyes.

The way I switch themes is, admittedly, somewhat hacky. I set a boolean (by
default true) that is true if the active theme is dark, false if light. What can
I say? I prefer the dark side. Then my switch function toggles that value and
changes the theme and the corresponding colours for =pdf-view-mode=. I like to
view my PDFs not in black and white, but in my theme's colours. To make sure
everything looks right, including the colours in PDFs and the asterisks
for headlines in Org Mode (I hide them with =org-bullets-mode= but one of them
comes back when I switch themes, for some reason), I refresh all open buffers.
#+BEGIN_SRC emacs-lisp
(defvar gm/theme 'dark)
(defun gm/switch-theme ()
  (interactive)
  (if (eq gm/theme 'dark)
      (progn
        (load-theme 'solarized-light)
        (setq pdf-view-midnight-colors '("#839496" . "#fdf6e3"))
        (setq gm/theme 'light))
    (load-theme 'solarized-dark)
    (setq pdf-view-midnight-colors '("#839496" . "#002b36"))
    (setq gm/theme 'dark))
  (modi/revert-all-file-buffers))
#+END_SRC
**** Font Face
I change my fonts a lot, so I made it easier to set a font.
#+BEGIN_SRC emacs-lisp
(defun gm/change-font ()
  (interactive)
  (let ((font (ivy-completing-read "Choose a font: "
                                   (delete-dups (font-family-list)))))
    (set-face-attribute 'default nil :font font)))
#+END_SRC
I also like using Palatino here.
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(variable-pitch ((t (:family "Source Sans Pro" :height 115)))))
#+END_SRC
I have experienced problems with certain math characters being displayed with a
font from the TeX Gyre family, which causes the line width to be very high. I
set the default font for characters in the "Mathematical Alphanumeric Symbols"
block in Unicode to Symbola. I got the Symbola font from the =ttf-ancient-fonts=
package on the AUR.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x1d400 . #x1d7ff) "Symbola")
#+END_SRC
I do something similar for my =org-ellipsis= character (=⬎=); here, though, I just
prefer how this font draws the character.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x2b0e . #x2b0e) "Symbola")
#+END_SRC
**** Syntax Highlighting
I want syntax highlighting everywhere...
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
except in massive buffers, where it probably wouldn't be that useful (syntax
highlighting doesn't help you read a CSV file with thousands of lines) and would
definitely slow things down. In such buffers I also remove line numbers.
#+BEGIN_SRC emacs-lisp
(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))
(add-hook 'prog-mode-hook
          (lambda ()
            ;; turn off `nlinum-relative-mode' when there are more than 5000 lines
            (when (buffer-too-big-p)
              (nlinum-relative-mode -1)
              (font-lock-mode -1))))
#+END_SRC
Normally, I want the opening and closing parentheses highlighted. I used to set
=show-paren-style= to =expression=, all that highlighting was not really necessary.
#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'parenthesis)
#+END_SRC
When I'm doing dedicated editing, it's sometimes nice to have more colours,
especially for Lisps such as Emacs Lisp. However, it's too distracting in org
mode source blocks, and it also slows down the point's movement, so I find it
best not to enable it globally.
#+BEGIN_SRC emacs-lisp
;; (use-package rainbow-delimiters
;;   :hook (emacs-lisp-mode . rainbow-delimiters-mode))
#+END_SRC
Finally, =rainbow-mode= highlights hex-color strings with their colour. Very handy
for choosing colours, especially when editing CSS files.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer 2
  :diminish
  :config (rainbow-mode 1))
#+END_SRC
** Quality of Life
*** Garbage Collection
This package minimizes the interference of garbage collection with the user
experience. That means fewer annoyingly long pauses while you are using Emacs.
#+BEGIN_SRC emacs-lisp
(use-package gcmh
  :demand t
  :diminish
  :config (gcmh-mode 1))
#+END_SRC
*** Macros
Now for the Elisp macros. =after!= and =lambda!= are from the popular DOOM! Emacs
configuration. The documentation on these will be sparse, because the docstrings
do an excellent job of explaining what's going on.
**** after!
#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
**** lambda!
#+BEGIN_SRC emacs-lisp
(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))
#+END_SRC
**** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with. And
it's two less characters to type.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Stop Cursor Going into Minibuffer Prompt
Sometimes when going back in the minibuffer by using backspace or the left arrow
key, the cursor will move right back into the prompt, and when you start to type
again, Emacs will display the annoying message that the minibuffer text is read
only. This prevents you from manually having to move the cursor out of the
prompt and then back, or pressing =C-g= and starting over.
#+BEGIN_SRC emacs-lisp
(customize-set-variable
 'minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
**** Keystroke Echo Timeout
This is one of those things that I didn't think would be useful until I tried
it. When you type a keybinding, the key sequence shows up in the echo area. But
the default timeout, one second, is a bit too long for me.
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines. To be honest, I have no idea how it works, but it seems to
make Emacs prefer splitting vertically.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil
      split-width-threshold 0)
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
**** Uniquify
Make two buffers with the same file name distinguishable. This isn't strictly
necessary because I use =smart-mode-line=, but the default style puts brackets
around the non-unique buffer names, and I prefer a less confusing style.
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
**** Beginning of Line
[[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][This article]] argues that it's usually more useful for =C-a= to take you to the
beginning of the indentation of the line (that is, the logical/contextual
beginning of the line) as opposed to the literal beginning of the line. I tend
to agree. If you do want to go to the actual beginning of the line, then just
press =C-a= again.
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
(global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)
#+END_SRC
**** Faster Pop-to-mark
[[http://endlessparentheses.com/faster-pop-to-mark-command.html][Endless Parentheses]] shows us this modification to =pop-to-mark= (bound to =C-u
C-t=). Now we can pop the mark multiple times by pressing =C-t= again, rather than
having to type both keystrokes again.
#+BEGIN_SRC emacs-lisp
(defun modi/multi-pop-to-mark (orig-fun &rest args)
  "Call ORIG-FUN until the cursor moves.
Try the repeated popping up to 10 times."
  (let ((p (point)))
    (dotimes (i 10)
      (when (= p (point))
        (apply orig-fun args)))))

(advice-add 'pop-to-mark-command :around #'modi/multi-pop-to-mark)
#+END_SRC
**** Integrate Clipboard and Kill Ring
If you copy something into your clipboard from, say, Firefox, then you can paste
it into Emacs. That's all well and good. But if you kill something in Emacs
after copying something to the clipboard, what you had in the clipboard is lost.
That is, the clipboard cannot make use of the power that comes with the multiple
entries in the kill ring. Let's fix that by adding the system clipboard's
contents to the kill ring.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
*** Work with Protected Files
Authorize actions.
#+BEGIN_SRC emacs-lisp
(require 'auth-source-pass)
(auth-source-pass-enable)
(setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC
*** Persistent Scratch Buffer
The =*scratch*= buffer has come in handy for me many times when I want to quickly
test out some Elisp. It would be nice to have it saved; I could clear it easily if
I wanted to. Luckily, there's a package that does just that.
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :demand t
  :config
  (persistent-scratch-setup-default))
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves a
lot clutter.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name (concat gmacs-cache-dir "backups")))))
#+END_SRC
I have lots of disk space, and not so much patience when I lose an important
file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1
      version-control t
      vc-make-backup-files t
      create-lockfiles nil)
#+END_SRC
**** Autosave
I want to move the autosaved stuff into the cache dir: let's keep everything
nice and neat.
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,(expand-file-name (concat gmacs-cache-dir "auto-save")) t))
      auto-save-list-file-name (expand-file-name (concat gmacs-cache-dir "auto-save/.saves~")))
#+END_SRC
However, Emacs prints a lot of messages to the echo area telling you that a file
has been autosaved. This is unnecessary, so I use [[http://pragmaticemacs.com/emacs/make-emacs-a-bit-quieter/][this hack]] from Pragmatic Emacs
to quiet down the autosave. Essentially, we replace the default autosave
function with our own silent version.
#+BEGIN_SRC emacs-lisp
(setq auto-save-timeout 99999)

(defvar bjm/auto-save-timer nil
  "Timer to run `bjm/auto-save-silent'")

(defvar bjm/auto-save-interval 5
  "How often in seconds of idle time to auto-save with
`bjm/auto-save-silent'")

(defun bjm/auto-save-silent ()
  "Auto-save all buffers silently"
  (interactive)
  (do-auto-save t))

(setq bjm/auto-save-timer
      (run-with-idle-timer 0 bjm/auto-save-interval 'bjm/auto-save-silent))
#+END_SRC
**** History
It's nice to have a history of commands and other things so that you can get
right to work when you open a new Emacs instance, you can get right to work.
Without this, =*table--cell-backward-kill-paragraph= is the default command,
because they are sorted alphabetically. If this has ever been the first command
you wanted to execute after opening Emacs, please let me know.
#+BEGIN_SRC emacs-lisp
(setq-default savehist-file (expand-file-name "savehist" gmacs-cache-dir)
      save-place-file (expand-file-name "saveplaces" gmacs-cache-dir)
      recentf-save-file (expand-file-name "recentf" gmacs-cache-dir)
      transient-history-file (expand-file-name "transient-history.el" gmacs-cache-dir)
      bookmark-default-file (expand-file-name "bookmarks" gmacs-cache-dir))
#+END_SRC
Now we specify what to save.
#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** Reloading
As I tinkered with my Emacs configuration, it quickly became clear to me that
reloading Emacs is useful when testing something out. There are three fronts on
which reloading is useful.

When a file is changed on the disk, I want the content in my Emacs buffer to
reflect that. The only problem with this is that you could lose data if you're
not careful but I autosave almost too often, so this is not a concern for me.
And so I enable =auto-revert-mode= globally. Given this, I silence the messages
that a buffer has been reverted.
#+BEGIN_SRC emacs-lisp
(setq-default auto-revert-mode t)
(setq auto-revert-verbose nil)
(diminish 'auto-revert-mode)
#+END_SRC
Sometimes, however, there are other cases in which we want to reload a buffer.
The change have been not in the file's contents, but in an Emacs setting, such
as the colours of the theme. Or the buffer might not have been representing a
file at all. In these cases, it's usually easiest to revert every open buffer.
This might be a problem for you if you're one of those people who keeps hundreds
of buffers open at a time, but I like to close my buffers liberally with the
knowledge that =recentf= will remember where I've been for me. I obtained the
following function from [[https://emacs.stackexchange.com/questions/24459/revert-all-open-buffers-and-ignore-errors][Emacs Stack Exchange]].
#+BEGIN_SRC emacs-lisp
(defun modi/revert-all-file-buffers ()
  "Refresh all open file buffers without confirmation.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer t t))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers."))
#+END_SRC
Other times, we need to reload Emacs fully. To completely reload Emacs, we just
run the procedure of =init.el= again. Usually, we want to load the byte-compiled
version, but for those cases where we just want to load the uncompiled =.el= file,
a prefix argument does the job. I disable =after-save-hook= because I set up
asynchronous tangling and byte-compilation [[#tangle-async][here]].

Finally, I hope it doesn't come to this too often, but sometimes we must close
Emacs entirely and start a new session. I know, I can feel the agony. =C-x C-c=,
then move your mouse to click Emacs again! Luckily, there's a package for that.
This kills Emacs and starts a new session.
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
Our function completely restarts, compiles and reloads with a prefix argument,
and just loads the existing =.el= file with two prefix arguments.
#+BEGIN_SRC emacs-lisp
(defun gm/reload (p)
  (interactive "P")
  (let ((after-save-hook nil)
        (org (expand-file-name "gmacs.org" gmacs-emacs-dir))
        (el (expand-file-name "gmacs.el" gmacs-emacs-dir))
        (elc (expand-file-name "gmacs.elc" gmacs-emacs-dir))
        (init (expand-file-name "init.el" gmacs-emacs-dir)))
    (cond ((equal p '(4))
           (when (or (not (file-exists-p elc))
                     (file-newer-than-file-p org elc))
             (org-babel-tangle-file org el)
             (byte-compile-file el))
           (load-file init)
           (run-hooks 'after-init-hook))
          ((equal p '(16))
           (org-babel-load-file org))
          (t (restart-emacs)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'gm/reload)
#+END_SRC
*** Abbreviations
Abbrevs are a pretty common and useful feature in editors. You can define
abbrevs, which are strings. When you type space after an abbrev, it is expanded
to whatever you want. Saves a lot of keystrokes.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrevs.el" user-emacs-directory))
(setq-default abbrev-mode t)
(setq save-abbrevs 'silently)
(diminish 'abbrev-mode)
(bind-key "C-c M a" #'abbrev-mode)
#+END_SRC
*** Async Without Results Window
#+BEGIN_SRC emacs-lisp
(defun async-shell-command-no-window (command)
  (interactive)
  (let ((display-buffer-alist
        (list (cons "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+END_SRC
*** Insert Key Sequence
This command takes a key sequence and inserts it into the buffer. This is
surprisingly much easier than typing it in manually. I got it from [[http://endlessparentheses.com/inserting-the-kbd-tag-in-org-mode.html][this article]].
#+BEGIN_SRC emacs-lisp
(defun endless/insert-key (key)
  "Ask for a key then insert its description.
Will work on both org-mode and any mode that accepts plain html."
  (interactive "kType key sequence: ")
  (let* ((orgp (derived-mode-p 'org-mode))
         (tag (if orgp "=%s=" "<kbd>%s</kbd>")))
    (if (null (equal key "\C-m"))
        (insert
         (format tag (help-key-description key nil)))
      (insert (format tag ""))
      (forward-char (if orgp -1 -6)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c k" . endless/insert-key)
#+END_SRC
*** Transpose Windows
Every now and then, you'll want to switch the order of the buffers in Emacs.
This usually happens to me if I have something I'm reading in one buffer (code
reference, PDF) and something I'm writing in the other. I got this from
[[https://github.com/bbatsov/crux][bbatsov/crux]].
#+BEGIN_SRC emacs-lisp
(defun gm/transpose-windows (arg)
  "Transpose the buffers shown in two windows.
Prefix ARG determines if the current windows buffer is swapped
with the next or previous window, and the number of
transpositions to execute in sequence."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (> arg 0) (1- arg) (1+ arg))))))

(bind-key "C-x 4 t" #'gm/transpose-windows)
#+END_SRC
*** Tangle Config File
:PROPERTIES:
:CUSTOM_ID: tangle-async
:END:
I used to have my =init.el= set up so that, if =gmacs.elc= did not exist, it would
tangle =gmacs.org=. This unfortunately means that when I clear out the
byte-compiled file, Emacs takes a long time to start up (about 6 seconds). To
solve this, I tangle this very file on save.

First, we set up a function to do the tangling. We have to, for example, refer
to =user-emacs-directory= and not =gmacs-emacs-directory=, and run =(require
'ob-tangle)= because the function is run in its own subprocess (this is what
allows it to be asynchronous).
#+BEGIN_SRC emacs-lisp
(defun gm/tangle-gmacs-helper ()
  (let ((src (expand-file-name "gmacs.org" user-emacs-directory))
        (dst (expand-file-name "gmacs.el" user-emacs-directory)))
    (require 'ob-tangle)
    (org-babel-tangle-file src dst)
    (byte-compile-file dst)
    (with-current-buffer byte-compile-log-buffer
      (buffer-string))))
#+END_SRC
Then, we wrap this in an asynchronous process. I only really want to know about
this process if it failed.
#+BEGIN_SRC emacs-lisp
(defun gm/tangle-gmacs ()
  (interactive)
  (async-start (symbol-function #'gm/tangle-gmacs-helper)
               (lambda (result)
                 (unless result
                   (message "GMACS unsuccessfully tangled: %s" result)))))
#+END_SRC
Finally. we wrap this in a function that checks whether we're in the right file.
It would be inefficient to tangle the configuration file a different file was
edited and saved.
#+BEGIN_SRC emacs-lisp
(defun gm/tangle-if-config ()
    (when (string-suffix-p "gmacs.org" (buffer-file-name))
      (gm/tangle-gmacs)))

(add-hook 'after-save-hook #'gm/tangle-if-config)
#+END_SRC
*** Benchmarking
**** Functions
To optimize a function, you need to know the actual difference your changes
make.
#+BEGIN_SRC emacs-lisp
(autoload 'benchmark-elapse "benchmark")
#+END_SRC
**** Startup
If I introduce a new feature that increases my startup time, I can test things
out quantitatively with =esup=, a built-in feature.
#+BEGIN_SRC emacs-lisp
(autoload 'esup "esup")
#+END_SRC
*** UTF-8
From [[https://masteringemacs.org/article/working-coding-systems-unicode-emacs][Mastering Emacs]].
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
*** Visual Regexp
#+BEGIN_SRC emacs-lisp
(autoload 'vr/replace "visual-regexp")
(autoload 'vr/query-replace "visual-regexp")
#+END_SRC
** Wordsmithing
*** Basic Configuration
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me. I also don't
live in the typewriter days where the
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Delete Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Don't Adjust Point When Pasting by Mouse
Pasting into Emacs by middle-clicking can be nice, but I don't want the click to
change the location of the point and then paste there instead of where the point
originally was.
#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
**** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
**** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
(diminish 'visual-line-mode)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC
Default wrap at 80 characters.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC
*** Utilities
**** Dictionary
See this [[http://jsomers.net/blog/dictionary][beautiful post]] by James Somers on why you should use this dictionary.
It's Webster's original, his magnum opus.
#+BEGIN_SRC emacs-lisp
(autoload 'sdcv-search "sdcv-mode")
(bind-key "C-c d" 'sdcv-search)
#+END_SRC
**** Highlighting/Comments
#+BEGIN_SRC emacs-lisp
(autoload 'ov-highlight/body "ov-highlight")
(bind-key "C-c h" 'ov-highlight/body)
(bind-key "C-c C-h" 'ov-highlight/body)
#+END_SRC
**** Writing
A minor mode that centres the text in the buffer. Nice distraction-free
environment for writing.
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :commands olivetti-mode)
#+END_SRC
A major mode for writing screenplays in the =.fountain= format.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package fountain-mode
  :commands fountain-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.fountain\\'" . fountain-mode))
  :config
  (add-hook 'fountain-mode-hook
            (lambda () (auto-fill-mode -1)
              (olivetti-mode 1)))
  <<fountain-mode>>
  :custom
  (fountain-export-font "Courier New")
  (fountain-export-scene-heading-format '(bold)))
#+END_SRC
The default export function has some annoying behaviour such as asking if you
want to overwrite the exported file and switching to the export buffer, so I
redefine the function here.
#+BEGIN_SRC emacs-lisp :noweb-ref fountain-mode
(defun fountain-export-buffer (format &optional snippet buffer)
  "Export current buffer or BUFFER to export format FORMAT.

If destination buffer is not empty, ask to overwrite or generate
a new buffer. If destination buffer is the same as source buffer,
generate a new buffer.

Switch to destination buffer if complete without errors,
otherwise kill destination buffer."
  ;; If called interactively, present export format options.
  (interactive
   (list (intern
          (completing-read "Export format: "
                           (mapcar #'car fountain-export-formats) nil t))
         (car current-prefix-arg)))
  (unless buffer
    (save-buffer)
    (setq buffer (current-buffer)))
  (let ((dest-buffer (get-buffer-create
                      (fountain-export-get-filename format buffer)))
        (hook (plist-get (cdr (assq format fountain-export-formats))
                         :hook))
        string complete)
    (unwind-protect
      ;; Export the region to STRING.
      (setq string
            (fountain-export-region (point-min) (point-max) format snippet))
      ;; Insert STRING into DEST-BUFFER.
      (with-current-buffer dest-buffer
        (with-silent-modifications
          (erase-buffer)
          (insert string))
        (write-file (buffer-name)))

      ;; Set COMPLETE flag and run hooks.
      (setq complete t)
      (run-hooks hook))))
#+END_SRC
*** Spelling
**** Setup
The article [[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]] helped me out in setting up spellchecking in
my own Emacs configuration.

We automatically spellcheck text buffers using =flyspell=. The only mode I write
prose in is Org Mode.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package flyspell
  :diminish
  :commands flyspell-mode
  :init
  (add-hook 'org-mode-hook (lambda () (flyspell-mode 1)))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
  <<flyspell-init>>
  :config
  <<flyspell-settings>>)
#+END_SRC
Set up spellchecking using =ispell= and the dictionary =hunspell=. We set the
locally used dictionary to Canadian English, and we set up the list of valid
dictionaries.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_CA"
      ispell-hunspell-dictionary-alist
      '(("en_CA" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_CA") nil utf-8)))
#+END_SRC
As suggested by the Emacs wiki, I supress messages, which slows down
performance when checking the entire buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq-default flyspell-issue-message-flag nil
              flyspell-issue-welcome-flag nil)
#+END_SRC
Spellchecking should not occur inside certain parts of Org Mode buffers like
property drawers and code source blocks. From [[http://endlessparentheses.com/ispell-and-org-mode.html?source=rss][Making Ispell work with org-mode
in Emacs]].
#+BEGIN_SRC emacs-lisp
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("^#\+.*$"))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))

(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
**** Autocorrect and Abbreviations and Avy Selection
We want to be able to go to the previous error and correct it, then add it to
our global abbreviation list. As long as we spell the word incorrectly the same
way, we'll never make that typo again. I used to use code I took and modified
from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Artur Malabarba]] and Howard Abrams, but now I just set this variable built
into =flyspell=.
#+BEGIN_SRC emacs-lisp :tanle no :noweb-ref flyspell-init
(setq flyspell-abbrev-p t)
#+END_SRC
However, I'm not a fan of the default interface for selecting spelling
corrections. Many forces in Emacs fight for window space, from expanded
minibuffers to popup windows. Both have their disadvantages. The minibuffer is
away from the action and requires you to look to a different place on the
screen. Popup windows can easily cause a jarring change in the way content is
displayed on the buffer. The solution is a [[https://github.com/alphapapa/frog-menu][frog menu]].

Its role is not fixed, but ad hoc; it pops up at the right moment in the right
place, just as the frog's tongue pouncing on the fly.

We use the =flyspell-correct= package to implement such an interface. It uses =avy=
for selection.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(autoload 'frog-menu-read "frog-menu")
(use-package flyspell-correct
  :commands flyspell-correct-wrapper
  :custom
  (flyspell-correct-interface #'frog-menu-flyspell-correct))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(defun frog-menu-flyspell-correct (candidates word)
  "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
  (let* ((corrects (if flyspell-sort-corrections
                       (sort candidates 'string<)
                     candidates))
         (actions `(("C-s" "Save word"         (save    . ,word))
                    ("C-a" "Accept (session)"  (session . ,word))
                    ("C-b" "Accept (buffer)"   (buffer  . ,word))
                    ("C-c" "Skip"              (skip    . ,word))))
         (prompt   (format "Correcting %s with [%s]"
                           word
                           (or ispell-local-dictionary
                               ispell-dictionary
                               "default")))
         (res      (frog-menu-read prompt corrects actions)))
    (unless res
      (error "Quit"))
    res))
#+END_SRC
[[http://pragmaticemacs.com/emacs/jump-back-to-previous-typo/][This article]] thinks that going to the previous error is more useful than going
to the next one. This is usually true, and aligns with the default behaviour
=flyspell-correct-wrapper=. The default binding on =C-;= is =flyspell='s built-in
autocorrect function. However, its suggestions are often not so useful, and
we've subsumed its role with =flyspell-correct= anyway.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(bind-key [remap flyspell-auto-correct-previous-word]
          #'flyspell-correct-wrapper flyspell-mode-map)
#+END_SRC
**** Correct Double Capitals
Taken from [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type/13975#13975][Stack Exchange]]. It's a piece of code with a great impact to
complexity ratio. Whenever you're a bit slow in releasing the Shift key and type
something like "THis," =dubcaps-mode= converts it to "This" for you automatically.
This isn't really a hindrance, because if I actually want two capital letters in
a row, I almost never want a lowercase letter to follow.
#+BEGIN_SRC emacs-lisp
(defun gm/dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p 'interactive)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(define-minor-mode gm/dubcaps-mode
  "Toggle `gm/dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  (if gm/dubcaps-mode
      (add-hook 'post-self-insert-hook #'gm/dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'g/dcaps-to-scaps 'local)))

(add-hook 'text-mode-hook #'gm/dubcaps-mode)
#+END_SRC
*** Text Manipulation
**** Cut/Paste
From the infamous Xah Lee.
#+BEGIN_SRC emacs-lisp
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2)))))

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2018-09-10"
  (interactive)
  (if current-prefix-arg
      (progn
        (copy-region-as-kill (point-min) (point-max)))
    (if (use-region-p)
        (progn
          (copy-region-as-kill (region-beginning) (region-end)))
      (if (eq last-command this-command)
          (if (eobp)
              (progn )
            (progn
              (kill-append "\n" nil)
              (kill-append
               (buffer-substring-no-properties (line-beginning-position) (line-end-position))
               nil)
              (progn
                (end-of-line)
                (forward-char))))
        (if (eobp)
            (if (eq (char-before) 10 )
                (progn )
              (progn
                (copy-region-as-kill (line-beginning-position) (line-end-position))
                (end-of-line)))
          (progn
            (copy-region-as-kill (line-beginning-position) (line-end-position))
            (end-of-line)
            (forward-char)))))))

(bind-key "C-k" 'xah-cut-line-or-region)
(bind-key "M-w" 'xah-copy-line-or-region)
#+END_SRC
Org Mode rebinds =C-k= to its own kill line function, so we set up another binding
here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "C-k" #'xah-cut-line-or-region org-mode-map)
#+END_SRC
**** Paragraph Navigation
Keep blank lines as paragraph delimiters, no matter the major mode. From [[http://endlessparentheses.com/meta-binds-part-2-a-peeve-with-paragraphs.html][Meta
Binds Part 2: A peeve with paragraphs]].
#+BEGIN_SRC emacs-lisp
(bind-key "M-p" 'endless/backward-paragraph)
(bind-key "M-n" 'endless/forward-paragraph)

(defun endless/forward-paragraph (&optional n)
  "Advance just past next blank line."
  (interactive "p")
  (let ((para-commands
         '(endless/forward-paragraph endless/backward-paragraph)))
    ;; Only push mark if it's not active and we're not repeating.
    (or (use-region-p)
        (not (member this-command para-commands))
        (member last-command para-commands)
        (push-mark))
    ;; The actual movement.
    (dotimes (_ (abs n))
      (if (> n 0)
          (skip-chars-forward "\n[:blank:]")
        (skip-chars-backward "\n[:blank:]"))
      (if (search-forward-regexp
           "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
          (goto-char (match-end 0))
        (goto-char (if (> n 0) (point-max) (point-min)))))))

(defun endless/backward-paragraph (&optional n)
  "Go back up to previous blank line."
  (interactive "p")
  (endless/forward-paragraph (- n)))
#+END_SRC
But Org Mode messes this up. So we setup a binding using the =:bind= keyword from
=use-package=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("M-n" . forward-paragraph)
("M-p" . backward-paragraph)
#+END_SRC
**** Transpose Elements
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
(bind-key "C-r" 'transpose-chars)
#+END_SRC
**** Capitalize Word
The default behaviour, that pressing =M-c= here (with the cursor at =|=) =capit|alize=
produces =capitAlize= is silly; I can't think of a situation where I would want to
capitalize just the following character if the cursor is in the middle of a
word.
#+BEGIN_SRC emacs-lisp
(defun gm/capitalize-word ()
  (interactive)
  (when (eq (char-before) ? )
    (backward-char))
  (let* ((bounds (bounds-of-thing-at-point 'symbol))
         (beg (car bounds))
         (end (cdr bounds))
         (word (buffer-substring-no-properties beg end)))
    (delete-region beg end)
    (if (string= word (capitalize word))
        (insert (downcase word))
    (insert (capitalize word)))))
(bind-key "M-c" #'gm/capitalize-word)
#+END_SRC
**** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind (("C-=" . er/expand-region)
         ("M-2" . er/expand-region)))
#+END_SRC
**** Change Region to Title Case
#+BEGIN_SRC emacs-lisp
(defvar gm/title-case-skip-chars
  "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕")
(defun xah-title-case-region-or-line (@begin @end)
  "Title case text between nearest brackets, or current line, or text selection.
Capitalize first letter of each word, except words like {to, of,
the, a, in, or, and, …}. If a word already contains cap letters
such as HTTP, URL, they are left as is.

When called in a elisp program, *begin *end are region boundaries.
URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
Version 2017-01-11"
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let (
           p1
           p2
           (skipChars gm/title-case-skip-chars))
       (progn
         (skip-chars-backward skipChars (line-beginning-position))
         (setq p1 (point))
         (skip-chars-forward skipChars (line-end-position))
         (setq p2 (point)))
       (list p1 p2))))
  (let* (
         (strPairs [
                     [" A " " a "]
                     [" And " " and "]
                     [" At " " at "]
                     [" As " " as "]
                     [" By " " by "]
                     [" Be " " be "]
                     [" Into " " into "]
                     [" In " " in "]
                     [" Is " " is "]
                     [" It " " it "]
                     [" For " " for "]
                     [" Of " " of "]
                     [" Or " " or "]
                     [" On " " on "]
                     [" Via " " via "]
                     [" The " " the "]
                     [" That " " that "]
                     [" To " " to "]
                     [" Vs " " vs "]
                     [" With " " with "]
                     [" From " " from "]
                     ["'S " "'s "]
                     ["'T " "'t "]
                     ]))
    (save-excursion
      (save-restriction
        (narrow-to-region @begin @end)
        (upcase-initials-region (point-min) (point-max))
        (let ((case-fold-search nil))
          (mapc
           (lambda (x)
             (goto-char (point-min))
             (while
                 (search-forward (aref x 0) nil t)
               (replace-match (aref x 1) "FIXEDCASE" "LITERAL")))
           strPairs))))))
#+END_SRC
Note that one of the characters we skip is ="=.
** Programming
The age old debate: tabs or spaces? I say spaces.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2)
#+END_SRC
Make =TAB= indent first then perform completion, if any.
#+BEGIN_SRC emacs-lisp
(setq-default tab-always-indent 'complete)
#+END_SRC
Set up =flycheck=.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package flycheck
  :commands flycheck-mode
  :diminish (flycheck-mode " Ψ")
  :custom (flycheck-display-errors-delay .3)
  :hook (prog-mode . flycheck-mode))
#+END_SRC
Relative line numbers, useful for Vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :hook (prog-mode . nlinum-relative-mode))
#+END_SRC
*** Flycheck Hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-flycheck (:color blue)
  "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("M" flycheck-manual)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-mode)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))
(bind-key "C-c f" #'hydra-flycheck/body)
#+END_SRC
*** Python
Indent with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq-default python-indent-offset 4)
#+END_SRC
Turn Emacs into basically a Python IDE.
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (use-package py-autopep8
    :hook (elpy-mode . py-autopep8-enable-on-save))
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  :hook
  (python-mode . elpy-enable)
  (python-mode . elpy-mode)
  (elpy-mode . flycheck-mode))
#+END_SRC
*** Lisp
Because =use-package= is never actually evaluated/loaded if we byte-compile
=gmacs.el=, it is not automatically syntax-highlighted as a macro.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'emacs-lisp-mode
  '(("use-package " . font-lock-keyword-face)))
#+END_SRC
We don't want annoying comments about having, for example, =;;; package ---
summary= at the top of an Emacs Lisp file.
#+BEGIN_SRC emacs-lisp
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
#+END_SRC
Sexps are everything in Lisp. The default bindings to traverse them forwards and
backwards are clunky: =C-M-f=, =C-M-b=. Since I've already taken my =M-digit=
[[*Window Management][bindings]], I'm willing to do it again.
#+BEGIN_SRC emacs-lisp
(bind-key "M-9" #'backward-sexp)
(bind-key "M-0" #'forward-sexp)
#+END_SRC
** Packages
*** Helpful
This package is a more informative alternative to the default Emacs
documentation/help feature. The [[https://github.com/Wilfred/helpful][author's pictures]] explain it better than I
could.
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)
   ("C-h F" . helpful-function)       ; no macros
   ("C-h C" . helpful-command)        ; only interactive functions
  )
  :commands (helpful-callable
             helpful-variable
             helpful-key
             helpful-function
             helpful-command))
#+END_SRC
*** Paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands (package-initialize)
  :config (paradox-enable))
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :defer 2
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
*** Tramp
Make sure to keep backups locally and not remotely.
#+BEGIN_SRC emacs-lisp
(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC
Set tramp connection history location.
#+BEGIN_SRC emacs-lisp
(after! tramp-cache
  (setq tramp-persistency-file (expand-file-name "tramp" gmacs-cache-dir)))
#+END_SRC
*** Magit
Magit, the magical Git client, is an amazing porcelain for Git inside of Emacs.
Seriously, I've forgotten how tedious using Git on the command line is, and
every time I have to is a pain. Emacs is worth using for this package alone. We
only load it from the entry points given in =:commands=. We also define a
quick-bind to quit the current Magit session and return to the previous window
configuration. This way, we can let Magit take up the full real estate on the
screen, and once we're done, we can get right back to where we left off.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all)
  :init
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  :bind (("C-x g" . magit-status)
         :map magit-status-mode-map
              ("q" . magit-quit-session)))
#+END_SRC
*** Dired
#+BEGIN_SRC emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+END_SRC
Have the most up-to-date version of the buffer when using Dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun gm/dired-mode-setup ()
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook #'gm/dired-mode-setup)
#+END_SRC
Allow Dired to recursively copy and delete directories. The option ~always~
ensures that no confirmation dialog comes up; ~top~ would do it only one layer
deep.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
#+END_SRC
But I don't want to permanently delete things. Not yet, anyway.
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC
Great for renaming things in Dired.
#+BEGIN_SRC emacs-lisp
(after! dired
  (require 'visual-regexp))
#+END_SRC
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a Dired buffer.
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :config (dired-quick-sort-setup))
#+END_SRC
This is excellent for editing files owned by root.
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :commands sudo-edit
  :bind (("C-c C-x r" . sudo-edit)))
#+END_SRC
I often find the commands in Dired hard to remember.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "." 'hydra-dired/body dired-mode-map)
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish
  :demand t
  :config
  (ivy-mode 1)
  (use-package flx)
  (use-package smex
    :commands (counsel-M-x)
    :custom
    (smex-save-file (expand-file-name "smex" gmacs-cache-dir))
    (smex-history-length 50))
  (use-package swiper
    :commands (swiper swiper-all))
  (use-package counsel
    :demand t
    :bind
    ([remap execute-extended-command] . counsel-M-x)
    ([remap org-goto] . counsel-org-goto)
    ([remap find-file] . counsel-find-file)
    ("C-s" . counsel-grep-or-swiper)
    (:map ivy-minibuffer-map
          ([remap hungry-delete-backward] . nil))
    :custom
    (counsel-grep-base-command
          "rg -i -M 120 --color auto --line-number %s %s"))
  :custom
  (ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)
     (t . ivy--regex-fuzzy)))
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil))
#+END_SRC
I want to ignore certain file extensions when searching for a file, so I add
them to the regexp in =counsel-find-file-ignore-regexp=.
#+BEGIN_SRC emacs-lisp
(defconst gm/find-file-ignore-extensions
  '("aux" "bbl" "blg" "exe" "log" "meta" "out" "fls" "tdo" "toc" "xdv" "fdx"
    "synctex.gz" "fdb_latexmk"
    "desktop" "elc"
    "pyc"))

(defconst gm/find-file-ignore-dirs
  '("cache/" "auto/" "ltximg/"
    ".git/"))

(setq counsel-find-file-ignore-regexp
      (s-join "\\|" (list (concat (regexp-opt
                                   (--map (concat "." it) gm/find-file-ignore-extensions))
                                  "\\'")            ; make sure we only match end of filename
                          (regexp-opt
                           gm/find-file-ignore-dirs))))
#+END_SRC
We do something similar for =ivy-switch-buffer=.
#+BEGIN_SRC emacs-lisp
(defconst gm/find-file-ignore-names
  '("*elfeed-org*"
    ".org-gcal-token"))

(push (regexp-opt gm/find-file-ignore-names) ivy-ignore-buffers)
#+END_SRC
[[http://pragmaticemacs.com/page/6/][This post]] explains the pitfalls of the default behaviour of =ivy-yank-word= and
how to fix them. Now we can easily search for the word at point using =swiper=.
#+BEGIN_SRC emacs-lisp
;; version of ivy-yank-word to yank from start of word
(defun bjm/ivy-yank-whole-word ()
  "Pull next word from buffer into search string."
  (interactive)
  (let (amend)
    (with-ivy-window
      ;;move to last word boundary
      (re-search-backward "\\b")
      (let ((pt (point))
            (le (line-end-position)))
        (forward-word 1)
        (if (> (point) le)
            (goto-char pt)
          (setq amend (buffer-substring-no-properties pt (point))))))
    (when amend
      (insert (replace-regexp-in-string "  +" " " amend)))))

;; bind it to M-j
(define-key ivy-minibuffer-map (kbd "M-j") 'bjm/ivy-yank-whole-word)
#+END_SRC
*** God Mode
In =god-mode=, all keypresses are interpreted as if preceded by =C-= (as in
"Control"). For example, the sequence =2 n x s= goes down two lines then saves the
buffer.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
 :commands (god-local-mode god-mode-all))
#+END_SRC
Easily enter God Mode.
#+BEGIN_SRC emacs-lisp
(after! key-chord
  (key-chord-define-global "jk" 'god-mode-all))
#+END_SRC
Indicate whether we're in God mode with the cursor colour. I've seen other
people do this by having a bar cursor in "insert mode" (to borrow some
terminology from Vim) and a block cursor in "command mode" (in our case, God
Mode).
#+BEGIN_SRC emacs-lisp
(defun gm/god-mode-indicator ()
  (cond (god-local-mode
         (set-cursor-color "#dc322f"))
        (t (set-cursor-color "#657b83"))))

(add-hook 'god-mode-enabled-hook #'gm/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'gm/god-mode-indicator)
#+END_SRC
*** PDF Tools
Basic configuration.
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :commands pdf-view-mode
  :config
  (setq pdf-annot-activate-created-annotations t)
  :diminish pdf-view-midnight-minor-mode
  :bind (:map pdf-view-mode-map
              ("C-s" . counsel-grep-or-swiper)
              ("h" . pdf-annot-add-highlight-markup-annotation)
              ("t" . pdf-annot-add-text-annotation)
              ("D". pdf-annot-delete)
              ("r" . pdf-view--rotate)
              ("n" . pdf-view-next-line-or-next-page)
              ("C-n" . pdf-view-next-page-command)
              ("p" . pdf-view-previous-line-or-previous-page)
              ("C-p" . pdf-view-previous-page-command))
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode)
  (pdf-view-mode . pdf-view-fit-width-to-window))
(eval-when-compile (pdf-tools-install))
#+END_SRC
Allow rotation.
#+BEGIN_SRC emacs-lisp
(defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  (interactive)
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!"))))))
#+END_SRC
*** Epub reading
We use =nov.el=.
#+BEGIN_SRC emacs-lisp
(use-package nov
  :commands (nov-mode)
  :init (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  :hook (nov-mode . gm/nov-font-setup))
#+END_SRC
Change default reading font from Source Sans Pro (my default variable pitch
font) to Minion Pro.
#+BEGIN_SRC emacs-lisp
(defun gm/nov-font-setup ()
  (face-remap-add-relative 'variable-pitch :family "Minion Pro"
                                           :height 2.0))
#+END_SRC
Justifying e-book text. This code was taken from [[https://github.com/wasamasa/nov.el][wasamasa/nov.el]].
#+BEGIN_SRC emacs-lisp
(require 'justify-kp)
(setq nov-text-width most-positive-fixnum)

(defun my-nov-window-configuration-change-hook ()
  (my-nov-post-html-render-hook)
  (remove-hook 'window-configuration-change-hook
               'my-nov-window-configuration-change-hook
               t))

(defun my-nov-post-html-render-hook ()
  (if (get-buffer-window)
      (let ((max-width (pj-line-width))
            buffer-read-only)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when (not (looking-at "^[[:space:]]*$"))
              (goto-char (line-end-position))
              (when (> (shr-pixel-column) max-width)
                (goto-char (line-beginning-position))
                (pj-justify)))
            (forward-line 1))))
    (add-hook 'window-configuration-change-hook
              'my-nov-window-configuration-change-hook
              nil t)))

(add-hook 'nov-post-html-render-hook 'my-nov-post-html-render-hook)
#+END_SRC
*** TeX
#+BEGIN_SRC emacs-lisp
(use-package auctex)
#+END_SRC
*** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.scss\\'" . web-mode)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Screencast
#+BEGIN_SRC emacs-lisp
(autoload 'gif-screencast "gif-screencast" "Start GIF Screencast" t)
(autoload 'keycast-mode "keycast" "Start `keycast-mode'" t)

(defun gm/begin-screencast ()
  (interactive)
  (gif-screencast)
  (unless (bound-and-true-p keycast-mode) (keycast-mode)))

(defun gm/end-screencast ()
  (interactive)
  (gif-screencast-stop)
  (when (bound-and-true-p keycast-mode) (keycast-mode)))

(bind-key "<f8>" #'gm/begin-screencast)
(bind-key "<f9>" #'gm/end-screencast)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package hydra
  :defer 2
  :config
  <<hydra>>)
#+END_SRC
*** Window Management
I don't like the default Emacs functionality of splitting windows but not
switching to the new window. I find myself pressing =M-3 C-x 0= pretty much every
time I split the window.
#+BEGIN_SRC emacs-lisp
(defun gm/split-window-below-and-switch ()
  (interactive)
  (split-window-below)
  (other-window 1))

(defun gm/split-window-right-and-switch ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC
To manage my windows. I use =ace-window=. The nice thing about this is that when
you use the equivalent of =other-window=, you don't have to remember which window
the "other one" is. Instead, you select the window with a number.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window
             delete-window
             delete-other-windows
             gm/split-window-right-and-switch
             gm/split-window-below-and-switch)
  :bind (("C-x o" . ace-window)
         ("C-x 0" . delete-window)
         ("M-1" . delete-other-windows)
         ("M-3" . gm/split-window-right-and-switch)
         ("M-4" . gm/split-window-below-and-switch)))
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind (("M-g" . avy-goto-word-1)))
#+END_SRC
Similarly, we use =ace-link= to open links quickly.
#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :config
  (ace-link-setup-default)
  :bind
  (:map org-mode-map
        ("M-o" . ace-link-org)))
#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp
(use-package company)
#+END_SRC
*** Which Key Mode
Helpful when you want to see completion for a certain sequence of prefix keys.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 10
  :diminish
  :config (which-key-mode))
#+END_SRC
*** Projectile
A neat package to perform operations with respect to the active "project,"
usually a git repo. The most useful function for me is =projectile-find-file=.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 5
  :config (use-package counsel-projectile :demand t))
#+END_SRC
I use a hydra to manage its many keybindings.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-projectile
  (:color teal :hint nil)
  "
  PROJECTILE: %(projectile-project-root)

  ^Find File^        ^Search/Tags^        ^Buffers^         ^Cache^                      ^Project^
  ^---------^        ^-----------^        ^-------^         ^-----^                      ^-------^
  _f_: file          _R_: grep            _i_: Ibuffer      _c_: cache clear             _p_: switch proj
  _F_: file dwim     _g_: update gtags    _b_: switch to    _x_: remove known project
  _C-f_: file pwd    _o_: multi-occur     _s-k_: Kill all   _X_: cleanup non-existing
  _r_: recent file   ^ ^                  ^ ^               _z_: cache current
  _d_: dir
"
  ("R"   counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   counsel-projectile-find-dir)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-dwim)
  ("C-f" projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("p"   projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("q"   nil "cancel" :color blue))

(bind-key "C-c p" #'hydra-projectile/body)
#+END_SRC
* Keybindings
** Better Defaults
These are what I think are better bindings for or better versions of the default
commands.
*** Easy M-x
Alt is simply too hard to hit for such a commonly used command.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" #'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above. And I know, I know, everyone
loves =transpose-chars=, but I don't see myself using it that much.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" 'set-mark-command)
#+END_SRC
*** Shell Kill Word
Use the standard Unix shell binding for deleting the previous word. As a result,
it's fine to remove the default Emacs bindings for this. In fact,
=C-<backspace>= in particular can get in the way.
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" 'backward-kill-word)
(unbind-key "C-<backspace>")
(unbind-key "M-DEL")
#+END_SRC
*** Kill Paragraph
This binding takes after the default =M-k= binding for =kill-sentence=.
#+BEGIN_SRC emacs-lisp
(bind-key "M-K" #'kill-paragraph)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring
  :bind ("M-y" . browse-kill-ring)
  :config (browse-kill-ring-default-keybindings))
#+END_SRC
*** Unfill Paragraph
I used to =[remap fill-paragraph]= to =gm/fill-unfill=, a function that used the
=unfill= package to toggle the paragraph from filled to unfilled with a single
key. It turned out this was not best for my use case, as I usually double-tapped
=M-q= because I just wanted to refill the paragraph. However, unfilling is
sometimes useful, so I kept the package around.
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands unfill-paragraph
  :bind ("M-Q" . unfill-paragraph))
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(bind-key "M-j" (lambda! (join-line -1)))
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Narrowing
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim]].
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(bind-key "n" #'narrow-or-widen-dwim ctl-x-map)
#+END_SRC
Then we can use =narrow-or-widen-dwim= to easily edit org =src= blocks.
#+BEGIN_SRC emacs-lisp
(after! org-src
  (bind-key "C-x C-s" #'org-edit-src-exit org-src-mode-map))
#+END_SRC
*** Delete Better
When using =C-d= or =Backspace=, delete all white space in a certain direction, and
not just one.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :commands hungry-delete-mode
  :hook (text-mode . hungry-delete-mode))
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))

(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" #'delete-current-buffer-file)
#+END_SRC
Rename better (from Magnar Sveen).
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file." name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" #'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x b" #'ivy-switch-buffer)
#+END_SRC
Use =ibuffer=.
#+BEGIN_SRC emacs-lisp
(autoload 'ibuffer "ibuffer" "List buffers." t)
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
*** Delete Frame
The default =C-x 5 0= is too clunky for this.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x w" #'delete-frame)
#+END_SRC
*** Comment Dwim
Pretty straightforward. A better version of the built-in =comment-dwim= from
[[https://github.com/remyferre/comment-dwim-2][remyferre/comment-dwim-2]].
#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :commands comment-dwim-2
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC
** Open Shell
I have started to use =eshell= as my primary shell. However, I sometimes want to
use my default =zsh= shell, which I access with =deepin-terminal= as a frontend.
This command ensures that =eshell= is opened next to, not instead of, my current
buffer.
#+BEGIN_SRC emacs-lisp
(defun eshell-other-window ()
  "Open a `eshell' in a new window."
  (interactive)
  (let ((buf (eshell)))
    (switch-to-buffer (other-buffer buf))
    (switch-to-buffer-other-window buf)))
#+END_SRC
I rebind the redundant help binding (there is already a more convenient prefix
map at =C-h=). I would use =C-M-t= to open a normal terminal, rebinding the Deepin
default, but I'm not sure how to make this Emacs command override the system
default.
#+BEGIN_SRC emacs-lisp
(bind-key "<f1>" #'eshell-other-window)
(bind-key "C-M-s" (lambda! (shell-command "deepin-terminal")))
#+END_SRC
** Find Inbox
#+BEGIN_SRC emacs-lisp
(bind-key "C-c o" (lambda! (find-file "~/org/inbox.org")))
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols. The dollar sign ($) keychord is
especially useful when typing LaTeX.
#+BEGIN_SRC emacs-lisp
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
#+END_SRC
** Toggles
We use a hydra to toggle various features in our setup.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-toggle (:color pink)
  "
_t_ theme-colour       %`gm/theme
_m_ quick-math-mode:   %`quick-math-mode
_p_ equation-preview:  %`gm/eq-preview
_e_ pretty-math:
_D_ dubcaps-mode:      %`gm/dubcaps-mode

"
  ("t" gm/switch-theme nil)
  ("m" quick-math-mode nil)
  ("p" gm/toggle-equation-preview nil)
  ("e" gm/prettify-math nil)
  ("D" gm/dubcaps-mode nil)
  ("q" nil "cancel"))

(bind-key "C-c t" #'hydra-toggle/body)
#+END_SRC
* Org Mode
We have to require the entire =org.el= file to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package org
  :init
  (require 'org)
  (require 'ox-latex)
  (require 'ox-hugo)
  :bind (:map org-mode-map
              <<org-keys>>)
  :config
  <<org-settings>>)
#+END_SRC
** Configuration
*** Invisible Edits
When text is entered near a hidden area (...), it is hard to see what is
changed.
#+BEGIN_SRC emacs-lisp :noweb-ref org-settings
(setq org-catch-invisible-edits 'show-and-error)
#+END_SRC
*** Better Return Behaviour
A better return for Org mode. If in a list, we want to add a new item.
If we're in a heading, we want to go the end of the line, then return. This is
because I never want to split the heading in half. If we're in a table, we add a
new row. If we are in a source block, we want to indent. Inspired by [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][John Kitchin]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun gm/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond
     ((eq 'link (car (org-element-context)))
      (org-return))
     ((and (org-in-item-p) (not (bolp)))
      (if (org-element-property :contents-begin (org-element-context))
          (org-insert-item)
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     ((org-at-heading-p)
      (end-of-line)
      (org-return))
     ((org-at-table-p)
      (if (-any?
           (lambda (x) (not (string= "" x)))
           (nth
            (- (org-table-current-dline) 1)
            (org-table-to-lisp)))
          (org-return)
        ;; empty row
        (beginning-of-line)
        (setf (buffer-substring
               (line-beginning-position) (line-end-position)) "")
        (org-return)))
     ((org-in-src-block-p)
      (newline-and-indent))
     (t
      (org-return)))))
#+END_SRC
We replace the normal return.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("RET" . #'gm/org-return)
("C-RET" . #'org-return)
#+END_SRC
*** File Locations
We need a place where Org files go by default. Org Mode uses this to, for
example, decide where to put the result of an Org Capture.
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/")
#+END_SRC
We similarly decide other default locations.
#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file (expand-file-name "inbox.org" org-directory)
      org-agenda-files `(,(expand-file-name "inbox.org" org-directory)
                         ,(expand-file-name "todo.org" org-directory)
                         ,(expand-file-name "notes.org" org-directory)
                         ,(expand-file-name "gcal.org" org-directory)))
#+END_SRC
Keeping my refile locations minimal makes refiling faster; besides, my primary
use case for refiling is to stow something away in its proper place for later
use. and we just set our "proper places."
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets `((,(expand-file-name "todo.org" org-directory) :maxlevel . 3)
                           (,(expand-file-name "notes.org" org-directory) :maxlevel . 3)))
#+END_SRC
*** Archival
[[https://orgmode.org/worg/org-hacks.html#org0344577][Worg]] gives a way to avoid messing up the heading hierarchy of an archive file
after archiving lower level items.
#+BEGIN_SRC emacs-lisp
(defun gm/org-inherited-no-file-tags ()
  (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
        (ltags (org-entry-get nil "TAGS")))
    (mapc (lambda (tag)
            (setq tags
                  (replace-regexp-in-string (concat tag ":") "" tags)))
          (append org-file-tags (when ltags (split-string ltags ":" t))))
    (if (string= ":" tags) nil tags)))

(defadvice org-archive-subtree (around my-org-archive-subtree-low-level activate)
  (let ((tags (gm/org-inherited-no-file-tags))
        (org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it
    (with-current-buffer (find-file-noselect (org-extract-archive-file))
      (save-excursion
        (while (org-up-heading-safe))
        (org-set-tags-to tags)))))
#+END_SRC
*** Capture
:PROPERTIES:
:ORDERED:  t
:END:
Org Capture is one of the best features of Org Mode. I use it to organize my
todo list, take note of ideas I think of, and kickstart blog posts.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" #'org-capture)
#+END_SRC
Here are my capture templates.
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-settings
(setq org-capture-templates
      `(("a" "Appointment" entry
         (file ,(expand-file-name "gcal.org" org-directory))
         "* %i%? \n%^T\n")
        ("t" "Todo" entry
         (file org-default-notes-file)
         "* TODO %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("n" "Note" entry
         (file org-default-notes-file)
         "* %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("j" "Journal" entry
         (file+olp+datetree ,(expand-file-name "journal.org" org-directory))
         "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
        ("e" "euler" entry
         (file+headline "~/website/content-org/blog.org" "Euler")
         "** Project Euler %^{Problem Number}: %^{Problem Name} %^g
:PROPERTIES:
:EXPORT_FILE_NAME: %\\1
:EXPORT_DATE: %u
:EXPORT_DESCRIPTION: My solution to problem %\\1 of Project Euler.
:END:\n*** Problem Statement\n%?\n*** My Algorithm")))
#+END_SRC
The two applications I spend the most time in are Emacs and Firefox. It would be
very nice if I could use Org Capture from within the web browser. In particular,
I want to be able to rely on the functionality of Org Mode to manage my
bookmarks (see [[https://karl-voit.at/2014/08/10/bookmarks-with-orgmode/][Karl Volt's method]]), rather than rely on Firefox. Also, I often
come across quotes or excerpts that I'd love to file away for later. The
built-in =org-protocol= lets us intercept calls to =emacsclient= from a web browser
and apply functions to it, like =org-capture=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol)
#+END_SRC
However, this only lets us manipulate the selection in the browser as plain
text. Pretty much every browser has the ability to copy text as HTML. So we
leverage the power of =pandoc= to convert this HTML to Org Mode syntax using some
code by [[https://github.com/alphapapa/org-protocol-capture-html][alphapapa]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol-capture-html)
#+END_SRC
So how do we actually get data from Firefox to Emacs? You can read the [[https://orgmode.org/worg/org-contrib/org-protocol.html][Org Mode
wiki]] for the basics.

The meat of the following snippet is in the function that turns the browser
selection into HTML (after =&body==). It was sourced from [[https://stackoverflow.com/questions/5643635/how-to-get-selected-html-text-with-javascript/6668159#6668159][StackOverflow]].
#+BEGIN_SRC js :tangle no
javascript:location.href = 'org-protocol://capture-html?template=p&url=' + encodeURIComponent(location.href) + '&title=' + encodeURIComponent(document.title || "[untitled page]") + '&body=' + encodeURIComponent(function () {var html = ""; if (typeof document.getSelection != "undefined") {var sel = document.getSelection(); if (sel.rangeCount) {var container = document.createElement("div"); for (var i = 0, len = sel.rangeCount; i < len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != "undefined") {if (document.selection.type == "Text") {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement("a"); a.href = href; var abs = a.protocol + "//" + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [['a', 'href'], ['img', 'src']]; var div = document.createElement('div'); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i < elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}());
#+END_SRC
A convenient way to activate this from Firefox is to use the extension
[[https://github.com/mikecrittenden/shortkeys][ShortKeys]]. With it, I bind the above to =c b=, for "capture bookmark." One thing to
note is that the user interface for this extension, at least on Firefox, kinda
sucks. You have to scroll horizontally to save your keybindings, and it took me
a while to figure that out. I've also set up many other bindings, like =n= and =p=
for next and previous tab, but that's another story.

We send the data from =org-protocol= into the following template.
#+BEGIN_SRC emacs-lisp
(push
 '("p" "Org Protocol" entry
   (file org-default-notes-file)
   "* [[%:link][%(gm/square-to-round-brackets \"%:description\")]]\n:PROPERTIES:\n:CREATED: %U\n:END:\n%?\n%(gm/quote-if-non-empty \"%i\")")
 org-capture-templates)
#+END_SRC
Because Org links are constructed with square brackets, any URL whose title
contains square brackets (I'm looking at you, arXiv) would break a normal
implementation of the this template. Our workaround is to change square brackets
to round ones.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun gm/square-to-round-brackets (s)
  "Transform [ into ( and ] into ), other chars left unchanged."
  (->> s
      (replace-regexp-in-string "\\[" "\(")
      (replace-regexp-in-string "\\]" "\)")))
#+END_SRC
Also, I want to wrap the excerpt in an Org quote block, but not if there is no
excerpt.
#+BEGIN_SRC emacs-lisp
(defun gm/quote-if-non-empty (str)
  (unless (or (string-blank-p str)
              ; dont quote things with headings or org blocks
              (string-match "^\\(\*+\\)\\|\\(#\+BEGIN\_\\)" str))
    (setq str (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" (s-trim str))))
  (s-trim str))
#+END_SRC
I also bind =c l= to store the URL of the current page as an Org link.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://store-link:?url='+encodeURIComponent(location.href)
#+END_SRC
Finally, I have a general purpose binding on =c n= for capturing any notes or
thoughts that come to me while browsing.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://capture?template=n'
#+END_SRC
*** Org Download
Now we can easily move images into Org Mode buffers.
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :commands (org-download-yank)
  :custom
  (org-download-method 'attach)
  (org-download-timestamp t))
#+END_SRC
**** Add Images to Notes Live
[[http://pragmaticemacs.com/emacs/a-workflow-to-quickly-add-photos-to-org-mode-notes/][This article]] gives a neat way to add images taken from your phone into an Org
Mode buffer. This could be useful if you are taking notes in a class or
conference and want to reference a slide or diagram on the board.

I use Syncthing to get photos from my phone to my computer, but any syncing
service works, like Google Drive or Dropbox.
#+BEGIN_SRC emacs-lisp
(defvar gm/live-image-dir (expand-file-name "~/Camera/Camera"))
#+END_SRC
We use =ivy= to prompt the user for a file from the camera roll, sorted by most
recent. Then, we attach the file to the current subtree by /copying/ it, add an
image link, and display it. Because most images taken this way are vertical, I
rotate the image first to make sure it displays correctly.
#+BEGIN_SRC emacs-lisp
(defun gm/insert-live-image ()
  (interactive)
  (let (file-list file-list-sorted start-file start-file-full end-file)
    (setq file-list
          (-remove (lambda (x) (nth 1 x))
                   (directory-files-and-attributes gm/live-image-dir)))
    (setq file-list-sorted
          (mapcar #'car
                  (sort file-list
                        #'(lambda (x y) (time-less-p (nth 6 y) (nth 6 x))))))
    (setq start-file (ivy-read
                      "Select file to attach:"
                      file-list-sorted
                      :re-builder #'ivy--regex
                      :sort nil
                      :initial-input nil))
    (setq start-file-full
          (expand-file-name start-file gm/live-image-dir))
    (org-attach-attach start-file-full nil 'cp)
    (message "Attached %s" start-file-full)
    (setq end-file (expand-file-name start-file (org-attach-dir nil)))
    (call-process "convert" nil nil nil end-file "-rotate" "-90" end-file)
    (insert (org-make-link-string (format "file:%s" end-file)))
    (org-display-inline-images t t)))
#+END_SRC
*** Todo Lists and Agenda
I like the following set of =TODO= words. This is what appears
before an Org headline when a todo state is activated.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t!)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC
Automatically archive cancelled tasks.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-state-tags-triggers '(("CANCELLED" ("ARCHIVE" . t))))
#+END_SRC
Track the time when a TODO item is marked DONE.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-log-done 'time)
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
If all the checkboxes in a list are checked, the parent heading is done, and its
TODO state should be marked as such.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    ;; all done - do the state change
                    (org-todo 'done)
                  (org-todo 'todo))
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (org-todo 'done)
                (org-todo 'todo)))))))
#+END_SRC
The default is =week=, which gives the current week (starting on Monday by
default). I prefer to see a larger view.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 14)
#+END_SRC
*** Google Calendar
I manage deadlines with Org Agenda.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c a" #'org-agenda)
#+END_SRC
However, that's not quite enough, because when I'm out and about, I want whatever
I have in my Org Agenda to be able to alert me on my phone. I also want to be
able to enter new events on the go. The best solution I've found for this is to
integrate Org Mode with Google Calendar. The setup is contained in the file for
my personal settings, =private.el=.
#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :after org
  :commands org-gcal-sync
  :init (setq package-check-signature nil)
  :custom (org-gcal-dir gmacs-cache-dir)
  :hook (org-agenda-mode . org-gcal-sync))
#+END_SRC
*** Links
I often use links to easily navigate to a relevant file in cases where I would
rather not use =org-attach=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c l" . org-store-link)
#+END_SRC
Follow links using return rather than =C-c C-o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-return-follows-link t)
#+END_SRC
I can use =org-cliplink= to paste in a website's URL with the link's description
being the title of that website.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-cliplink
  :commands org-cliplink
  :bind (:map org-mode-map ("C-c y" . org-cliplink)))
#+END_SRC
*** Word Count
It's very useful to be able to see the word count of a subtree when I am writing
a paper for school.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-wc
  :commands org-wc-display
  :bind (:map org-mode-map ("C-c w" . gm/wc-display-current-subtree)))
#+END_SRC
I narrow to subtree by default because displaying the count for every subtree in
the file is (usually) unnecessary and (always) too slow.
#+BEGIN_SRC emacs-lisp
(defun gm/wc-display-current-subtree (arg)
  (interactive "P")
  (if arg
      (org-wc-display nil)
    (save-restriction
      (org-narrow-to-subtree)
      (org-wc-display nil))))
#+END_SRC
*** Org Ref
A wonderfully featured framework for maintaining bibliographies and writing
academic papers in Org Mode by Org-guru John Kitchin.
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :custom
  (org-ref-completion-library 'org-ref-ivy-cite)
  (org-ref-default-citation-link "footcite")
  (bibtex-dialect 'biblatex)
  :bind (:map bibtex-mode-map
              ("C-c b" . org-ref-bibtex-new-entry/body)))
#+END_SRC
** Prettifying
*** Headlines
Let's make our headings look a bit nicer. The package =org-bullet-mode= replaces the
asterisks that define an Org heading with pretty symbols, like stylized bullet
points.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-bullets
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))
#+END_SRC
In a similar vein, it helps the visual hierarchy to have text indented in
accordance with the level of the heading, so I always use =org-indent-mode=.
Because it's always active, it's best to diminish it.
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(diminish 'org-indent-mode)
#+END_SRC
The dot-dot-dot ellipsis that indicates hidden content can become a bit much
when you have a lot of headlines.
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⬎")
#+END_SRC
*** Emphasis Markers
It looks much cleaner if we omit emphasis markers such as the =*= asterisks that
make something bold. It is enough to just display the argument as bold.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Lists
Have lists begun by, for example, =-= look like a bullet list.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
This doesn't change anything in the buffer, which is nice.

*** Pretty Symbols in Source Blocks
I do a lot of programming in Org Mode source blocks, and I want to have features
like =prettify-symbols-mode= for =lambda= functions in Elisp. However, this mode is
buffer local, so if I were to turn it on, I would have to display the string
"lambda" as "λ" throughout the buffer, even in paragraphs and the source blocks
of other languages. This is obviously undesirable.

We add hooks to particular languages to activate pretty symbols. In this case I
don't add the lambda fontification, just activate =pretty-symbols-mode=, because
the default variable =lisp-prettify-symbols-mode= already has this pair.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq prettify-symbols-alist
                  '(("lambda" . ?λ)
                    ("lambda!" . (?λ (Br . Bl) ?!))))
            (prettify-symbols-mode)))
#+END_SRC
Then, we modify =org-src-font-lock-fontify-block= (the function that fontifies Org
source blocks) as per [[https://emacs.stackexchange.com/questions/17283/is-it-possible-to-get-prettified-symbols-in-org-mode-source-blocks/17847][this SE post]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun org-src-font-lock-fontify-block (lang start end)
  "Fontify code block.
This function is called by emacs automatic fontification, as long
as `org-src-fontify-natively' is non-nil."
  (let ((lang-mode (org-src--get-lang-mode lang)))
    (when (fboundp lang-mode)
      (let ((string (buffer-substring-no-properties start end))
        (modified (buffer-modified-p)) (org-buffer (current-buffer)) pos next)
    (remove-text-properties start end '(face nil))
    (with-current-buffer
        (get-buffer-create
         (concat " org-src-fontification:" (symbol-name lang-mode)))
      (delete-region (point-min) (point-max))
      (insert string " ") ;; so there's a final property change
      (unless (eq major-mode lang-mode) (funcall lang-mode))
      ;; Avoid `font-lock-ensure', which does not display fonts in
      ;; source block.
      (call-interactively #'font-lock-fontify-buffer)
      (setq pos (point-min))
      (while (setq next (next-single-property-change pos 'face))
        (put-text-property
         (+ start (1- pos)) (1- (+ start next)) 'face
         (get-text-property pos 'face) org-buffer)
        (setq pos next))
      ;; Addition: also copy 'composition info for prettified symbols
      (setq pos (point-min))
      (while (setq next (next-single-property-change pos 'composition))
        (put-text-property
         (+ start (1- pos)) (1- (+ start next)) 'composition
         (get-text-property pos 'composition) org-buffer)
        (setq pos next))
      ;; End addition
      )
    (add-text-properties
     start end
     '(font-lock-fontified t fontified t font-lock-multiline t))
    (set-buffer-modified-p modified)))))
#+END_SRC
** Babel
Set up languages loaded for use in Org source blocks and their respective
default execution commands.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(org-babel-do-load-languages
      'org-babel-load-languages '((python . t)
                                  (latex . t)
                                  (shell . t)))

(setq org-babel-python-command "python3.6"
      org-babel-latex-command "pdflatex")
#+END_SRC
Make Org Mode source blocks act normally with respect to indentation and syntax
highlighting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC
I'm generally fine with just evaluating a code block.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Proper Keymaps in Org Source Blocks
[[http://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/][John Kitchin]] explains how to get use keybindings from the appropriate language
major mode inside Org source blocks. This heavily reduces the need to activate
special edit mode with =C-c '=. The idea is that we set up keymaps and apply them
with font-lock by hooking into Org Mode's font-lock. We define the function that
applies the keymap to each block.
#+BEGIN_SRC emacs-lisp
(defun gm/add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `gm/src-block-keymaps'."
  (let ((case-fold-search t))
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) gm/src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          gm/src-block-keymaps))))))))))
#+END_SRC
To be able to toggle this, we add a minor mode. This is where we add the
relevant hook.
#+BEGIN_SRC emacs-lisp
(define-minor-mode gm/src-keymap-mode
  "Minor mode to add mode keymaps to src-blocks."
  :init-value nil
  (if gm/src-keymap-mode
      (progn
        (require 'elpy)
        (add-hook 'org-font-lock-hook #'gm/add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map))
    (remove-hook 'org-font-lock-hook #'gm/add-keymap-to-src-blocks)
    (cursor-sensor-mode -1))
  (call-interactively #'font-lock-fontify-buffer))
#+END_SRC
Here are the actual maps.
#+BEGIN_SRC emacs-lisp
(defvar gm/src-block-keymaps
      `(("python" . ,(let ((map (make-composed-keymap
                                 `(,(when (boundp 'elpy-mode)
                                      elpy-mode-map)
                                   ,(when (boundp 'python-mode)
                                      python-mode-map))
                                 org-mode-map)))
                       ;; In org-mode I define RET so we redefine
                       (define-key map (kbd "RET") 'newline-and-indent)
                       (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                       map))
        ("emacs-lisp" . ,(let ((map (make-composed-keymap
                                     `(,emacs-lisp-mode-map)
                                     org-mode-map)))
                           (define-key map (kbd "RET") 'newline-and-indent)
                           (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                           map))))
#+END_SRC
** LaTeX
Highlight LateX inline math in org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-highlight-latex-and-related '(latex))
#+END_SRC
*** Math Mode
Define a keychord to enter inline math mode. This allows me to get around
messing with making =$= an electrically paired delimiter.
#+BEGIN_SRC emacs-lisp
(key-chord-define org-mode-map "r4" #'gm/create-or-exit-math-fragment)
#+END_SRC
**** Pretty Math Symbols
I got the source for this from [[https://bitbucket.org/mortiferus/latex-pretty-symbols.el][mortiferus]]. The file I use is not the one from
their Bitbucket repo; I have, for example, removed subscripts and superscripts.
#+BEGIN_SRC emacs-lisp
(autoload 'gm/prettify-math "gm-pretty-math")
#+END_SRC
*** Don't Break Paragraph on Comments'
[[https://emacs.stackexchange.com/questions/22574/orgmode-export-how-to-prevent-a-new-line-for-comment-lines][John Kitchin]] tells us how to remove comments from an Org document when exporting
to LaTeX.
#+BEGIN_SRC emacs-lisp
(defun delete-org-comments (backend)
  (loop for comment in (reverse (org-element-map (org-element-parse-buffer)
                                    'comment 'identity))
        do (setf (buffer-substring (org-element-property :begin comment)
                                (org-element-property :end comment))
              "")))
(add-hook 'org-export-before-processing-hook 'delete-org-comments)
#+END_SRC
*** Reformat Math Fragment
For my primary use case of typing math in LaTeX, I don't care about how the
source looks when I'm typing it; I'm often typing it live, so the main concern
is speed. But later, I want it to look nice and readable, with spacing and so
on.

The idea is pretty simple. We just maintain a list of regexps in
=gm/reformat-fragment-alist= and run them all on a given LaTeX fragment with
=gm/reformat-fragment=. The main thing to notice is that the regexp that takes
care of too many spaces goes last. This way, we don't have to worry about
introducing too many spaces in the earlier regexps.
#+BEGIN_SRC emacs-lisp
(defcustom gm/reformat-fragment-alist
  '(("+" " + " "spaces around +")
    ("[ ]*\\([_^]\\)[ ]*" "\\1" "remove spaces around ^ and _")
    (" +" " " "no more than 1 space in a row")
    ("\\(\\\\(\\) " "\\1" "no space at start of fragment")
    (" \\(\\\\)\\)" "\\1" "no space at end of fragment"))
  "Alist of (REGEXP TO DOCSTRING) parsed by `gm/reformat-fragment'.
Upon reformatting, each REGEXP is replaced with TO. DOCSTRING
simply explains what the regexp does.")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun gm/reformat-fragment (&optional fr)
  (let ((fr-type (car (if fr fr (org-element-context))))
        (fr-begin (if fr
                      (nth 1 fr)
                    (org-element-property :begin (org-element-context))))
        fr-end base)
    (goto-char fr-begin)
    (setq fr-end (- (org-element-property :end (org-element-context))
                    (org-element-property :post-blank (org-element-context))))
    (setq base (buffer-substring-no-properties fr-begin fr-end))
    (dolist (reg gm/reformat-fragment-alist)
      (setq base (replace-regexp-in-string (car reg) (nth 1 reg) base)))
    (delete-region fr-begin fr-end)
    (insert base)
    (when (and (eq fr-type 'latex-environment)
               (eq (char-before) (string-to-char "}")))
      (newline))))
#+END_SRC
*** Equation Auto Preview
:PROPERTIES:
:ORDERED:  t
:END:
Not too small.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.75))
#+END_SRC
Where should it be? Let's put them all in the same place, so that common
fragments (like =x^2=) are never generated more than once and so that we don't
litter our folders.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-preview-latex-image-directory
      (expand-file-name "cache/ltximg/" gmacs-emacs-dir))
#+END_SRC
Inspired by John Kitchin. I've modified it to be toggleable and to run a hook on
leaving a math fragment.
#+BEGIN_SRC emacs-lisp
(require 'ov)
(defvar gm/org-last-fragment nil
  "Holds the type and position of last valid fragment we were on.
  Format: (FRAGMENT_TYPE FRAGMENT_POINT_BEGIN)")

(defvar gm/org-valid-fragment-type '(latex-fragment latex-environment)
  "List of types of fragments that will be previewed by `gm/org-preview-fragment'")

(defun gm/org-curr-fragment ()
  "Returns the type and position of the current fragment available
for preview inside org-mode. Returns nil at non-displayable fragments."
  (let* ((fr (org-element-context))
         (fr-type (car fr)))
    (when (memq fr-type gm/org-valid-fragment-type)
      ;; \(...\)| cursor there should not result in active fragment
      (let ( ; we only define these things now to optimize
            (fr-begin (org-element-property :begin fr))
            (fr-end (org-element-property :end fr))
            ;; add one for the space after in \end{equation}
            (fr-post-blank (1+ (org-element-property :post-blank fr))))
        (when
            ;; gotta fix some weird behaviour with environments
            ;; make sure that if you're on the line after
            ;; \end{equation}, you're considered out of the fragment
            ;; check if point is between the actual end of the
            ;; LaTex environment and the "supposed end" extended by blank ;; lines after the environment
            (and
             (>= (point) fr-begin)
             (<= (point) (- fr-end fr-post-blank)))
          (list fr-type fr-begin ))))))

(defun gm/org-remove-fragment-overlay (fr)
  "Remove fragment overlay at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (goto-char fr-begin)
    (when (memq fr-type gm/org-valid-fragment-type)
      (let ((ov (car (--filter
                      (and
                       (<= (overlay-start it) (point))
                       (>= (overlay-end it) (point)))
                      (org--list-latex-overlays)))))
        (when ov
          (delete-overlay ov))))))

(defun gm/org-preview-fragment (fr)
  "Preview org fragment at fr"
  (let ((fr-type (nth 0 fr))
        (fr-begin (nth 1 fr)))
    (when (memq fr-type gm/org-valid-fragment-type)
      (goto-char fr-begin)
      (org-toggle-latex-fragment))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun gm/org-auto-toggle-fragment-display ()
  "Automatically toggle a displayable org mode fragment."
  (and (eq 'org-mode major-mode)
       (let ((curr (gm/org-curr-fragment)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            gm/org-last-fragment
            ;; and are on a fragment now
            curr
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (equal curr gm/org-last-fragment)))
           ;; go back to last one and put image back, provided there is still a fragment there
           (save-excursion
             (gm/org-preview-fragment gm/org-last-fragment)
             ;; now remove current image
             (gm/org-remove-fragment-overlay curr))

           ;; and save new fragment
           (setq gm/org-last-fragment curr))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not curr)
            ;; but we were on one
            gm/org-last-fragment)

           ;; put image back on, provided that there is still a fragment here.
           (save-excursion
             (gm/org-preview-fragment gm/org-last-fragment))
           ;; unset last fragment
           (setq gm/org-last-fragment nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not gm/org-last-fragment)
            ;; but now we are
            curr)
           ;; remove image
           (save-excursion
             (gm/org-remove-fragment-overlay curr)
             (setq gm/org-last-fragment curr))
           ;; there is no point being in on the \( or \) part of the math fragment
           ;; this code jumps the point into the actual math part of the fragment
           (cond
            ((equal (gm/last-n-chars -2) "\\(")
             (forward-char 2))
            ((and (eq (char-before) 92)
                  (eq (char-after) 41))
             (backward-char 1))))))))
#+END_SRC
We can also center equations and (this is useful when equation preview mode is
disabled) add a tooltip to them that lets you edit the equation when you click
on it. This is more John Kitchin code.
#+BEGIN_SRC emacs-lisp
(defun org-justify-fragment-overlay (beg end image imagetype)
  "Adjust the justification of a LaTeX fragment.
The justification is set by :justify in
`org-format-latex-options'. Only equations at the beginning of a
line are justified."
  (when
   ;; Centered justification
   (and (= beg (line-beginning-position))
         (string= "\\begin"
                  (buffer-substring-no-properties
                   beg (+ beg 6))))
    (let* ((img (create-image image 'png t))
           (width (car (image-size img)))
           (offset (floor (- (/ (min (window-max-chars-per-line) fill-column) 3) (/ width 3)))))
      (overlay-put (ov-at) 'before-string (make-string offset ? )))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun org-latex-fragment-tooltip (beg end image imagetype)
  "Add the fragment tooltip to the overlay and set click function to toggle it."
  (overlay-put (ov-at) 'help-echo
               (concat (buffer-substring beg end)
                       "\nmouse-1 to toggle."))
  (overlay-put (ov-at) 'local-map (let ((map (make-sparse-keymap)))
                                    (define-key map [mouse-1]
                                      `())
                                    map)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(advice-add 'org--format-latex-make-overlay :after 'org-justify-fragment-overlay)
(advice-add 'org--format-latex-make-overlay :after 'org-latex-fragment-tooltip)
#+END_SRC
Toggle the "mode" to preview equations. The keybinding is setup in [[*Hydra][the section
on hydras]].
#+BEGIN_SRC emacs-lisp
(defvar gm/eq-preview nil)
;; this is buffer local
(defun gm/toggle-equation-preview ()
  (interactive)
  (if gm/eq-preview
      (progn
        (remove-hook 'post-command-hook 'gm/org-auto-toggle-fragment-display t)
        (message "Equation preview disabled."))
    (add-hook 'post-command-hook 'gm/org-auto-toggle-fragment-display nil t)
    (message "Equation preview enabled."))
  (setq-local gm/eq-preview (not gm/eq-preview)))
#+END_SRC
*** Export
#+BEGIN_SRC emacs-lisp
(defun gm/org-latex-export ()
  (interactive)
  (require 'ox-tufte-latex)
  (save-excursion
    (search-backward "EXPORT_FILE_NAME")
    (org-latex-export-to-latex t t)))
#+END_SRC
Bind this in Org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c b" . gm/org-latex-export)
#+END_SRC
Don't use straight quotes when exporting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-export-with-smart-quotes t)
#+END_SRC
**** Math Macros
I have a LaTeX =.sty= file with macros for math. I want this to be automatically
included in every LaTeX file exported from Org Mode. The optional third argument
makes sure this package is also loaded when compiling LaTeX image previews, such
as equation previews.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-latex-packages-alist
      '(("" "gm-math" t)))
#+END_SRC
**** Latexmk
The command =gm/auto-tex-cmd= looks at your Org file. If it finds that =xelatex= has
been specified as the desired compilation command, then it uses that. Otherwise,
it runs =latexmk= with normal =pdflatex=. We don't need to worry about compiling the
correct number of times to include bibliography information, or to render
graphics correctly; =latexmk= handles all of that.
#+BEGIN_SRC emacs-lisp
(defun gm/auto-tex-cmd ()
  (let ((texcmd))
    (setq texcmd "latexmk -pdf -quiet %f")
    (if (string-match "LATEX_CMD: xelatex" (buffer-string))
        (setq texcmd "latexmk -pdflatex=xelatex -pdf -quiet %f"))
    (setq org-latex-to-pdf-process (list texcmd))))

(add-hook 'org-export-latex-after-initial-vars-hook 'gm/auto-tex-cmd)
#+END_SRC
**** Command Links
***** No Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\%s{%s}" path desc))))
#+END_SRC
***** One Option
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s%s{%s}" path
                       (if (equal "" opt) opt (format "[%s]" opt))
                       arg)))))
#+END_SRC
***** One Option (After Main)
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt-after"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s{%s}%s" path arg
                       (if (equal "" opt) opt (format "[%s]" opt)))))))
#+END_SRC
***** Todo Link
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "todo"
 :follow nil
 :face '(:foreground "red" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\marginnote{\\textcolor{red}{\\textbf{TODO:}} %s}" path))))
#+END_SRC
**** Use Cleveref
by default, Org Mode exports references to LaTeX with =\ref=. I prefer using the
=cleveref= package, which uses the =\cref= macro.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "ref"
                         :export
                         (lambda (label desc format)
                           (format "\\cref{%s}" label)))
#+END_SRC
**** Export Classes
***** Tufte-LaTeX
****** Class Options
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("tufte-handout"
               "\\documentclass{tufte-handout}
   [NO-DEFAULT-PACKAGES]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")))
#+END_SRC
***** Assignment
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("assignment"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-assignment}
\\renewcommand{\\maketitle}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
***** MLA
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-mla"
                 "\\documentclass[12pt]{article}
\\usepackage{uts-mla}
\\renewcommand{\\maketitle}{}
\\renewcommand{\\tableofcontents}{}
[NO-DEFAULT-PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubection*{%s}"))))
#+END_SRC
***** Notes
#+BEGIN_SRC emacs-lisp
(after! ox-latex (add-to-list 'org-latex-classes
               '("gm-notes"
                 "\\documentclass{gm-notes}
[NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC
We make this our default class.
#+BEGIN_SRC emacs-lisp
(setq org-latex-default-class "gm-notes")
#+END_SRC
* Media
Here I configure everything for recreation and contact with the outside world:
managing email, consuming published media (blog posts and YouTube videos), and
listening to music.
** Mail
I used to use =mu4e=, but now I use =notmuch=. It has greater synergy with =elfeed=,
my RSS reader (in fact, =elfeed= was inspired by =notmuch=). Also, I found that =mu4e=
was too complicated and tried to do too much. As the name suggests, =notmuch=
doesn't have much. It's simple, transparent, and it works. That makes it perfect
for me.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package notmuch
  :commands (notmuch)
  :config
  (require 'smtpmail)
  (require 'smtpmail-async)
  :custom
  (nms-settings-file (expand-file-name "network-security.data" gmacs-cache-dir))
  :config
  <<notmuch-settings>>)
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-directory "~/mail/"
      message-auto-save-directory "~/mail/draft"
      message-fcc-dirs "~/mail/mbsyncmail/Sent Items")
#+END_SRC
Provide my email and name.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq mail-user-agent 'message-user-agent
      user-mail-address gm--email
      user-full-name "Gautam Manohar")
#+END_SRC
SMTP for sending mail. The =stream-type= is important because I want my outgoing
mail to at least use TLS encryption. One day, though, I would like to adopt a
more rigorous system of encryption.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq send-mail-function #'async-smtpmail-send-it
      message-send-mail-function #'async-smtpmail-send-it
      smtpmail-debug-info t
      smtpmail-debug-verb t
      smtpmail-stream-type 'starttls
      smtpmail-smtp-server gm--send-mail-server
      smtpmail-smtp-service 587)
#+END_SRC
#+BEGIN_SRC emacs-lisp

#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:unread" :key "i" :sort-order oldest-first)
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s" :sort-order newest-first)
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a" :sort-order newest-first)))
#+END_SRC
Nice stuff to have for sending mail.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-kill-buffer-on-exit t
      notmuch-address-command 'internal)
#+END_SRC
Most modern mail clients expect mail to be soft-wrapped. That is, the paragraph
conforms to the width of the viewer the person reading the mail is using, not to
the sender's preference of 80 characters or whatever it may be. However, when
sending mail, I still want the buffer to look as if it was hard-wrapped. Enter
=visual-fill-column-mode=. This mode works with =visual-line-mode= to wrap the
paragraph not at the window edge but at =fill-column=.
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode
  :hook (notmuch-message-mode . visual-fill-column-mode)
  :config (advice-add 'text-scale-adjust :after
                      #'visual-fill-column-adjust)
  (add-hook 'notmuch-message-mode-hook (lambda () (auto-fill-mode -1))))
#+END_SRC
Accessing mail. When we first open up =notmuch=, I want to start a system script
that checks for new mail periodically.
#+BEGIN_SRC emacs-lisp
(defun gm/open-mail ()
  (interactive)
  (notmuch)
  (notmuch-refresh-this-buffer))

(bind-key "C-c m" #'gm/open-mail)
#+END_SRC
*** HTML Mail
This code from [[http://kitchingroup.cheme.cmu.edu/blog/category/orgmode/4/][John Kitchin]] lets you write mail in Org Mode and send it
formatted as HTML. This is incredibly powerful, because you can include syntax
highlighted code, LaTeX math images, and even the image output of Babel blocks,
all composed in plain text with Org Mode. Unfortunately, when I first set up
this process, I received an error when trying to send HTML mail with LaTeX math
in it (the desired =.png= was not produced and I had to adjust =imagemagick= as
apart of =org-preview-latex-process-alist=). Investigating the =.log= files showed
that the issue was not with =pdflatex= (and indeed a proper PDF was
produced). In fact, the issue was with ImageMagick, which did not have the
proper permissions to do its job on PDF files. Here's the fix:

Find =/etc/ImageMagick-7/policy.xml=. Change
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="none" pattern="PDF" />
#+END_SRC
to
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="read|write" pattern="PDF" />
#+END_SRC
Looking at the =rights= field makes it clear that the permissions were off.

Now for the Emacs setup. This library converts Org into HTML.
#+BEGIN_SRC emacs-lisp
(require 'org-mime)
#+END_SRC
Then we give ourselves a way to activate Org Mode mail.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun gm/compose-html-org ()
  (interactive)
  (setq *compose-html-org* t)
  (org-mode)
  (auto-fill-mode -1))

(bind-key "M-m" #'gm/compose-html-org notmuch-message-mode-map)
#+END_SRC
Let's define a function to send the mail.
#+BEGIN_SRC emacs-lisp
(defun gm/org-htmlize-and-send ()
  "When composing an Org HTML message, htmlize and send it."
  (interactive)
  (when (bound-and-true-p *compose-html-org*)
    (setq *compose-html-org* nil)
    (notmuch-message-mode)
    (org-mime-htmlize)
    (notmuch-mua-send-and-exit)))

(add-hook 'org-ctrl-c-ctrl-c-hook 'gm/org-htmlize-and-send t)
#+END_SRC
If we're sending HTML, we might as well make it pretty. Let's nicely offset
block quotes.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mime-html-hook
          (lambda ()
            (org-mime-change-element-style
             "blockquote" "border-left: 2px solid gray; padding-left: 4px;")))
#+END_SRC
We definitely don't want to export the table of contents or section numbers.
It's an email, not an essay.
#+BEGIN_SRC emacs-lisp
(setq org-mime-export-options '(:section-numbers nil
                                :with-author nil
                                :with-toc nil))
#+END_SRC
** Elfeed
Elfeed is a feed manager for Emacs. It lets me manage YouTube subscriptions and
other forms of media, such as blogs. I plan to also use it for academic articles
when the need arises. Many of the snippets (tagged =bjm/=) I use here was written
by the author of [[http://pragmaticemacs.com][Pragmatic Emacs]].
#+BEGIN_SRC emacs-lisp :noweb yes
(autoload 'elfeed "elfeed")
(autoload 'elfeed-db-load "elfeed")
(setq elfeed-db-directory "~/.emacs.d/.elfeed")
(after! elfeed
  (bind-keys :map elfeed-search-mode-map
             ("q" . bjm/elfeed-save-db-and-bury)
             ("f" . gm/elfeed-hydra/body)
             ("*" . gm/elfeed-toggle-star)
             ([remap elfeed-search-live-filter]
              . bjm/elfeed-search-live-filter-space))
  <<elfeed-settings>>)
#+END_SRC
By default, =elfeed= stores the feeds it should compile in an elisp file. But Org
is easier.
#+BEGIN_SRC emacs-lisp
(autoload 'elfeed-org "elfeed-org")
(elfeed-org)
(setq rmh-elfeed-org-files
      `(,(expand-file-name "elfeed.org" org-directory)))
#+END_SRC
*** Launching
We want to make sure =elfeed= reads from the disk before it launches. This makes
our =.elfeed= easier to synchronize across machines.
#+BEGIN_SRC emacs-lisp
(defun bjm/elfeed-load-db-and-open ()
  "Wrapper to load the elfeed db from disk before opening"
  (interactive)
  (elfeed-db-load)
  (elfeed)
  (elfeed-search-update--force))

(defun bjm/elfeed-save-db-and-bury ()
  "Wrapper to save the elfeed db to disk before burying buffer"
  (interactive)
  (elfeed-db-save)
  (quit-window))

(bind-key "C-c e" #'bjm/elfeed-load-db-and-open)
#+END_SRC
*** Improvements
It's nice to have a way to star content for future reference.
#+BEGIN_SRC emacs-lisp
(defun gm/elfeed-toggle-star ()
  (interactive)
  (elfeed-search-toggle-all 'starred))
#+END_SRC
Then we add a visual indicator.
#+BEGIN_SRC emacs-lisp
(defface elfeed-search-starred-title-face
  '((t :foreground "#f77"))
  "Marks a starred Elfeed entry.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
#+END_SRC
[[http://pragmaticemacs.com/emacs/a-tweak-to-elfeed-filtering/][Life is too short to type extra spaces.]]
#+BEGIN_SRC emacs-lisp
(defun bjm/elfeed-search-live-filter-space ()
  "Insert space when running elfeed filter"
  (interactive)
  (let ((elfeed-search-filter (concat elfeed-search-filter " ")))
    (elfeed-search-live-filter)))
#+END_SRC
*** Consuming Media
When reading articles in =elfeed-show-mode=, the content spans the entire buffer.
I like to read my content hard-wrapped at 80 chars, so I customize the built-in
=shr-width= ("Simple HTML Renderer," which is what Elfeed uses).
#+BEGIN_SRC emacs-lisp
(setq shr-width 80)
#+END_SRC
For YouTube videos, I like to play them right from Emacs with =mpv=.
#+BEGIN_SRC emacs-lisp
(defvar gm/elfeed-mpv-patterns
  '("youtu\\.?be")
  "List of regexp to match against elfeed entry link to know
whether to use mpv to visit the link.")

(defun gm/search-local-yt-video (id dir)
  (let ((default-directory dir))
    (with-temp-buffer
      (shell-command
       (format "find . -regextype sed -regex '.*\\[%s\\].mkv'" id)
       (current-buffer))
      (unless (string= (buffer-string) "")
        (expand-file-name (buffer-substring-no-properties (+ 2 (line-beginning-position)) (line-end-position)) default-directory)))))

(defun gm/elfeed-play-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let (entry title link)
    (if (eq major-mode 'elfeed-show-mode)
        (setq entry elfeed-show-entry)
      (setq entry (elfeed-search-selected :single))
      (elfeed-search-untag-all-unread))
    (setq title (elfeed-entry-title entry))
    (setq link (elfeed-entry-link entry))
    (let*
        ((id (nth 1 (s-split "watch\\?v=" link)))
         (video (gm/search-local-yt-video id "~/Videos/YouTube"))
         (drive-video-path (expand-file-name "Videos/YouTube/" gm--drive-path))
         drive-video)
      (when (and (not video) (file-directory-p drive-video-path))
        (when-let ((drive-video (gm/search-local-yt-video id drive-video-path)))
          (setq video drive-video)))
      (if video
          (progn
            (message "Playing \"%s\" from local copy..." title)
            (setq link video))
        (message "Streaming \"%s\"..." title)))
    (start-process "elfeed-mpv" nil "mpv" "--fs" link)))
#+END_SRC
We make a multi-purpose function to open the link with =mpv= if it is a video,
otherwise with the browser.
#+BEGIN_SRC emacs-lisp
(defun gm/elfeed-visit-or-play-with-mpv ()
  "Play in mpv if entry link matches `gm/elfeed-mpv-patterns', visit otherwise.
See `gm/elfeed-play-with-mpv'."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
        (patterns gm/elfeed-mpv-patterns))
    (while (and patterns
                (not (string-match (car gm/elfeed-mpv-patterns)
                                   (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (if patterns
        (gm/elfeed-play-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC
I don't want Firefox stealing the focus, because I like opening many links from
Emacs, then switching to Firefox to read them all. To fix this, I toggle
=browser.tabs.loadDivertedInBackground= to =true=, as per [[https://stackoverflow.com/questions/10506496/run-browse-url-in-emacs-without-giving-focus-to-the-browser][this SO post]].
We bind it to =o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(bind-key "o" #'gm/elfeed-visit-or-play-with-mpv elfeed-show-mode-map)
(bind-key "o" #'gm/elfeed-visit-or-play-with-mpv elfeed-search-mode-map)
#+END_SRC
Sometimes I want to download videos to watch them later or in higher quality.
For this I use skeeto's =youtube-dl=.
#+BEGIN_SRC emacs-lisp
(autoload #'youtube-dl "youtube-dl")
(setq youtube-dl-directory "~/Videos/YouTube")
#+END_SRC
I wrap it for use in =elfeed=.
#+BEGIN_SRC emacs-lisp
(defun gm/youtube-dl ()
  (interactive)
  (let* ((entry-full (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
         (entry (elfeed-entry-link entry-full)))
    (youtube-dl entry)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-settings
(bind-key "d" #'gm/youtube-dl elfeed-show-mode-map)
(bind-key "d" #'gm/youtube-dl elfeed-search-mode-map)
#+END_SRC
*** Hydra
I use a hydra to easily navigate between groups of feeds.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra gm/elfeed-hydra ()
  "filter"
  ("a" (elfeed-search-set-filter "@6-months-ago") "All")
  ("c" (elfeed-search-set-filter "@6-months-ago +cs") "CS")
  ("e" (elfeed-search-set-filter "@6-months-ago +emacs") "Emacs")
  ("*" (elfeed-search-set-filter "@6-months-ago +starred") "Starred")
  ("t" (elfeed-search-set-filter "@1-day-ago") "Today")
  ("M" gm/elfeed-toggle-star "Mark")
  ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
  ("q" nil "quit" :color blue))
#+END_SRC
** Music
I got the setup information from [[https://www.reddit.com/r/emacs/comments/981khz/emacs_music_player_with_emms/][Reddit]] and [[https://www.youtube.com/watch?v=xTVN8UDScqk][this video]].
#+BEGIN_SRC emacs-lisp :noweb yes
(defun gm/emms-setup ()
  (add-to-list 'load-path "~/.emacs.d/elisp/emms/lisp/")
  (require 'emms-setup)
  (require 'emms-player-mpd)
  (emms-all)
  (require 'emms-mode-line)
  (emms-mode-line 1)
  (require 'emms-playing-time)
  (emms-playing-time 1)
  <<emms>>)
#+END_SRC
Now for the settings. I use =mpd=, which I find is minimal and causes no bloat.
#+BEGIN_SRC emacs-lisp :noweb-ref emms
(setq emms-seek-seconds 5
      emms-player-list '(emms-player-mpd)
      emms-info-list '(emms-info-mpd)
      emms-player-mpd-server-name "localhost"
      emms-player-mpd-server-port "6601"
      emms-source-file-default-directory "~/Music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t)
#+END_SRC
We use non-default settings for the socket. In order to use the built-in
functionality for =mpc=, we need to let Emacs know about this.
#+BEGIN_SRC emacs-lisp :noweb-ref emms
(setq mpc-host "localhost:6601")
#+END_SRC
When the music I have isn't tagged right or needs some editing, I use the
command line tool =id3v2= for quick or repetitive jobs. When appropriate, I prefer
the GUI application =easytag=.
*** Starting MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/start-music-daemon ()
  "Start MPD, connects to it and syncs the metadata cache."
  (interactive)
  (shell-command "mpd")
  (emms-player-mpd-update-all-reset-cache)
  (emms-player-mpd-connect)
  (emms-cache-set-from-mpd-all)
  (message "MPD Started!"))
#+END_SRC
*** Killing MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/kill-music-daemon ()
  "Stops playback and kill the music daemon."
  (interactive)
  (emms-stop)
  (call-process "killall" nil nil nil "mpd")
  (message "MPD Killed!"))
#+END_SRC
*** Bindings
I use a prefix map to compactify this set of keybindings.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-emms (:color pink :pre (gm/emms-setup))
  "
  ^
  ^EMMS^            ^Track^             ^MPD (daemon)^
  ^────────^──────────^──────^────────────^───────^─────
  _q_uit            _p_revious          _c_reate
  _e_mms            _n_ext              _k_ill
  _b_rowse          _P_ause             _r_eload
  ^^                _B_back (10s)       ^^
  ^^                _F_orward (10s)     ^^
  ^^                ^^                  ^^
  "
  ("q" nil)
  ("e" emms :color blue)
  ("b" emms-smart-browse :color blue)
  ("p" emms-previous)
  ("n" emms-next)
  ("P" emms-pause)
  ("B" emms-seek-backward)
  ("F" emms-seek-forward)
  ("k" mpd/kill-music-daemon)
  ("c" mpd/start-music-daemon)
  ("r" emms-player-mpd-update-all-reset-cache :color blue))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "s-j" #'hydra-emms/body)
#+END_SRC
* Snippets
I use =SPC= instead of the default =TAB= to expand snippets. I find this more
convenient, because it makes typing a snippet more like typing a word. This
works fine apart from one hiccup. We need to bind =TAB= to =org-cycle= (even though
that is the default in Org Mode). Otherwise, binding =TAB= to =nil= in
=yas-minor-mode= overrides the default behaviour.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode yas-global-mode)
  :config
  (yas-global-mode 1)
  (bind-key "<tab>" nil yas-minor-mode-map)
  (bind-key "TAB" nil yas-minor-mode-map)
  (define-key yas-minor-mode-map (kbd "SPC")
    (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
  :custom
  (yas-triggers-in-field t) ; expand snippets within snippets
  (yas-snippet-dirs '("~/.emacs.d/snippets")))
(yas-global-mode 1)
(diminish 'yas-minor-mode " ✂")
#+END_SRC
** QuickMath
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=.
*** Math Symbols
**** Main Math Snippets
#+BEGIN_SRC emacs-lisp
(defcustom gm/math-snippets
  '(("==" "&= ")
    ("=>" "\\implies ")
    ("(" "paren" t)
    ("CC" "\\C")
    ("LL" "\\mathcal{L}")
    ("MM" "\\mathcal{M}")
    ("NN" "\\N")
    ("QQ" "\\Q")
    ("RR" "\\R")
    ("ZZ" "\\Z")
    ("[" "square-brackets" t)
    ("^" "superscript" t)
    ("_" "subscript" t)
    ("abs" "abs" t)
    ("acos" "\\arccos ")
    ("acot" "\\arccot ")
    ("aleph" "\\aleph")
    ("approx" "\\approx ")
    ("asin" "\\arcsin ")
    ("atan" "\\arctan ")
    ("bar" "bar" t)
    ("bigop" "big-operator" t)
    ("binom" "choose" t)
    ("bol" "bol" t)
    ("cb" "^3")
    ("cc" "\\subset ")
    ("ceil" "ceiling" t)
    ("cong" "\\equiv")
    ("cos" "\\cos ")
    ("cot" "\\cot ")
    ("cu" "\\Curl ")
    ("dd" "derivative-one-term" t)
    ("del" "partial" t)
    ("det" "determinant" t)
    ("dim" "\\Dim ")
    ("dint" "dintegral" t)
    ("div" "\\Div ")
    ("dv" "derivative" t)
    ("eq" " = ")
    ("exp" "\\exp ")
    ("fa" "\\forall ")
    ("fl" "floor" t)
    ("fr" "frac" t)
    ("fun" "function" t)
    ("ge" "\\ge ")
    ("gr" "\\Grad ")
    ("hat" "hat" t)
    ("iint" "iintegral" t)
    ("im" "\\Image ")
    ("inf" "\\Inf ")
    ("inn" "\\in ")
    ("int" "integral" t)
    ("inv" "inverse" t)
    ("iso" "\\Iso ")
    ("ker" "\\Ker ")
    ("lap" "laplacian" t)
    ("le" "\\le ")
    ("lim" "limit" t)
    ("list" "list" t)
    ("ln" "\\ln ")
    ("log" "\\log ")
    ("lr9" "parentheses" t)
    ("lr[" "brackets" t)
    ("lr{" "set" t)
    ("mp" "\\mp ")
    ("nabl" "\\nabla ")
    ("ndd" "nth-derivative" t)
    ("ndv" "nth-differential" t)
    ("neq" "neq" t)
    ("norm" "norm" t)
    ("npd" "nth-pderivative" t)
    ("npv" "nth-pdifferential" t)
    ("nsq" "nsqrt" t)
    ("o+" "\\oplus ")
    ("oint" "ointegral" t)
    ("oo" "\\infty")
    ("opl" "\\oplus ")
    ("ox" "\\otimes ")
    ("part" "partial" t)
    ("pd" "partial" t)
    ("pi" "\\pi")
    ("pm" "\\pm ")
    ("prod" "product" t)
    ("prop" "\\propto ")
    ("ps" "pairsum" t)
    ("psum" "pairsum" t)
    ("pv" "partial-derivative" t)
    ("sec" "\\sec ")
    ("seq" "sequence" t)
    ("set" "set" t)
    ("sim" "\\sim ")
    ("sin" "\\sin ")
    ("span" "\\Span")
    ("sq" "sqrt" t)
    ("sr" "^2")
    ("st" ": ")
    ("star" "^\\star ")
    ("sum" "sum" t)
    ("sup" "\\Sup ")
    ("tan" "\\tan ")
    ("then" "\\implies ")
    ("to" "\\to ")
    ("tr" "trace" t)
    ("vv" "\\vec ")
    ("xii" "x_i")
    ("xx" "\\times "))
  "Contains lists (KEY EXPANSION SNIPPET). When KEY is typed, it
  will be replaced with EXPANSION. If SNIPPET is non-nil,
  EXPANSION is taken to be a loaded yasnippet. Otherwise, it is
  considered the replacement string."
  :group 'quick-math)
#+END_SRC
**** Hydras
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta") "β")
  ("C" (insert "\\mathbb{C}") "ℂ")
  ("d" (insert "\\delta") "δ")
  ("D" (insert "\\Delta") "Δ")
  ("e" (insert "\\epsilon") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi") "φ")
  ("F" (insert "\\Phi") "Φ")
  ("g" (insert "\\gamma") "γ")
  ("G" (insert "\\Gamma") "Γ")
  ("h" (insert "\\eta") "η")
  ("k" (insert "\\kappa") "κ")
  ("l" (insert "\\lambda") "λ")
  ("L" (insert "\\Lambda") "Λ")
  ("m" (insert "\\mu") "µ")
  ("n" (insert "\\nu") "ν")
  ("N" (insert "\\nabla ") "∇")
  ("o" (insert "\\omega") "ω")
  ("O" (insert "\\Omega") "Ω")
  ("p" (insert "\\pi") "π")
  ("P" (insert "\\Pi") "Π")
  ("q" (insert "\\theta") "θ")
  ("Q" (insert "\\mathbb{Q}") "ℚ")
  ("r" (insert "\\rho") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma") "σ")
  ("t" (insert "\\tau") "τ")
  ("u" (insert "\\upsilon") "υ")
  ("U" (insert " \\cup ") "∪")
  ("v" (insert "\\vec ") "v")
  ("w" (insert "\\xi") "ξ")
  ("W" (insert "\\Xi") "Ξ")
  ("x" (insert "\\chi") "χ")
  ("y" (insert "\\psi") "ψ")
  ("Y" (insert "\\Psi") "Ψ")
  ("z" (insert "\\zeta") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert " \\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert " \\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph") "ℵ")
  ("e" (insert "\\varepsilon") "ε")
  ("f" (insert "\\phi") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell") "ℓ")
  ("q" (insert "\\Theta") "Θ")
  ("r" (insert "\\varrho") "ρ")
  ("U" (insert "\\cap ") "∩")
  ("x" (insert " \\times ") "×")
  ("." (insert " \\cdots ") "···"))
#+END_SRC
Then we bind this to semicolon.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key gm/math-mode-map ";" #'hydra-semicolon-a/body (gm/in-math-p))
#+END_SRC
*** Helper Functions
**** QuickMath Minor Mode
#+BEGIN_SRC emacs-lisp :noweb yes
(defvar gm/math-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map org-mode-map)
    map))
<<math-mode>>

(define-minor-mode quick-math-mode
  "Minor mode for math"
  :init-value nil
  :keymap gm/math-mode-map
  (when quick-math-mode
    (gm/math-setup)))
#+END_SRC
**** Simpler =texmathp=
The default =texmathp= function assumes that you are writing valid LaTeX code.
This is all well and good when you are actually writing LaTeX, where things like
the dollar sign have only one meaning, but I write documents almost entirely in
Org Mode (I export them to LaTeX). Here the function easily gets confused. So I
make my own for checking if you are in math mode, which leverages Org Mode's
font-locking to narrow down the area we need to check. We first make a list of
math environments that our function will look for.
#+BEGIN_SRC emacs-lisp
(defvar gm/math-environments '("equation" "align")
  "The environments `gm/in-math-p' assumes as valid math environments.")
#+END_SRC
The only way we're in math mode is if we're in a LaTeX fragment. However, the
latter sometimes returns false positives when it comes to math mode. That is, we
can be in a LaTeX fragment (like a =figure= environment) without being in math
mode.

When Org says we're in inline LaTeX, we're definitely in math mode. If we're in
an environment, we check from the beginning of the environment to the point. If
there are more opening delimiters than closing ones (more of =\begin{ENV}= then
=\end{ENV}=, where =ENV= is an element of =gm/math-environments=), then the point must
be in math. The one subtlety is that we also look at the starred versions of
=ENV=.
#+BEGIN_SRC emacs-lisp
(defun gm/in-math-p (&optional loc)
  (unless loc (setq loc (point)))
  (defun gm/--in-math-p (begin-delim)
    (concat begin-delim (regexp-opt gm/math-environments) "[\\*]?}"))
  (let* ((fr (org-element-context))
         (fr-type (car fr))
         (begin (org-element-property :begin fr)))
    (cond ((eq fr-type 'latex-fragment)
           (and
            (>= loc begin)
            (<= loc (1- (- (org-element-property :end fr)
                           (org-element-property :post-blank fr))))))
          ((eq fr-type 'latex-environment)
           (let ((env-open (how-many (gm/--in-math-p "\\\\begin{") begin loc))
                 (env-close (how-many (gm/--in-math-p "\\\\end{") begin loc)))
             (> (- env-open env-close) 0))))))
#+END_SRC
**** Enter Math Mode
Enter a math fragment if inside one, exit otherwise. We keep track of the number
of blank lines that follow the fragment, because according to Org, an =equation=
environment doesn't end until the first non-newline character that follows. This
makes for some awkward timing for activating previews.
#+BEGIN_SRC emacs-lisp
(defun gm/create-or-exit-math-fragment ()
  (interactive)
  (if (gm/in-math-p)
      (gm/reformat-fragment)
    (insert "\\(")
    (save-excursion (insert "\\)"))))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point, or =loc= if provided.
#+BEGIN_SRC emacs-lisp
(defun gm/last-n-chars (n &optional loc)
  (unless loc (setq loc (point)))
  (let ((start (- loc n)))
    (when (and (>= start (point-min))
               (<= start (point-max)))
      (buffer-substring-no-properties (- loc n) loc))))
#+END_SRC
**** Last LaTeX Letter
Postfix commands often act on the last letter. For example, I want =fhat= to
expand into =\hat{f}=. However, we cannot just act on the last letter, because
=\betahat= should expand into =\hat{beta}=, not the invalid =\bet\hat{a}=.
#+BEGIN_SRC emacs-lisp
(defun gm/last-letter ()
  (when (string-match "[a-zA-Z]" (gm/last-n-chars 1))
    (if (looking-back (regexp-opt
                       (--map (concat "\\" (car it))
                              (append gm/math-greek-lower
                                      gm/math-greek-upper)))
                      (- (point) 8) t)
        (buffer-substring-no-properties (match-beginning 0)
                                        (match-end 0)))
    (char-to-string (char-before))))
#+END_SRC
**** Test if LaTeX Needs to Be Wrapped in Brackets
#+BEGIN_SRC emacs-lisp
(defun gm/math-expression-p (math)
  (when math
    (or (eq (length math) 1)
        ;; match one single latex command, with opt-args and args
        ;; such as \command[1][2]{3}{4}
        ;; only validate if this is the entire string
        (string-match "\\`\\\\[[:alpha:]]+\\(\\[[^\\]]*]\\)*\\({[^}]*}\\)*\\'" math))))
#+END_SRC
**** Increment Snippet Fields
#+BEGIN_SRC emacs-lisp
(defun gm/increment-snippet-fields (string &optional n)
  (unless n (setq n 1))
  (replace-regexp-in-string "[1-9]+" (lambda (x) (format "%d" (+ n (string-to-number x)))) string))
#+END_SRC
**** Generate Snippets
:PROPERTIES:
:ORDERED:  t
:END:
I wrote this to reduce the amount of redundant code needed to set up the
snippets. First, we create a suffix tree of all the math snippets.
#+BEGIN_SRC emacs-lisp
(defvar gm/longest-snippet)

(defun gm/math-setup ()
  (setq gm/longest-snippet
        (cons (-max (--map (length (car it)) gm/math-snippets))
              (-max (--map (length (cadr it)) gm/math-snippets))))
  (let ((unique-suffixes
         (delete-dups (--map (s-right 1 (car it)) gm/math-snippets))))
    (seq-do (lambda (key)
              (eval `(define-conditional-key gm/math-mode-map
                       ,key (lambda! () (gm/math-snippet-expand ,key))
                       (gm/in-math-p))))
            unique-suffixes)))
#+END_SRC
We make a function to get the possible completion candidates from the buffer.
#+BEGIN_SRC emacs-lisp
(defun gm/buff-cand (n)
  (loop for i from 0 to n
        collect (gm/last-n-chars i)))
#+END_SRC
Then, we set up the creation of an actual snippet (note that its length is
capped at a certain number of characters, defined by =gm/longest-snippet=). The
longest snippet is currently =binom=, for the binomial coefficient (choose
function).
#+BEGIN_SRC emacs-lisp
(defun gm/math-snippet-expand (key)
  (insert key)
  (-when-let* ((buff-cand (gm/buff-cand (car gm/longest-snippet)))
               (completions (--keep (assoc it gm/math-snippets) buff-cand))
               (snippet (--max-by (> (length (car it)) (length (car other)))
                                  completions)))
    ;; this has to be negative, we're deleting back
    (delete-char (- 0 (length (car snippet))))
    ;; this is so we don't have two backslashes after something like \sim
    (when (= (char-before) ?\\) (delete-char -1))
    ;; is this a snippet expansion or just a text insertion?
    (let ((expand (cadr snippet)))
      (if (cddr snippet)
          (yas-expand-snippet (yas-lookup-snippet expand))
        (insert expand)))))
#+END_SRC
Now we give the user a way to easily add snippets.
#+BEGIN_SRC emacs-lisp
(defun gm/new-math-snippet (key name)
  "Creates a new math snippet. Adds the cons (KEY . NAME) to
`gm/math-snippets'. If no snippet with the name NAME exists in
the yasnippet directory for latex-mode, then the such a file is
created. The user can then write the code into which te snippet
should expand."
  (interactive "sSnippet key: \nSnippet name: ")
  (unless (or (s-blank-str? key)
              (s-blank-str? name))
    (push (cons key name) gm/math-snippets)
    (setq file-cand (expand-file-name
                     (format "%s/latex-mode/%s" (car (yas-snippet-dirs)) name)))
    (unless (file-exists-p file-cand)
      (find-file file-cand)
      (yas-expand-snippet (yas-lookup-snippet "new-math-snippet")))
    (gm/math-setup)))
#+END_SRC
A very rudimentary command to see all current snippet keys and expansions.
#+BEGIN_SRC emacs-lisp
(defun gm/view-snippets ()
  (interactive)
  (with-output-to-temp-buffer "*QuickMath Expansions*"
    (let ((key-len (+ 4 (car gm/longest-snippet)))
          (snip-len (cdr gm/longest-snippet)))
      (princ (format "Key%s  Snippet%s\n%s%s\n"
                     (make-string (- key-len 4) ? )
                     (make-string (- snip-len 8) ? )
                     (make-string key-len ?-)
                     (make-string (1+ snip-len) ?-)))
      (dolist (snippet gm/math-snippets)
        (princ (format "%s %s\n"
                       (concat
                        (car snippet)
                        (make-string (- key-len (length (car snippet))) ? ))
                       (nth 1 snippet)))))))
#+END_SRC
**** Tab Jump to Next LaTeX Position
Modified from the =cdlatex-tab= function in =cdlatex.el=.
#+BEGIN_SRC emacs-lisp
(defun math-tab ()
  (interactive)
  (catch 'stop
    (cond
     ((looking-at "}\\|\\]\\|)")
      (forward-char 1)
      (if (or (looking-at "\\\\") (looking-at "[^_\\^({\\[]"))
          (throw 'stop t)))
     ((= (following-char) ?$)
      (while (= (following-char) ?$) (forward-char 1))
      (throw 'stop t))
     ((= (following-char) ?\ )
      (forward-char 1)
      (re-search-forward "[^ ]")
      (if (/= (preceding-char) ?\n) (forward-char -1)))
     (t
      (forward-char 1)))
    (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
      (forward-char -1)
      (cond
       ((= (following-char) ?\ )
        (if (not (bolp)) (forward-char 1)) (throw 'stop t))
       ((= (following-char) ?\n)
        (if (and (bolp) (not (eobp)))
            (throw 'stop t)
          (if (equal "\\\\" (buffer-substring-no-properties
                             (- (point) 2) (point)))
              (forward-char 1)
            (throw 'stop t))))
       (t
        (if (or (= (char-syntax (preceding-char)) ?\()
                (= (char-syntax (preceding-char)) ?\))
                (= (preceding-char) ?-))
            (throw 'stop t)
          (forward-char 1)
          (if (looking-at "[^_\\^({\\[]")
              (throw 'stop t)))))))
  (unless (gm/in-math-p)
    (forward-char -1)
    (gm/reformat-fragment)))
#+END_SRC
Bind to tab.
#+BEGIN_SRC emacs-lisp
(define-conditional-key gm/math-mode-map (kbd "<tab>") #'math-tab (gm/in-math-p))
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as $x_0$ or $a_{18}$. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering. I also rarely enter a
numbered subscript of more than two digits, so I also exit the brackets after
creating them.
#+BEGIN_SRC emacs-lisp
(defun gm/math-number-subscript (n)
  (insert n)
  (cond ((string-match "[a-zA-Z][0-9]" (gm/last-n-chars 2))
         (save-excursion
           (backward-char)
           (insert "_")))
        ((string-match "\_[0-9][0-9]" (gm/last-n-chars 3))
         (save-excursion
           (backward-char 2)
           (insert "\{"))
         (insert  "\}"))))
#+END_SRC
Add subscript bindings to each of the ten digits.
#+BEGIN_SRC emacs-lisp
(cl-loop for i from 0 to 9
         collect (eval (macroexpand `(define-conditional-key gm/math-mode-map
                (number-to-string ,i)
                (lambda! () (gm/math-number-subscript (number-to-string ,i)))
              (gm/in-math-p)))))
#+END_SRC
**** Fraction
Typing =/= after an appropriate block (a number or a balanced set of parentheses)
creates a fraction with this block in the numerator and the point in the
denominator. The outside parentheses will be removed; for example, =(\sin x)/=
results in =\frac{\sin x}{|}=.
#+BEGIN_SRC emacs-lisp
(defun gm/math-insert-frac-match (match)
  (when match
    (yas-expand-snippet (yas-lookup-snippet "frac"))
    (insert match)
    (yas-next-field)))

(defun gm/math-frac-helper (regexp)
  (when (looking-back regexp (line-beginning-position) t)
    (let* ((begin (match-beginning 0))
           (end (match-end 0))
           (match (buffer-substring-no-properties begin end)))
      (delete-region begin end)
      (gm/math-insert-frac-match match))))

(defun gm/math-frac ()
  (interactive)
  (cond
   ((string-match "[\])]" (char-to-string (char-before)))
    (let ((end (point))
          match)
      (backward-sexp)
      (setq match (buffer-substring-no-properties (point) end))
      (delete-region (point) end)
      (gm/math-insert-frac-match (substring match 1 -1))))
   ((string-match "}" (char-to-string (char-before)))
    (gm/math-frac-helper "[\\][a-z]*[\[{].*[\]}]"))
   ((string-match "[[:alnum:]!]" (char-to-string (char-before)))
    (gm/math-frac-helper "[\\]?[[:alnum:]_^!]*"))
   (t (yas-expand-snippet (yas-lookup-snippet "frac")))))

(define-conditional-key gm/math-mode-map "/" #'gm/math-frac (gm/in-math-p))
#+END_SRC
**** Easy Split Environments
I wanted to make writing environments like =split= and =align= easier, so that I
wouldn't have to manually add the newline (=\\=) at the end of each line required
to make LaTeX happy.
#+BEGIN_SRC emacs-lisp
(defun gm/math-split-p ()
  (when (gm/in-math-p)
    (save-excursion
      (if (eq major-mode 'org-mode)
          (org-backward-paragraph)
        (backward-paragraph))
      (forward-line)
      (equal (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))
             "\\begin{split}"))))

(defun gm/tex-newline ()
  (interactive)
  (if (equal (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))
             "\\begin{split}")
      (newline)
    (end-of-line)
    (if (equal (gm/last-n-chars 2) "\\\\")
        (forward-line)
      (insert " \\\\")
      (newline))))

(define-conditional-key gm/math-mode-map (kbd "RET") #'gm/tex-newline (gm/math-split-p))
#+END_SRC
**** Ignore
I'm just going to do a couple tests out here, just to see how the general typing
experience works out.
